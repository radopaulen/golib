<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GOLIB: Polyhedral Relaxations for Factorable Programs</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GOLIB
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('page_FPRELAX.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Polyhedral Relaxations for Factorable Programs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="author"><dt><b>Author:</b></dt><dd>Benoit C. Chachuat </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.1 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2011 </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>No known bugs.</dd></dl>
<h2><a class="anchor" id="sec_FPREL_bkg"></a>
What Is Meant by Polyhedral Relaxations?</h2>
<p>Consider the mathematical program <img class="formulaInl" alt="$\mathcal{P}:\min\{f({\bf x}): {\bf x}^{\rm L}\leq{\bf x}\leq{\bf x}^{\rm L}, g_j({\bf x})\leq 0, j=1,\ldots,n_g\}$" src="form_0.png"/>, where <img class="formulaInl" alt="$f$" src="form_1.png"/> and <img class="formulaInl" alt="$g_j, j=1,\ldots,n_g$" src="form_2.png"/>, are factorable, potentially nonconvex, real-valued functions. A mathematical program <img class="formulaInl" alt="$\mathcal{R}$" src="form_3.png"/> is said to be a <em>convex relaxation</em> of <img class="formulaInl" alt="$\mathcal{P}$" src="form_4.png"/> if (i) it is convex, and (ii) its optimal solution value underestimates the optimal solution value of <img class="formulaInl" alt="$\mathcal{P}$" src="form_4.png"/>. Moreover, if all the functions (objective and constraints) in <img class="formulaInl" alt="$\mathcal{R}$" src="form_3.png"/> are affine, then <img class="formulaInl" alt="$\mathcal{R}$" src="form_3.png"/> is said to be a <em>polyhedral relaxation</em> of <img class="formulaInl" alt="$\mathcal{P}$" src="form_4.png"/>.</p>
<p>The basic procedure to generate a polyhedral relaxation of <img class="formulaInl" alt="$\mathcal{P}$" src="form_4.png"/> follows a three-step procedure: (i) reformulate <img class="formulaInl" alt="$\mathcal{P}$" src="form_4.png"/> by introducing intermediate variables and extra constraints so that all the constraints in the equivalent program <img class="formulaInl" alt="$\widetilde{\mathcal{P}}$" src="form_5.png"/> are either unary and binary operations; (ii) generate convex underestimators and concave overestimators for every constraint in <img class="formulaInl" alt="$\widetilde{\mathcal{P}}$" src="form_5.png"/>; and (iii) outer-approximate the nonlinear under- or over-estimators at given, well-chosen points. Each step is detailed further below.</p>
<ul>
<li><b>Step 1. Decomposition</b> <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathcal{P}:\min_{\bf x}\ &amp; f(\bf x) &amp; \xrightarrow{\displaystyle\text{decomp.}} &amp;&amp; \widetilde{\mathcal{P}}:\min_{\bf v}\ &amp; v_{\rm obj} \\ \text{s.t.}\ &amp; {\bf g}(\bf x) \leq {\bf 0} &amp;&amp;&amp; \text{s.t.}\ &amp; {\bf A}\,{\bf v} = {\bf b} \\ &amp; {\bf x}^{\rm L}\leq {\bf x} \leq {\bf x}^{\rm U} &amp;&amp;&amp; &amp; v_k = v_iv_j, \quad \forall (i,j,k)\in\mathcal{B}\\ &amp; &amp;&amp;&amp; &amp; v_k = \frac{v_i}{v_j}, \quad \forall (i,j,k)\in\mathcal{F}\\ &amp; &amp;&amp;&amp; &amp; v_k = \varphi(v_i), \quad \forall (i,k)\in\mathcal{U}\\ &amp; &amp;&amp;&amp; &amp; {\bf v}^{\rm L}\leq {\bf v} \leq {\bf v}^{\rm U} \end{align*}" src="form_6.png"/>
</p>
 The advantage of this decomposition is that it can be applied to any factorable program, but also that it detects and accounts for common subexpressions, which leads to tighter relaxations. Its main drawback, on the other hand, is that it may introduce a large number of extra variables and constraints.</li>
</ul>
<ul>
<li><b>Step 2. Relaxation</b><ul>
<li>The bilinear terms <img class="formulaInl" alt="$v_k = v_iv_j$" src="form_7.png"/>, <img class="formulaInl" alt="$v_i^{\rm L}\leq v_i\leq v_i^{\rm U}$" src="form_8.png"/>, <img class="formulaInl" alt="$v_j^{\rm L}\leq v_j\leq v_j^{\rm U}$" src="form_9.png"/>, can be replaced by their polyhedral envelopes as <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} v_k=v_iv_j \quad \xrightarrow{\displaystyle\text{relax.}}\quad \left\{\begin{array}{l} v_k \geq v_i^{\rm L}v_j+v_j^{\rm L}v_i-v_i^{\rm L}v_j^{\rm L}\\ v_k \geq v_i^{\rm U}v_j+v_j^{\rm U}v_i-v_i^{\rm U}v_j^{\rm U}\\ v_k \leq v_i^{\rm U}v_j+v_j^{\rm L}v_i-v_i^{\rm U}v_j^{\rm L}\\ v_k \leq v_i^{\rm L}v_j+v_j^{\rm U}v_i-v_i^{\rm L}v_j^{\rm U} \end{array}\right. \end{align*}" src="form_10.png"/>
</p>
</li>
<li>The fractional terms <img class="formulaInl" alt="$v_k = \frac{v_i}{v_j}$" src="form_11.png"/>, <img class="formulaInl" alt="$v_i^{\rm L}\leq v_i\leq v_i^{\rm U}$" src="form_8.png"/>, <img class="formulaInl" alt="$v_j^{\rm L}\leq v_j\leq v_j^{\rm U}$" src="form_9.png"/>, <img class="formulaInl" alt="$0\notin[v_j^{\rm L},v_j^{\rm U}]$" src="form_12.png"/>, can be rewritten as bilinear terms <img class="formulaInl" alt="$v_i = v_jv_k$" src="form_13.png"/> and relaxed as indicated above, with the following bounds for the variables <img class="formulaInl" alt="$v_k$" src="form_14.png"/>: <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \min\left\{\frac{v_j^{\rm L}}{v_k^{\rm L}}, \frac{v_j^{\rm L}}{v_k^{\rm U}}, \frac{v_j^{\rm U}}{v_k^{\rm L}}, \frac{v_j^{\rm U}}{v_k^{\rm U}}\right\} =: v_k^{\rm L} \leq v_k \leq v_k^{\rm U} := \max\left\{\frac{v_j^{\rm L}}{v_k^{\rm L}}, \frac{v_j^{\rm L}}{v_k^{\rm U}}, \frac{v_j^{\rm U}}{v_k^{\rm L}}, \frac{v_j^{\rm U}}{v_k^{\rm U}}\right\} \end{align*}" src="form_15.png"/>
</p>
 It should be noted, however, that this approach, although being straightforward, does not generally yield the convex/concave envelopes for fractional terms (which turn out to be quite complicated nonlinear expressions -- see <a class="el" href="page_FPRELAX.html#sec_FPREL_refs">References</a>). <br/>
</li>
<li>The univariate terms <img class="formulaInl" alt="$v_k = \varphi(v_i)$" src="form_16.png"/>, <img class="formulaInl" alt="$v_i^{\rm L}\leq v_i\leq v_i^{\rm U}$" src="form_8.png"/>, are relaxed differently depending on whether the function <img class="formulaInl" alt="$\varphi$" src="form_17.png"/> is convex, concave, convexo-concave, etc., on <img class="formulaInl" alt="$[v_i^{\rm L},v_i^{\rm U}]$" src="form_18.png"/>. <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \text{convex case:} &amp; \quad v_k=\varphi(v_i) \quad \xrightarrow{\displaystyle\text{relax}} \quad \left\{\begin{array}{l} v_k \geq \varphi(v_i)\\ v_k \leq \varphi(v_i^{\rm L}) + \frac{\varphi(v_i^{\rm U})-\varphi(v_i^{\rm L})}{v_i^{\rm U}-v_i^{\rm L}}(v_i-v_i^{\rm L}) \end{array}\right.\\ \text{concave case:} &amp; \quad v_k=\varphi(v_i) \quad \xrightarrow{\displaystyle\text{relax}} \quad \left\{\begin{array}{l} v_k \geq \varphi(v_i^{\rm L}) + \frac{\varphi(v_i^{\rm U})-\varphi(v_i^{\rm L})}{v_i^{\rm U}-v_i^{\rm L}}(v_i-v_i^{\rm L})\\ v_k \leq \varphi(v_i) \end{array}\right.\\ \text{convexo-concave case:} &amp; \quad v_k=\varphi(v_i) \quad \xrightarrow{\displaystyle\text{relax}} \quad \left\{\begin{array}{l} v_k \geq \left\{\begin{array}{ll} \varphi(v_i), &amp; \text{if $v_i\leq v_{\rm m}^{\rm cv}$}\\ \varphi(v_i^{\rm U}) + \frac{\varphi(v_i^{\rm U})-\varphi(v_{\rm m}^{\rm cv})}{v_i^{\rm U}-v_{\rm m}^{\rm cv}}(v_i-v_i^{\rm U}), &amp; \text{otherwise} \end{array}\right.\\ v_k \leq \left\{\begin{array}{ll} \varphi(v_i), &amp; \text{if $v_i\geq v_{\rm m}^{\rm cc}$}\\ \varphi(v_i^{\rm L}) + \frac{\varphi(v_i^{\rm L})-\varphi(v_{\rm m}^{\rm cc})}{v_i^{\rm L}-v_{\rm m}^{\rm cc}}(v_i-v_i^{\rm L}), &amp; \text{otherwise} \end{array}\right. \end{array}\right.\\ &amp; \quad \text{with:}\ v_{\rm m}^{\rm cv},v_{\rm m}^{\rm cc}\in[v_i^{\rm L},v_i^{\rm U}]:\ \varphi'(v_{\rm m}^{\rm cv}) = \textstyle\frac{\varphi(v_i^{\rm U})-\varphi(v_{\rm m}^{\rm cv})}{v_i^{\rm U}-v_{\rm m}^{\rm cv}} \text{ and } \varphi'(v_{\rm m}^{\rm cc}) = \textstyle\frac{\varphi(v_i^{\rm L})-\varphi(v_{\rm m}^{\rm cc})}{v_i^{\rm L}-v_{\rm m}^{\rm cc}} \end{align*}" src="form_19.png"/>
</p>
 <div class="image">
<img src="exm_uni.png" alt="exm_uni.png"/>
</div>
 <br/>
</li>
</ul>
</li>
<li><b>Step 3. Polyhedral Outer-Approximation</b> Every convex, nonlinear univariate constraint generated in Step 2 is outer-approximated by constructing supporting cuts at a number of well-chosen points. Although the resulting polyhedral relaxations are inherently weaker than the nonlinear relaxations, LP solvers are currently more robust and faster than NLP solvers.<br/>
 An iterative scheme (a.k.a. sandwich algorithm) can be applied that adds linearization points in such a way that the maximum distance <img class="formulaInl" alt="$\delta^{\rm max}$" src="form_20.png"/> between the nonlinear constraint and its polyhedral approximation decreases as the inverse of the square of the number <img class="formulaInl" alt="$n$" src="form_21.png"/> of linearization points; that is, <img class="formulaInl" alt="$\delta^{\rm max}\propto \frac{1}{n^2}$" src="form_22.png"/>. This algorithm proceeds as follows:<ol type="a">
<li>Construct cuts at both interval end-points <img class="formulaInl" alt="$v_i^{\rm L}$" src="form_23.png"/> and <img class="formulaInl" alt="$v_i^{\rm U}$" src="form_24.png"/></li>
<li><b>REPEAT</b><ul>
<li>Identify an interval <img class="formulaInl" alt="$[v_i^\ell,v_i^{\ell+1}]$" src="form_25.png"/> with maximum outer-approximation error</li>
<li>Subdivide <img class="formulaInl" alt="$[v_i^\ell,v_i^{\ell+1}]$" src="form_25.png"/> at a suitably chosen point <img class="formulaInl" alt="$v_i^{\rm new}$" src="form_26.png"/></li>
</ul>
<b>UNTIL</b> <img class="formulaInl" alt="$\text{maximum outer-approximation error} < \varepsilon^{\rm tol}$" src="form_27.png"/></li>
</ol>
In particular, diverse strategies have been proposed for selecting a new linearization point <img class="formulaInl" alt="$v_i^{\rm new}$" src="form_26.png"/>. The <em>interval bisection rule</em> and the <em>maximum error rule</em> are depicted below.</li>
</ul>
<div class="image">
<img src="OAcvx_strategy.png" alt="OAcvx_strategy.png"/>
</div>
<h2><a class="anchor" id="sec_FPREL_impl"></a>
How Are Polyhedral Relaxations Implemented in MC++?</h2>
<p>The class <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a> in MC++ provides an implementation of the abovementionned three-step procedure for the construction polyhedral relaxations for general factorable programs. Both the classes <a class="el" href="classmc_1_1FPRCplex.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Cplex.">mc::FPRCplex</a> (header file <code>fprcplex.h</code>) and <a class="el" href="classmc_1_1FPRGurobi.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Gurobi.">mc::FPRGurobi</a> (header file <code>fprgurobi.h</code>) are derived from <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a> and solve the resulting relaxed programs using, repectively <a href="http://www-01.ibm.com/software/integration/optimization/cplex-optimizer/">CPLEX</a> and <a href="http://www.gurobi.com/">GUROBI</a> as the optimizer, in addition to generate the relaxations.</p>
<p>In constructing the polyhedral relaxations, interval bounds must be calculated for the intermediate factors (the results of both unary and binary operations). This is done in <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a> via standard interval arithmetic, and the template parameter of <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a> is used precisely to specify the desired interval type. This makes it convenient for the user to switch between different interval types. For convenience, MC++ comes with a default interval type named mc::Interval (header file <code>interval.h</code>) that can be used inside <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a>, although it should be noted that mc::Interval is not a validated implementation. For validated interval analysis, it is recommended to use third-party libraries such as <a href="http://www.ti3.tu-harburg.de/Software/PROFILEnglisch.html">PROFIL</a> (header file <code>mcprofil.h</code>) or <a href="http://www.math.uni-wuppertal.de/~xsc/software/filib.html">FILIB++</a> (header file <code>mcfilib.h</code>). The selection of alternative interval types is also possible, yet it involves instantiating the templated structure mc::Op for the corresponding types.</p>
<p>Also note that <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a> is <b>not</b> a verified implementation per se. Indeed, round-off errors are not accounted during the construction of the polyhedral relaxations (no matter whether or not validated interval types are used to propagate bound for the intermediate factors).</p>
<h2><a class="anchor" id="sec_FPREL_val"></a>
How to Generate and Solve a Polyhedral Relaxation of a Factorable Program?</h2>
<p>For illustration, suppose we want to construct a polyhedral relaxation for the following NLP and solve it in order to obtain a lower bound on the global solution: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \max_{\bf x}\ &amp; x_1 + \exp(1-x_2) \\ \text{s.t.} \ &amp; x_1\,\exp(1-x_2) \leq 4 \\ &amp; 3 \leq x_1 \leq 6 \\ &amp; 0 \leq x_2 \leq 4. \end{align*}" src="form_28.png"/>
</p>
<p> The optimizer GUROBI is considered subsequently, along with the default interval type mc::Interval for simplicity:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;interval.h&quot;</span>
      <span class="keyword">typedef</span> mc::Interval I;

<span class="preprocessor">      #include &quot;fprgurobi.h&quot;</span>
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPRGurobi.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Gurobi.">mc::FPRGurobi&lt;I&gt;</a> FPREL;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">mc::FPVar&lt;I&gt;</a> FPVAR;
</pre></div><p>First, the factorable program along with the two participating variables (indexes, ranges) are defined as follows:</p>
<div class="fragment"><pre class="fragment">      FPREL FP;
      FPVAR X1( &amp;FP, 1, I(3.,6.) );
      FPVAR X2( &amp;FP, 2, I(0.,4.) );
</pre></div><p>Next, the objective function and inequality constraint are defined:</p>
<div class="fragment"><pre class="fragment">      FP.set_objective( FPREL::MAX, X1+exp(1-X2) );
      FP.add_constraint( X1*exp(1-X2), FPREL::LE, 4. );
      std::cout &lt;&lt; FP;
</pre></div><p>The last line displays the following information about the factorable program:</p>
<div class="fragment"><pre class="fragment">
    VARIABLES:
      X1 &lt;= [  3.00000e+00 :  6.00000e+00 ]         
      X2 &lt;= [  0.00000e+00 :  4.00000e+00 ]         

    AUXILIARY:
      Z1 &lt;= [ -3.00000e+00 :  1.00000e+00 ]                 Z0 - X2
      Z2 &lt;= [  4.97871e-02 :  2.71828e+00 ]                 EXP( Z1 )
      Z3 &lt;= [  3.04979e+00 :  8.71828e+00 ]                 X1 + Z2
      Z4 &lt;= [  1.49361e-01 :  1.63097e+01 ]                 X1 * Z2
      Z0 &lt;= (I) 1                                           CONSTANT
      Z5 &lt;= (D) 4                                           CONSTANT

    NO CUTS
</pre></div><p>It is seen that 6 auxiliary variables are introduced during the decomposition (step 1), <img class="formulaInl" alt="$z_0,\ldots,z_5$" src="form_29.png"/>, which correspond to the various unary and binary operations in the objective and contraint functions, as well as the (integer and real) constants. Observe, in particular, that the common sub-expression <img class="formulaInl" alt="$\exp(1-x_2)$" src="form_30.png"/> is detected. Bounds are also computed for these auxiliary variables, as indicated.</p>
<p>At this stage, however, the cuts in the polyhedral relaxation (steps 2 and 3) are yet to be generated. This is done as follows:</p>
<div class="fragment"><pre class="fragment">      FP.generate_cuts();
      std::cout &lt;&lt; FP;
</pre></div><p>The following information is now displayed about the factorable program:</p>
<div class="fragment"><pre class="fragment">
    VARIABLES:
      X1 &lt;= [  3.00000e+00 :  6.00000e+00 ]         
      X2 &lt;= [  0.00000e+00 :  4.00000e+00 ]         
    
    AUXILIARY:
      Z1 &lt;= [ -3.00000e+00 :  1.00000e+00 ]                 Z0 - X2
      Z2 &lt;= [  4.97871e-02 :  2.71828e+00 ]                 EXP( Z1 )
      Z3 &lt;= [  3.04979e+00 :  8.71828e+00 ]                 X1 + Z2
      Z4 &lt;= [  1.49361e-01 :  1.63097e+01 ]                 X1 * Z2
      Z0 &lt;= (I) 1                                           CONSTANT
      Z5 &lt;= (D) 4                                           CONSTANT
    
    CUTS:
      + 1.00000e+00Z3 - 1.00000e+00X1 - 1.00000e+00Z2 = 0.00000e+00
      + 1.00000e+00Z1 + 1.00000e+00X2 = 1.00000e+00
      + 1.00000e+00Z4 &lt;= 4.00000e+00
      + 1.00000e+00Z4 - 4.97871e-02X1 - 6.00000e+00Z2 &lt;= -2.98722e-01
      + 1.00000e+00Z4 - 2.71828e+00X1 - 3.00000e+00Z2 &lt;= -8.15485e+00
      - 2.00855e+01Z2 + 1.00000e+00Z1 &lt;= -4.00000e+00
      - 3.67879e-01Z2 + 1.00000e+00Z1 &lt;= 0.00000e+00
      - 9.28087e-01Z2 + 1.00000e+00Z1 &lt;= -9.25371e-01
      - 2.17368e+00Z2 + 1.00000e+00Z1 &lt;= -1.77642e+00
      - 5.44615e-01Z2 + 1.00000e+00Z1 &lt;= -3.92324e-01
      + 1.00000e+00Z4 - 2.71828e+00X1 - 6.00000e+00Z2 &gt;= -1.63097e+01
      + 1.00000e+00Z4 - 4.97871e-02X1 - 3.00000e+00Z2 &gt;= -1.49361e-01
      - 4.00000e+00Z2 + 2.66849e+00Z1 &gt;= -8.20463e+00
</pre></div><p>By default, the cuts in the polyhedral relaxation of a convex univariate terms are generated according to the <em>maximum error rule</em> (see above), and a maximum of 5 cuts are generated for each nonlinear constraint. The cut generation is also controlled by the absolute and relative tolerances on the maximum outer-approximation error, which are both set to <img class="formulaInl" alt="$10^{-3}$" src="form_31.png"/> by default. All these default values can be altered via the options mechanism of <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a>, as explained below in the section <a class="el" href="page_FPRELAX.html#sec_FPREL_opt">What are the Options Relative to the Generation of a Polyhedral Relaxation?</a> below.</p>
<p>Having generated the cuts, a solution to the resulting polyhedral relaxation can be computed as:</p>
<div class="fragment"><pre class="fragment">      FP.solve();
      std::cout &lt;&lt; <span class="stringliteral">&quot;\n  RELAXATION VALUE:   &quot;</span> &lt;&lt; FP.get_objective()
                &lt;&lt; <span class="stringliteral">&quot;\n  RELAXATION OPTIMUM: &quot;</span> &lt;&lt; FP.get_variable(1) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
                                              &lt;&lt; FP.get_variable(2)
                &lt;&lt; <span class="stringliteral">&quot;\n  CPU TIME [sec]:     &quot;</span> &lt;&lt; FP.get_runtime()
                &lt;&lt; std::endl;
</pre></div><p>The following results are obtained:</p>
<div class="fragment"><pre class="fragment">
    RELAXATION VALUE:   6.66667e+00
    RELAXATION OPTIMUM: 6.00000e+00, 3.07531e+00
    CPU TIME [sec]:     1.20902e-03
</pre></div><p>Note that the solution of the polyhedral relaxation corresponds to the global optimum for this simple problem.</p>
<p>Prior to generating the polyhedral relaxation, <b>constraint propagation</b> can be applied as a preprocessing step to tighten the variable bounds. This is done as follows:</p>
<div class="fragment"><pre class="fragment">      FP.propagate_constraints();
      FP.generate_cuts( <span class="keyword">true</span> );
      std::cout &lt;&lt; FP;
</pre></div><p>where the argument `true' passed to the method <a href="classmc_1_1FPRelax.html#a90277409a6e357ca8ff819a3f9201289">mc::FPRelax::generate_cuts</a> indicates that the polyhedral relaxations are to be rebuilt. The following result is displayed:</p>
<div class="fragment"><pre class="fragment">
    VARIABLES:
      X1 &lt;= [  3.00000e+00 :  6.00000e+00 ]         
      X2 &lt;= [  7.12318e-01 :  4.00000e+00 ]         

    AUXILIARY:
      Z1 &lt;= [ -3.00000e+00 :  2.87682e-01 ]                 Z0 - X2
      Z2 &lt;= [  4.97871e-02 :  1.33333e+00 ]                 EXP( Z1 )
      Z3 &lt;= [  3.04979e+00 :  8.71828e+00 ]                 X1 + Z2
      Z4 &lt;= [  1.49361e-01 :  4.00000e+00 ]                 X1 * Z2
      Z0 &lt;= (I) 1                                           CONSTANT
      Z5 &lt;= (D) 4                                           CONSTANT

    CUTS:
      + 1.00000e+00Z3 - 1.00000e+00X1 - 1.00000e+00Z2 = 0.00000e+00
      + 1.00000e+00Z1 + 1.00000e+00X2 = 1.00000e+00
      + 1.00000e+00Z4 &lt;= 4.00000e+00
      + 1.00000e+00Z4 - 4.97871e-02X1 - 6.00000e+00Z2 &lt;= -2.98722e-01
      + 1.00000e+00Z4 - 1.33333e+00X1 - 3.00000e+00Z2 &lt;= -4.00000e+00
      - 2.00855e+01Z2 + 1.00000e+00Z1 &lt;= -4.00000e+00
      - 7.50000e-01Z2 + 1.00000e+00Z1 &lt;= -7.12318e-01
      - 1.79462e+00Z2 + 1.00000e+00Z1 &lt;= -1.58479e+00
      - 3.84904e+00Z2 + 1.00000e+00Z1 &lt;= -2.34782e+00
      - 1.08971e+00Z2 + 1.00000e+00Z1 &lt;= -1.08591e+00
      + 1.00000e+00Z4 - 1.33333e+00X1 - 6.00000e+00Z2 &gt;= -8.00000e+00
      + 1.00000e+00Z4 - 4.97871e-02X1 - 3.00000e+00Z2 &gt;= -1.49361e-01
      - 3.28768e+00Z2 + 1.28355e+00Z1 &gt;= -4.01432e+00
</pre></div><p>Observe, in particular, that constraint propagation could tighten the bounds for variable X2, which results in tighter polyhedral relaxations in turn.</p>
<h2><a class="anchor" id="sec_FPREL_link"></a>
How to Incorporate McCormick, Taylor and McCormick-Taylor Models in the Polyhedral Relaxation of a Factorable Program?</h2>
<p>Polyhedral relaxations can also be constructed for optimization problems that contain terms for which McCormick, Taylor or McCormick-Taylor models are known. One special case where this is particularly useful is for the polyhedral relaxation of dynamic systems described by differential equations.</p>
<h3><a class="anchor" id="ssec_FPREL_link_TM"></a>
Incorporation of Taylor and McCormick-Taylor Models in a Polyhedral Relaxation</h3>
<p>For illustration, suppose we want to construct and solve a polyhedral relaxation for the same NLP as before: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \max_{\bf x}\ &amp; x_1 + \exp(1-x_2) \\ \text{s.t.} \ &amp; x_1\,\exp(1-x_2) \leq 4 \\ &amp; 3 \leq x_1 \leq 6 \\ &amp; 0 \leq x_2 \leq 4, \end{align*}" src="form_32.png"/>
</p>
<p> but with the use of a McCormick-Taylor model of order 4 for the subexpression <img class="formulaInl" alt="$\exp(1-x_2)$" src="form_30.png"/> (see Page page_TAYLOR for a description of how to compute Taylor Model for factorable functions). An implementation of this problem is the following:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;interval.h&quot;</span>
<span class="preprocessor">      #include &quot;tmodel.h&quot;</span>
<span class="preprocessor">      #include &quot;mccormick.h&quot;</span>
<span class="preprocessor">      #include &quot;fprgurobi.h&quot;</span>
      <span class="keyword">typedef</span> mc::Interval I;
      <span class="keyword">typedef</span> mc::McCormick&lt;I&gt; MC;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPRGurobi.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Gurobi.">mc::FPRGurobi&lt;I&gt;</a> FPREL;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">mc::FPVar&lt;I&gt;</a> FPVAR;
      <span class="keyword">typedef</span> mc::TModel&lt;MC&gt; TMMC;
      <span class="keyword">typedef</span> mc::TVar&lt;MC&gt; TVMC;
      <span class="keyword">typedef</span> mc::TModel&lt;FPVAR&gt; TMFPVAR;

      FPREL FP;
      FPVAR X1( &amp;FP, 1, I(3.,6.) );
      FPVAR X2( &amp;FP, 2, I(0.,4.) );

      TMMC TMod( 1, 4 );
      <span class="keywordtype">double</span> X2_Ref[1] = { 2. };
      MC X2_MC( I(0.,4.), X2_Ref[0] );
      X2_MC.sub( 1, 0 );
      TVMC X2_TMMC( &amp;TMod, 0, X2_MC );
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TMod2FP[1] = { 2 };
      TVMC X3_TMMC = exp( 1 - X2_TMMC );
      TMFPVAR*TModFP = FP.create_TModel( &amp;TMod, TMod2FP );
      FPVAR X3( &amp;FP, X3_TMMC, TModFP, X2_Ref, TMod2FP );
      <span class="keyword">delete</span> TModFP;
</pre></div><p>The last line initializes the variable X3 as a polyhedral enclosure of the McCormick-Taylor model X3_TMMC. Note that this constructor also requires to pass:</p>
<ul>
<li>(i) a pointer [TModFP] to a mc::TModel&lt;mc::FPVar&gt; object corresponding to the actual McCormick-taylor model mc::TModel&lt;mc::McCormick&gt;. This pointer can be created with the member function TModFP in <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a>, can be reused to append polyhedral relaxations of multiple McCormick-Taylor models in the same variables (e.g., for the solutions of parametric ODE systems), and must be deleted before coming out of scope to avoid memory leaks;</li>
<li>(ii) a pointer [X2_Ref] to the point at which the McCormick relaxation of the remainder term was computed; and</li>
<li>(iii) a pointer [TMod2FP] to an array matching the indexes of the variable that participate in the McCormick relaxation of the remainder term (subgradient components) to those of the factorable program.</li>
</ul>
<p>At this point, the definition of the objective function and inequality constraint, the construction of the polyhedral relaxation, and its solution are the same as previously:</p>
<div class="fragment"><pre class="fragment">      FP.set_objective( FPREL::MAX, X1+X3 );
      FP.add_constraint( X1*X3, FPREL::LE, 4. );
      FP.generate_cuts();
      FP.solve();
      std::cout &lt;&lt; <span class="stringliteral">&quot;\n  RELAXATION VALUE:   &quot;</span> &lt;&lt; FP.get_objective()
                &lt;&lt; <span class="stringliteral">&quot;\n  RELAXATION OPTIMUM: &quot;</span> &lt;&lt; FP.get_variable(1) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
                                              &lt;&lt; FP.get_variable(2)
                &lt;&lt; <span class="stringliteral">&quot;\n  CPU TIME [sec]:     &quot;</span> &lt;&lt; FP.get_runtime()
                &lt;&lt; std::endl;
      std::cout &lt;&lt; FP;
</pre></div><p>The following results are obtained:</p>
<div class="fragment"><pre class="fragment">
    RELAXATION VALUE:   6.66667e+00
    RELAXATION OPTIMUM: 6.00000e+00, 6.47938e-01
    CPU TIME [sec]:     1.82295e-03
</pre></div><h3><a class="anchor" id="ssec_FPREL_link_MC"></a>
Incorporation of McCormick Relaxations in a Polyhedral Relaxation</h3>
<p>Suppose instead that a McCormick relaxation is known for the subexpression <img class="formulaInl" alt="$\exp(1-x_2)$" src="form_30.png"/> (see Page page_MCCORMICK for a description of how to compute McCormick relaxations for factorable functions). The implementation is changed as follows:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">      #include &quot;interval.h&quot;</span>
<span class="preprocessor">      #include &quot;mccormick.h&quot;</span>
<span class="preprocessor">      #include &quot;fprgurobi.h&quot;</span>
      <span class="keyword">typedef</span> mc::Interval I;
      <span class="keyword">typedef</span> mc::McCormick&lt;I&gt; MC;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPRGurobi.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Gurobi.">mc::FPRGurobi&lt;I&gt;</a> FPREL;
      <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">mc::FPVar&lt;I&gt;</a> FPVAR;

      FPREL FP;
      FPVAR X1( &amp;FP, 1, I(3.,6.) );
      FPVAR X2( &amp;FP, 2, I(0.,4.) );

      <span class="keywordtype">double</span> X2_REF[1] = { 2. };
      MC X2_MC( I(0.,4.), X2_Ref[0] );
      X2_MC.sub( 1, 0 );
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TMod2FP[1] = { 2 };
      MC X3_MC = exp(1-X2_MC);
      FPVAR X3( &amp;FP, X3_MC, X2_Ref, TMod2FP );

      FP.set_objective( FPREL::MAX, X1+X3 );
      FP.add_constraint( X1*X3, FPREL::LE, 4. );
      FP.generate_cuts();
      FP.solve();
      std::cout &lt;&lt; <span class="stringliteral">&quot;\n  RELAXATION VALUE:   &quot;</span> &lt;&lt; FP.get_objective()
                &lt;&lt; <span class="stringliteral">&quot;\n  RELAXATION OPTIMUM: &quot;</span> &lt;&lt; FP.get_variable(1) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
                                              &lt;&lt; FP.get_variable(2)
                &lt;&lt; <span class="stringliteral">&quot;\n  CPU TIME [sec]:     &quot;</span> &lt;&lt; FP.get_runtime()
                &lt;&lt; std::endl;
      std::cout &lt;&lt; FP;
</pre></div><p>In this case, the variable X3 is initialized with a polyhedral enclosure of the McCormick relaxation X3_MC, as computed from the available subgradient information. As with McCormick-Taylor models, the corresponding constructor requires to pass: (i) a pointer to the point at which the McCormick relaxation was computed [X2_REF]; and (ii) a pointer to an array matching the indexes of the variable that participate in the McCormick relaxation to those of the factorable program [X2_TMMC].</p>
<p>The following results are obtained:</p>
<div class="fragment"><pre class="fragment">
  RELAXATION VALUE:   6.66667e+00
  RELAXATION OPTIMUM: 6.00000e+00, 3.07531e+00
  CPU TIME [sec]:     1.19686e-03
</pre></div><h2><a class="anchor" id="sec_FPREL_opt"></a>
What are the Options Relative to the Generation of a Polyhedral Relaxation?</h2>
<p>All the options are defined in the structure <a class="el" href="structmc_1_1FPRelax_1_1Options.html" title="FPRelax options.">mc::FPRelax::Options</a>. The current options are:</p>
<table  border="1">
<caption align="bottom"><em>Options in <a class="el" href="structmc_1_1FPRelax_1_1Options.html" title="FPRelax options.">mc::FPRelax::Options</a>: name, type and description</em></caption>
<tr>
<th><b>Name</b> </th><td><b>Type</b></td><td><b>Default</b> </td><td><b>Description</b> </td></tr>
<tr>
<th><code>SANDWICH_ATOL</code> </th><td><code>double</code> </td><td>1e-3 </td><td>Absolute tolerance in the outer approximation of convex/concave univariate terms using the sandwich algorithm </td></tr>
<tr>
<th><code>SANDWICH_RTOL</code> </th><td><code>double</code> </td><td>1e-3 </td><td>Relative tolerance in the outer approximation of convex/concave univariate terms using the sandwich algorithm </td></tr>
<tr>
<th><code>SANDWICH_MAXCUT</code> </th><td><code>integer</code> </td><td>5 </td><td>Maximum number of cuts in the outer approximation of convex/concave univariate terms using the sandwich algorithm </td></tr>
<tr>
<th><code>SANDWICH_RULE</code> </th><td><code><a class="el" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846" title="Enumeration type for sandwich strategy.">mc::FPRelax::Options::SANDWICH</a></code> </td><td><a class="el" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62" title="Maximum error rule.">mc::FPRelax::Options::MAXERR</a> </td><td>Strategy for outer approximation of convex/concave univariate terms using the sandwich algorithm: bisection (<a class="el" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a7df2113bf9806331b80e4ef543153332" title="Interval bisection.">mc::FPRelax::Options::BISECT</a>); maximum error rule (<a class="el" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62" title="Maximum error rule.">mc::FPRelax::Options::MAXERR</a>) </td></tr>
<tr>
<th><code>NEWTON_USE</code> </th><td><code>bool</code> </td><td>true </td><td>Whether to use the Newton/secant method to calculate convex/concave envelopes for concavo-convex univariate functions (including odd monomial terms, sine, cosine, erf, erfc, etc.) </td></tr>
<tr>
<th><code>NEWTON_TOL</code> </th><td><code>double</code> </td><td>1e-10 </td><td>Termination tolerance in the Newton/secant method </td></tr>
<tr>
<th><code>NEWTON_MAXIT</code> </th><td><code>int</code> </td><td>100 </td><td>Maximum number of iterations in the Newton/secant method </td></tr>
<tr>
<th><code>RRLT_STRATEGY</code> </th><td><code><a class="el" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544c" title="Enumeration type for reduced (R)RLT strategy.">mc::FPRelax::Options::RRLT</a></code> </td><td><a class="el" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544caffeb2bb1119a114a5b37da3b36810c32" title="RRLT with primary variables as operands only.">mc::FPRelax::Options::PRIMRRLT</a> </td><td>Strategy for reduced (R)RLT constraints; no cuts (mc::FPRelax::Options::NORRLT); cuts involved primary variables as multipliers only (<a class="el" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544caffeb2bb1119a114a5b37da3b36810c32" title="RRLT with primary variables as operands only.">mc::FPRelax::Options::PRIMRRLT</a>); cuts involved primary and auxiliary variables as multipliers (<a class="el" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544ca02780cf42d2191976b6c28dcd941195d" title="RRLT with primary and auxiliary variables as operands.">mc::FPRelax::Options::ALLRRLT</a>) </td></tr>
<tr>
<th><code>RRLT_DISPLAY</code> </th><td><code>unsigned int</code> </td><td>0 </td><td>Display level during reduced (R)RLT constraint generation; 0-no display; 1-RLT result only; &gt;1-full display </td></tr>
</table>
<p>The <a class="el" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax</a> class has a public static member called mc::FPRelax::options that can be used to set/modify the options; for example:</p>
<div class="fragment"><pre class="fragment">      FP.options.SANDWICH_ATOL = 1e-3;
      FP.options.SANDWICH_RTOL = 1e-3;
      FP.options.SANDWICH_MAXCUT = 5;
      FP.options.NEWTON_USE = <span class="keyword">true</span>;
      FP.options.NEWTON_TOL = 1e-12;
      FP.options.NEWTON_MAXIT = 100;
      FP.options.SANDWICH_RULE = <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62" title="Maximum error rule.">mc::FPRelax::Options::MAXERR</a>;
      FP.options.RRLT_STRATEGY = <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544caffeb2bb1119a114a5b37da3b36810c32" title="RRLT with primary variables as operands only.">mc::FPRelax::Options::PRIMRRLT</a>;
</pre></div><h2><a class="anchor" id="sec_FPREL_err"></a>
What Errors Can Be Encountered during the Calculation of an LP Relaxation of a Factorable Program?</h2>
<p>Errors are managed based on the exception handling mechanism of the C++ language. Each time an error is encountered, an instance of the class <a class="el" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">mc::FPRelax::Exceptions</a> is thrown, which contains the type of error. It is the user's responsibility to test whether an exception was thrown during an LP relaxation, and then make changes where appropriate. Should an exception be thrown and not caught by the calling program, execution will abort.</p>
<p>Possible errors encountered during the calculation of an LP relaxation are:</p>
<table  border="1">
<caption align="bottom"><em>Errors during Calculation of an LP relaxation</em></caption>
<tr>
<th><b>Number</b> </th><td><b>Description</b> </td></tr>
<tr>
<th><code>1</code> </th><td>Error during the calculation of the convex or concave envelope of a univariate functions (Newton/secant method failed) </td></tr>
<tr>
<th><code>2</code> </th><td>Error during intersection of two terms (empty intersection) </td></tr>
<tr>
<th><code>3</code> </th><td>Error in constraint definition (e.g., number = number) </td></tr>
<tr>
<th><code>4</code> </th><td>Error in objective definition (e.g., minimize interval) </td></tr>
<tr>
<th><code>5</code> </th><td>Error during initialization with a variable of class mc::McCormick or mc::Taylor </td></tr>
<tr>
<th><code>-1</code> </th><td>Error due to an operation between variables participating in different factorable programs </td></tr>
<tr>
<th><code>-2</code> </th><td>Error due to calling a function/feature not yet implemented in MC++ </td></tr>
<tr>
<th><code>-3</code> </th><td>Internal error </td></tr>
</table>
<h2><a class="anchor" id="sec_FPREL_refs"></a>
References</h2>
<ul>
<li>Tawarmalani, M., and N.V. Sahinidis, <a href="http://dx.doi.org/10.1007/s10107-003-0467-6">Global optimization of mixed-integer nonlinear programs: A theoretical and computational study</a>, <em>Mathematical Programming</em>, <b>99</b>(3):563-591, 2004.</li>
<li>Smith, E.M.B, and C.C. Pantelides, <a href="http://dx.doi.org/10.1016/S0098-1354(98)00286-5">A symbolic reformulation/spatial branch-and-bound algorithm for the global optimisation of nonconvex MINLPs</a>, <em>Computers &amp; Chemical Engineering</em>, <b>23</b>(4-5):457-478, 1999.</li>
</ul>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Thu Feb 13 2014 20:08:12 for GOLIB by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
