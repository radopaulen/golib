<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GOLIB: polyhedral/fprelax.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GOLIB
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('fprelax_8hpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">fprelax.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright (C) 2012, 2014 Benoit Chachuat, Imperial College London.</span>
<a name="l00002"></a>00002 <span class="comment">// All Rights Reserved.</span>
<a name="l00003"></a>00003 <span class="comment">// This code is published under the Eclipse Public License.</span>
<a name="l00004"></a>00004 
<a name="l00433"></a>00433 <span class="comment">// TO DO:</span>
<a name="l00434"></a>00434 <span class="comment">// - [DONE] Factor out the sandwich alorithm!</span>
<a name="l00435"></a>00435 <span class="comment">// - Implement remaining simple univariate functions: sqr [DONE], sqrt [DONE], log [DONE], fabs [DONE], pow (even) [DONE], fstep [DONE], bstep [DONE], min [DONE], max [DONE]</span>
<a name="l00436"></a>00436 <span class="comment">// - Implement more complex univariate functions with Newton method: pow (odd) [DONE], sin [DONE], cos [DONE], asin [DONE], acos [DONE], tan [DONE], atan [DONE], erf [DONE], erfc [DONE], hyperbolic functions</span>
<a name="l00437"></a>00437 <span class="comment">// - Also implement functions like: bilin [DONE], xlog, arh, monod, haldane</span>
<a name="l00438"></a>00438 <span class="comment">// - [DONE] Implement a header file &quot;lprgurobi.h&quot; for constructing LP relaxations in Gurobi format</span>
<a name="l00439"></a>00439 <span class="comment">// - [DONE] Floating point exception sent by Gurobi w/ Profil! (but not mc::Interval...)</span>
<a name="l00440"></a>00440 <span class="comment">// - [DONE] Implement CPLEX version too</span>
<a name="l00441"></a>00441 
<a name="l00442"></a>00442 <span class="comment">// - [BAD IDEA] Define Cuts in terms of the variables themselves, not variable indexes -&gt; not a good idea because of Outer Approximation</span>
<a name="l00443"></a>00443 <span class="comment">// - [DONE] Factorize variables/operations in operators/functions</span>
<a name="l00444"></a>00444 <span class="comment">// - [DONE] Introduce a _type field for the variables instead of _constant and negative indices, such as { VARCONT, VARBIN, AUXCONT, AUXBIN, AUXINT, AUXREAL }</span>
<a name="l00445"></a>00445 <span class="comment">// - [DONE] Make link with McCormick, Taylor and McCormick-Taylor for variable initialization</span>
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="comment">// - [DONE] Separate factorable decomposition from cut generation</span>
<a name="l00448"></a>00448 <span class="comment">// - [DONE] Add/remove particular cuts in Gurobi/Cplex</span>
<a name="l00449"></a>00449 <span class="comment">// - [DONE] Keep track of operations &lt;-&gt; cuts</span>
<a name="l00450"></a>00450 <span class="comment">// - Implement trilinear terms relaxation</span>
<a name="l00451"></a>00451 <span class="comment">// - [DONE] Change name from &quot;LP&quot; to &quot;FP&quot; for &quot;Factorable Program&quot;</span>
<a name="l00452"></a>00452 <span class="comment">// - [DONE] Implement constraint propagation</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">// - [DONE] Write down documentation</span>
<a name="l00455"></a>00455 <span class="comment">// - Check that variables participating in binary operations share the same FPRelax object</span>
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 
<a name="l00458"></a>00458 <span class="preprocessor">#ifndef MC__FPRELAX_HPP</span>
<a name="l00459"></a>00459 <span class="preprocessor"></span><span class="preprocessor">#define MC__FPRELAX_HPP</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00461"></a>00461 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00462"></a>00462 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00463"></a>00463 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00464"></a>00464 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00465"></a>00465 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00466"></a>00466 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00467"></a>00467 <span class="preprocessor">#include &lt;queue&gt;</span>
<a name="l00468"></a>00468 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00469"></a>00469 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="preprocessor">#include &quot;mcfunc.hpp&quot;</span>
<a name="l00472"></a>00472 <span class="preprocessor">#include &quot;mcop.hpp&quot;</span>
<a name="l00473"></a>00473 <span class="preprocessor">#include &quot;mccormick.hpp&quot;</span>
<a name="l00474"></a>00474 <span class="preprocessor">#include &quot;tmodel.hpp&quot;</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="preprocessor">#define MC__FPRELAX_SCALE_SEPARABLE</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span><span class="preprocessor">#undef  MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>
<a name="l00479"></a>00479 <span class="keyword">namespace </span>mc
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>FPOp;
<a name="l00482"></a>00482 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>lt_FPOp;
<a name="l00483"></a>00483 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>FPCut;
<a name="l00484"></a>00484 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>lt_FPCut;
<a name="l00485"></a>00485 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>FPRLT;
<a name="l00486"></a>00486 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>FPRelax;
<a name="l00487"></a>00487 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>FPRRLT;
<a name="l00488"></a>00488 
<a name="l00495"></a>00495 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00496"></a><a class="code" href="structmc_1_1FPVarNum.html">00496</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum</a>
<a name="l00497"></a>00497 {
<a name="l00499"></a><a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5">00499</a>   <span class="keyword">enum</span> <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5" title="Enumeration type for numeric variables in factorable program.">TYPE</a>{
<a name="l00500"></a><a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5aff0fb2009c0230bef8e4e33d3fb2a8a7">00500</a>     <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5aff0fb2009c0230bef8e4e33d3fb2a8a7" title="Integer value.">INT</a>=0,  
<a name="l00501"></a><a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a20fabf5e5dc2efae1b37d1c2630bfccc">00501</a>     <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a20fabf5e5dc2efae1b37d1c2630bfccc" title="Real value.">REAL</a>,   
<a name="l00502"></a><a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a53b306d33d29d2797f7b4957263543fe">00502</a>     <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a53b306d33d29d2797f7b4957263543fe" title="Range.">RANGE</a>   
<a name="l00503"></a>00503   };
<a name="l00505"></a><a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf">00505</a>   <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5" title="Enumeration type for numeric variables in factorable program.">TYPE</a> <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a>;
<a name="l00507"></a>00507   <span class="keyword">union</span>{
<a name="l00508"></a>00508     <span class="keywordtype">int</span> n;
<a name="l00509"></a>00509     <span class="keywordtype">double</span> x;
<a name="l00510"></a>00510   }; 
<a name="l00512"></a><a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc">00512</a>   T <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a>;
<a name="l00513"></a>00513 
<a name="l00515"></a><a class="code" href="structmc_1_1FPVarNum.html#a9552a4380f33bc87266c52cdf0f8a89f">00515</a>   <a class="code" href="structmc_1_1FPVarNum.html#a9552a4380f33bc87266c52cdf0f8a89f" title="Constructor for an integer variable.">FPVarNum</a>( <span class="keyword">const</span> <span class="keywordtype">int</span> i=0 ):
<a name="l00516"></a>00516     <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a>(<a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5aff0fb2009c0230bef8e4e33d3fb2a8a7" title="Integer value.">INT</a>), n(i), <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a>(i)
<a name="l00517"></a>00517     {}
<a name="l00519"></a><a class="code" href="structmc_1_1FPVarNum.html#a12330cfb93d1376e1bcad4645d497f38">00519</a>   <a class="code" href="structmc_1_1FPVarNum.html#a9552a4380f33bc87266c52cdf0f8a89f" title="Constructor for an integer variable.">FPVarNum</a>( <span class="keyword">const</span> <span class="keywordtype">double</span> d ):
<a name="l00520"></a>00520     <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a>(<a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a20fabf5e5dc2efae1b37d1c2630bfccc" title="Real value.">REAL</a>), x(d), <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a>(d)
<a name="l00521"></a>00521     {}
<a name="l00523"></a><a class="code" href="structmc_1_1FPVarNum.html#a108501a0c41cd51f94771bcab258b79d">00523</a>   <a class="code" href="structmc_1_1FPVarNum.html#a9552a4380f33bc87266c52cdf0f8a89f" title="Constructor for an integer variable.">FPVarNum</a>( <span class="keyword">const</span> T&amp;B ):
<a name="l00524"></a>00524     <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a>(<a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a53b306d33d29d2797f7b4957263543fe" title="Range.">RANGE</a>), n(0), <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a>(B)
<a name="l00525"></a>00525     {}
<a name="l00526"></a>00526 
<a name="l00528"></a>00528   <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00529"></a><a class="code" href="structmc_1_1FPVarNum.html#a0da5fd8137ad5d35810865aaf584c14e">00529</a>     ( <span class="keyword">const</span> <span class="keywordtype">int</span> i )
<a name="l00530"></a>00530     { <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> = <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5aff0fb2009c0230bef8e4e33d3fb2a8a7" title="Integer value.">INT</a>; n = i; <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a> = i; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00532"></a>00532   <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00533"></a><a class="code" href="structmc_1_1FPVarNum.html#a8502c1b5a0468519af82c1676165ba99">00533</a>     ( <span class="keyword">const</span> <span class="keywordtype">double</span> d )
<a name="l00534"></a>00534     { <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> = <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a20fabf5e5dc2efae1b37d1c2630bfccc" title="Real value.">REAL</a>; x = d; <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a> = d; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00536"></a>00536   <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00537"></a><a class="code" href="structmc_1_1FPVarNum.html#a90193a07c852bece448dc28c3c2424e1">00537</a>     ( <span class="keyword">const</span> T&amp;B )
<a name="l00538"></a>00538     { <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> = <a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a53b306d33d29d2797f7b4957263543fe" title="Range.">RANGE</a>; n = 0; <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a> = B; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00540"></a>00540   <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00541"></a><a class="code" href="structmc_1_1FPVarNum.html#a5ec43559d8268873311e3d6fedd22f0c">00541</a>     ( <span class="keyword">const</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>&amp;num )
<a name="l00542"></a>00542     { <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> = num.t; <a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a>==<a class="code" href="structmc_1_1FPVarNum.html#a47179810fadec2d74ee3cc3d60c1c8c5a20fabf5e5dc2efae1b37d1c2630bfccc" title="Real value.">REAL</a>? x=num.x: n; <a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a> = num.I; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00543"></a>00543 };
<a name="l00544"></a>00544 
<a name="l00550"></a>00550 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00551"></a><a class="code" href="structmc_1_1eq__FPVarNum.html">00551</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1eq__FPVarNum.html" title="C++ structure for comparing values of factorable program variables.">eq_FPVarNum</a>
<a name="l00553"></a>00553 {
<a name="l00554"></a>00554   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l00555"></a>00555     ( <span class="keyword">const</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>*Num1, <span class="keyword">const</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>*Num2 )<span class="keyword"> const</span>
<a name="l00556"></a>00556 <span class="keyword">    </span>{
<a name="l00557"></a>00557       <span class="keywordflow">if</span>( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> != Num2-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00558"></a>00558       <span class="keywordflow">switch</span>( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> ){
<a name="l00559"></a>00559         <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::INT</a>:   <span class="keywordflow">return</span> Num1-&gt;n==Num2-&gt;n? <span class="keyword">true</span>: <span class="keyword">false</span>;
<a name="l00560"></a>00560         <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::REAL</a>:  <span class="keywordflow">return</span> isequal( Num1-&gt;x, Num2-&gt;x );
<a name="l00561"></a>00561         <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::RANGE</a>: <span class="keywordflow">return</span> Op&lt;T&gt;::eq( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a>, Num2-&gt;<a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a> );
<a name="l00562"></a>00562       }
<a name="l00563"></a>00563     }
<a name="l00564"></a>00564 };
<a name="l00565"></a>00565 
<a name="l00571"></a>00571 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00572"></a><a class="code" href="structmc_1_1lt__FPVarNum.html">00572</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__FPVarNum.html" title="C++ structure for comparing values of factorable program variables.">lt_FPVarNum</a>
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l00576"></a>00576     ( <span class="keyword">const</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>*Num1, <span class="keyword">const</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>*Num2 )<span class="keyword"> const</span>
<a name="l00577"></a>00577 <span class="keyword">    </span>{
<a name="l00578"></a>00578       <span class="keywordflow">if</span>( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> &lt; Num2-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00579"></a>00579       <span class="keywordflow">if</span>( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> &gt; Num2-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00580"></a>00580       <span class="keywordflow">switch</span>( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#a41a7303f9502ccbcf38eb3ee4794cfdf" title="Variable type.">t</a> ){
<a name="l00581"></a>00581         <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::INT</a>:
<a name="l00582"></a>00582           <span class="keywordflow">return</span> Num1-&gt;n&lt;Num2-&gt;n? <span class="keyword">true</span>: <span class="keyword">false</span>;
<a name="l00583"></a>00583         <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::REAL</a>:
<a name="l00584"></a>00584           <span class="keywordflow">return</span> !isequal( Num1-&gt;x, Num2-&gt;x ) &amp;&amp; Num1-&gt;x&lt;Num2-&gt;x? <span class="keyword">true</span>: <span class="keyword">false</span>;
<a name="l00585"></a>00585         <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::RANGE</a>:
<a name="l00586"></a>00586           <span class="keywordflow">return</span> Op&lt;T&gt;::lt( Num1-&gt;<a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a>, Num2-&gt;<a class="code" href="structmc_1_1FPVarNum.html#ad5d19acefdabea2d26db43f9ff211bdc" title="Variable range.">I</a> );
<a name="l00587"></a>00587       }
<a name="l00588"></a>00588       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00589"></a>00589     }
<a name="l00590"></a>00590 };
<a name="l00591"></a>00591 
<a name="l00597"></a>00597 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00598"></a><a class="code" href="classmc_1_1FPVar.html">00598</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601   <span class="comment">// friends of this class with other classes/structures/operators</span>
<a name="l00602"></a>00602   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>;
<a name="l00603"></a>00603   <span class="comment">//template &lt;typename U&gt; friend FPVar&lt;U&gt;* FPRelax&lt;U&gt;::_auxiliary_variable</span>
<a name="l00604"></a>00604   <span class="comment">//  ( const U&amp;, FPOp&lt;U&gt;* );</span>
<a name="l00605"></a>00605   <span class="comment">//template &lt;typename U&gt; friend FPVar&lt;U&gt;* FPRelax&lt;U&gt;::_auxiliary_variable</span>
<a name="l00606"></a>00606   <span class="comment">//  ( FPOp&lt;U&gt;* );</span>
<a name="l00607"></a>00607   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax</a>;
<a name="l00608"></a>00608   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classmc_1_1FPRRLT.html" title="C++ template class for reduced RLT constraint generation.">FPRRLT</a>;
<a name="l00609"></a>00609   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar</a>;
<a name="l00610"></a>00610   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l00611"></a>00611     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;U&gt;</a>&amp; );
<a name="l00612"></a>00612   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l00613"></a>00613     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;U&gt;</a>&amp; );
<a name="l00614"></a>00614   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l00615"></a>00615     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;U&gt;</a>&amp; );
<a name="l00616"></a>00616   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l00617"></a>00617     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;U&gt;</a>&amp; );
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <span class="comment">// friends of this class for operator overloading</span>
<a name="l00620"></a>00620   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l00621"></a>00621     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00622"></a>00622   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l00623"></a>00623     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00624"></a>00624   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l00625"></a>00625     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00626"></a>00626   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l00627"></a>00627     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00628"></a>00628   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l00629"></a>00629     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l00630"></a>00630   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l00631"></a>00631     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00632"></a>00632   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l00633"></a>00633     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00634"></a>00634   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l00635"></a>00635     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00636"></a>00636   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l00637"></a>00637     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00638"></a>00638   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l00639"></a>00639     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00640"></a>00640   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l00641"></a>00641     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l00642"></a>00642   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l00643"></a>00643     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00644"></a>00644   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l00645"></a>00645     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00646"></a>00646   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l00647"></a>00647     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00648"></a>00648   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l00649"></a>00649     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00650"></a>00650   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l00651"></a>00651     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l00652"></a>00652   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l00653"></a>00653     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00654"></a>00654   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l00655"></a>00655     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00656"></a>00656   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l00657"></a>00657     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00658"></a>00658   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l00659"></a>00659     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00660"></a>00660   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l00661"></a>00661     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l00662"></a>00662   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l00663"></a>00663     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00664"></a>00664   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l00665"></a>00665     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00666"></a>00666   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>^
<a name="l00667"></a>00667     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00668"></a>00668   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l00669"></a>00669     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00670"></a>00670   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l00671"></a>00671     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00672"></a>00672   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l00673"></a>00673     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l00674"></a>00674   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l00675"></a>00675     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00676"></a>00676   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l00677"></a>00677     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00678"></a>00678   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l00679"></a>00679     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>* );
<a name="l00680"></a>00680   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l00681"></a>00681     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00682"></a>00682   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l00683"></a>00683     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00684"></a>00684   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l00685"></a>00685     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l00686"></a>00686   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l00687"></a>00687     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00688"></a>00688   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l00689"></a>00689     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00690"></a>00690   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l00691"></a>00691     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>* );
<a name="l00692"></a>00692 
<a name="l00693"></a>00693   <span class="comment">// friends of class FPVar for function overloading</span>
<a name="l00694"></a>00694   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> inv
<a name="l00695"></a>00695     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00696"></a>00696   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> sqr
<a name="l00697"></a>00697     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00698"></a>00698   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> exp
<a name="l00699"></a>00699     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00700"></a>00700   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> log
<a name="l00701"></a>00701     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00702"></a>00702   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> sqrt
<a name="l00703"></a>00703     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00704"></a>00704   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> fabs
<a name="l00705"></a>00705     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00706"></a>00706   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> cos
<a name="l00707"></a>00707     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00708"></a>00708   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> sin
<a name="l00709"></a>00709     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00710"></a>00710   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> tan
<a name="l00711"></a>00711     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00712"></a>00712   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> acos
<a name="l00713"></a>00713     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00714"></a>00714   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> asin
<a name="l00715"></a>00715     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00716"></a>00716   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> atan
<a name="l00717"></a>00717     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00718"></a>00718   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> xlog
<a name="l00719"></a>00719     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00720"></a>00720   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> arh
<a name="l00721"></a>00721     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <span class="keywordtype">double</span> );
<a name="l00722"></a>00722   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> erf
<a name="l00723"></a>00723     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00724"></a>00724   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> erfc
<a name="l00725"></a>00725     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00726"></a>00726   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> fstep
<a name="l00727"></a>00727     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00728"></a>00728   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> bstep
<a name="l00729"></a>00729     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00730"></a>00730   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> pow
<a name="l00731"></a>00731     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <span class="keywordtype">int</span> );
<a name="l00732"></a>00732   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> pow
<a name="l00733"></a>00733     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l00734"></a>00734   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> pow
<a name="l00735"></a>00735     ( <span class="keyword">const</span> <span class="keywordtype">double</span>, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00736"></a>00736   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> ltcond
<a name="l00737"></a>00737     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00738"></a>00738   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> ltcond
<a name="l00739"></a>00739     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00740"></a>00740   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> gtcond
<a name="l00741"></a>00741     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00742"></a>00742   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> gtcond
<a name="l00743"></a>00743     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00744"></a>00744   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> bilin
<a name="l00745"></a>00745     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <span class="keyword">public</span>:
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   <span class="comment">// other operator overloadings</span>
<a name="l00750"></a>00750   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00751"></a>00751     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; );
<a name="l00752"></a>00752   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00753"></a>00753     ( <span class="keyword">const</span> T&amp; );
<a name="l00754"></a>00754   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00755"></a>00755     ( <span class="keyword">const</span> int );
<a name="l00756"></a>00756   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>=
<a name="l00757"></a>00757     ( <span class="keyword">const</span> double );
<a name="l00758"></a>00758   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>+=
<a name="l00759"></a>00759     ( <span class="keyword">const</span> U&amp; );
<a name="l00760"></a>00760   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>-=
<a name="l00761"></a>00761     ( <span class="keyword">const</span> U&amp; );
<a name="l00762"></a>00762   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>*=
<a name="l00763"></a>00763     ( <span class="keyword">const</span> U&amp; );
<a name="l00764"></a>00764   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">operator</span>/=
<a name="l00765"></a>00765     ( <span class="keyword">const</span> U&amp; );
<a name="l00766"></a>00766 
<a name="l00767"></a>00767   <span class="comment">// operator overloadings (for constraint definition)</span>
<a name="l00768"></a>00768   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keywordtype">bool</span> <span class="keyword">operator</span> ==
<a name="l00769"></a>00769     ( <span class="keyword">const</span> U&amp;Var )
<a name="l00770"></a>00770     { _FP-&gt;add_constraint( *<span class="keyword">this</span>, <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::EQ</a>, Var ); <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00771"></a>00771   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keywordtype">bool</span> <span class="keyword">operator</span> &lt;=
<a name="l00772"></a>00772     ( <span class="keyword">const</span> U&amp;Var )
<a name="l00773"></a>00773     { _FP-&gt;add_constraint( *<span class="keyword">this</span>, <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::LE</a>, Var ); <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00774"></a>00774   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keywordtype">bool</span> <span class="keyword">operator</span> &gt;=
<a name="l00775"></a>00775     ( <span class="keyword">const</span> U&amp;Var )
<a name="l00776"></a>00776     { _FP-&gt;add_constraint( *<span class="keyword">this</span>, <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::GE</a>, Var ); <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00777"></a>00777 
<a name="l00781"></a>00781 
<a name="l00782"></a><a class="code" href="group__FP.html#ga9445a3b2ff57729aad2f7459f20d865a">00782</a>   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="group__FP.html#ga9445a3b2ff57729aad2f7459f20d865a" title="Index for &#39;free&#39; variables in factorable program.">NOREF</a> = -33;
<a name="l00784"></a><a class="code" href="group__FP.html#ga7b164aacf765e9d42ee6ba7531ca7362">00784</a>   <span class="keyword">enum</span> <a class="code" href="group__FP.html#ga7b164aacf765e9d42ee6ba7531ca7362" title="Enumeration type for variables in factorable program.">TYPE</a>{
<a name="l00785"></a><a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a8fc38409855d72045a99c4a54d019fd5">00785</a>     <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a8fc38409855d72045a99c4a54d019fd5" title="Native continuous variable.">VARCONT</a>=0, 
<a name="l00786"></a><a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a3522727fe472c9cc8b0cfee98a772afd">00786</a>     <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a3522727fe472c9cc8b0cfee98a772afd" title="Native binary variable.">VARBIN</a>, 
<a name="l00787"></a><a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a1395eaa40cc1e14041e146173427a51b">00787</a>     <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a1395eaa40cc1e14041e146173427a51b" title="Auxiliary continuous variable.">AUXCONT</a>,   
<a name="l00788"></a><a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a64f74ff8a18c51b445a28fc304b84b15">00788</a>     <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a64f74ff8a18c51b445a28fc304b84b15" title="Auxiliary binary variable.">AUXBIN</a>, 
<a name="l00789"></a><a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a5dda0b1f62be0ce17130f8e3680eb537">00789</a>     <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a5dda0b1f62be0ce17130f8e3680eb537" title="Auxiliary integer constant.">AUXINT</a>, 
<a name="l00790"></a><a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362ae82dcede9236cfc96ccef2cf2cae48a0">00790</a>     <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362ae82dcede9236cfc96ccef2cf2cae48a0" title="auxiliary real constant">AUXREAL</a> 
<a name="l00791"></a>00791   };
<a name="l00793"></a><a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6">00793</a>   <span class="keyword">typedef</span> std::pair&lt; TYPE, long &gt; <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">pt_idVar</a>;
<a name="l00796"></a>00796 <span class="keyword">private</span>:
<a name="l00798"></a>00798   <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">pt_idVar</a> _id;
<a name="l00800"></a>00800   <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a> _num;
<a name="l00802"></a>00802   <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a> *_FP;
<a name="l00804"></a>00804   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> *_Op;
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="keyword">public</span>:
<a name="l00807"></a>00807 
<a name="l00811"></a>00811 
<a name="l00812"></a>00812   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00813"></a><a class="code" href="group__FP.html#gafc7e89b002cbe8be048124f29c5f4a03">00813</a>     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*<a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac" title="Get const pointer to factorable program.">FP</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix, <span class="keyword">const</span> T&amp;X )
<a name="l00814"></a>00814     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a8fc38409855d72045a99c4a54d019fd5" title="Native continuous variable.">VARCONT</a>, ix ), _num( X ), _FP( FP ), _Op( 0 )
<a name="l00815"></a>00815     { 
<a name="l00816"></a>00816       <span class="keywordflow">if</span>( !FP )
<a name="l00817"></a>00817         <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INIT</a> );
<a name="l00818"></a>00818       <span class="comment">// Keep track of variable count</span>
<a name="l00819"></a>00819       <span class="keywordflow">if</span>( FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a> &lt;= ix ) FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a> = ix+1;
<a name="l00820"></a>00820       <span class="comment">// Search for existing variable with same identification in _Vars,</span>
<a name="l00821"></a>00821       <span class="comment">// and erase it from _Vars if found along with the corresponding</span>
<a name="l00822"></a>00822       <span class="comment">// operation in _Ops</span>
<a name="l00823"></a>00823       <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pVar = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( *this );
<a name="l00824"></a>00824       <span class="keyword">typename</span> FPRelax&lt;T&gt;::it_Vars iVar = FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.find( pVar );
<a name="l00825"></a>00825       <span class="keywordflow">if</span>( iVar!=FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.end() ){
<a name="l00826"></a>00826         FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.erase( (*iVar)-&gt;_Op ); <span class="keyword">delete</span> (*iVar)-&gt;_Op;
<a name="l00827"></a>00827         <span class="keyword">delete</span> *iVar; FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.erase( iVar );
<a name="l00828"></a>00828       }
<a name="l00829"></a>00829       <span class="comment">// Insert new variable in _Vars and corresponding operation in _Ops</span>
<a name="l00830"></a>00830       <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* Op = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::VAR</a>, 0, 0, pVar );
<a name="l00831"></a>00831       FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.insert( Op );
<a name="l00832"></a>00832       pVar-&gt;_Op = _Op = Op;
<a name="l00833"></a>00833       FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#ae869e37c863d88ea9bc2b7074fa03672" title="Appends new original variable.">_append_var</a>( pVar );
<a name="l00834"></a>00834    }
<a name="l00835"></a>00835 
<a name="l00837"></a>00837   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">set</span>
<a name="l00838"></a><a class="code" href="group__FP.html#ga041074b131ffddb840ec5aef8be5add5">00838</a>     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*<a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac" title="Get const pointer to factorable program.">FP</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix, <span class="keyword">const</span> T&amp;X )
<a name="l00839"></a>00839     { *<span class="keyword">this</span> = <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>( FP, ix, X ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00840"></a>00840 
<a name="l00842"></a>00842   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00843"></a><a class="code" href="group__FP.html#ga4bd076536d062e851131c00a8e1cbf58">00843</a>     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*FP, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix )
<a name="l00844"></a>00844     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a3522727fe472c9cc8b0cfee98a772afd" title="Native binary variable.">VARBIN</a>, ix ), _num( Op&lt;T&gt;::zeroone() ), _FP( FP ), _Op( 0 )
<a name="l00845"></a>00845     { 
<a name="l00846"></a>00846       <span class="keywordflow">if</span>( !FP )
<a name="l00847"></a>00847         <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INIT</a> );
<a name="l00848"></a>00848       <span class="comment">// Keep track of variable count</span>
<a name="l00849"></a>00849       <span class="keywordflow">if</span>( FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a> &lt;= ix ) FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a> = ix+1;
<a name="l00850"></a>00850       <span class="comment">// Search for existing variable with same identification in _Vars,</span>
<a name="l00851"></a>00851       <span class="comment">// and erase it from _Vars if found along with the corresponding</span>
<a name="l00852"></a>00852       <span class="comment">// operation in _Ops</span>
<a name="l00853"></a>00853       <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pVar = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( *this );
<a name="l00854"></a>00854       <span class="keyword">typename</span> FPRelax&lt;T&gt;::it_Vars iVar = FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.find( pVar );
<a name="l00855"></a>00855       <span class="keywordflow">if</span>( iVar!=FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.end() ){
<a name="l00856"></a>00856         FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.erase( (*iVar)-&gt;_Op ); <span class="keyword">delete</span> (*iVar)-&gt;_Op;
<a name="l00857"></a>00857         <span class="keyword">delete</span> *iVar; FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.erase( iVar );
<a name="l00858"></a>00858       }
<a name="l00859"></a>00859       <span class="comment">// Insert new variable in _Vars and corresponding operation in _Ops</span>
<a name="l00860"></a>00860       <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* Op = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::VAR</a>, 0, 0, pVar );
<a name="l00861"></a>00861       FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.insert( Op );
<a name="l00862"></a>00862       pVar-&gt;_Op = _Op = Op;
<a name="l00863"></a>00863       FP-&gt;<a class="code" href="classmc_1_1FPRelax.html#ae869e37c863d88ea9bc2b7074fa03672" title="Appends new original variable.">_append_var</a>( pVar );
<a name="l00864"></a>00864    }
<a name="l00865"></a>00865 
<a name="l00867"></a>00867   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp; <span class="keyword">set</span>
<a name="l00868"></a><a class="code" href="group__FP.html#gaf7e9036ee120f26e6f807d6e3b4a9b60">00868</a>     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*<a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac" title="Get const pointer to factorable program.">FP</a>, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ix )
<a name="l00869"></a>00869     { *<span class="keyword">this</span> = <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>( FP, ix ); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00870"></a>00870 
<a name="l00872"></a>00872   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00873"></a><a class="code" href="group__FP.html#ga6eb225d83b15dabeb99f8aaade4f2e35">00873</a>     ( <span class="keyword">const</span> <span class="keywordtype">int</span> i=0 )
<a name="l00874"></a>00874     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a5dda0b1f62be0ce17130f8e3680eb537" title="Auxiliary integer constant.">AUXINT</a>, <a class="code" href="group__FP.html#ga9445a3b2ff57729aad2f7459f20d865a" title="Index for &#39;free&#39; variables in factorable program.">NOREF</a> ), _num( i ), _FP( 0 ), _Op( 0 )
<a name="l00875"></a>00875     {}
<a name="l00876"></a>00876 
<a name="l00878"></a>00878   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00879"></a><a class="code" href="group__FP.html#ga0c5bc3c90cdfb3123e80b32180ed730b">00879</a>     ( <span class="keyword">const</span> <span class="keywordtype">double</span> d )
<a name="l00880"></a>00880     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362ae82dcede9236cfc96ccef2cf2cae48a0" title="auxiliary real constant">AUXREAL</a>, <a class="code" href="group__FP.html#ga9445a3b2ff57729aad2f7459f20d865a" title="Index for &#39;free&#39; variables in factorable program.">NOREF</a> ), _num( d ), _FP( 0 ), _Op( 0 )
<a name="l00881"></a>00881     {}
<a name="l00882"></a>00882 
<a name="l00884"></a>00884   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00885"></a><a class="code" href="group__FP.html#ga9110ede0cb7d913dadb5131dbb736846">00885</a>     ( <span class="keyword">const</span> T&amp;X )
<a name="l00886"></a>00886     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a1395eaa40cc1e14041e146173427a51b" title="Auxiliary continuous variable.">AUXCONT</a>, <a class="code" href="group__FP.html#ga9445a3b2ff57729aad2f7459f20d865a" title="Index for &#39;free&#39; variables in factorable program.">NOREF</a> ), _num( X ), _FP( 0 ), _Op( 0 )
<a name="l00887"></a>00887     {}
<a name="l00888"></a>00888 
<a name="l00890"></a>00890   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00891"></a>00891     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*FP, <span class="keyword">const</span> mc::McCormick&lt;T&gt;&amp;MCX, <span class="keyword">const</span> <span class="keywordtype">double</span>*xref,
<a name="l00892"></a>00892       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub=0 );
<a name="l00893"></a>00893 
<a name="l00895"></a>00895   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00896"></a>00896     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*FP, <span class="keyword">const</span> mc::TVar&lt;T&gt;&amp;TVX, mc::TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP );
<a name="l00897"></a>00897 
<a name="l00899"></a>00899   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00900"></a>00900     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*FP, <span class="keyword">const</span> mc::TVar&lt; mc::McCormick&lt;T&gt; &gt;&amp;TVMCX,
<a name="l00901"></a>00901       mc::TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP, <span class="keyword">const</span> <span class="keywordtype">double</span>*MCXref,
<a name="l00902"></a>00902       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub );
<a name="l00903"></a>00903 
<a name="l00905"></a>00905   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00906"></a><a class="code" href="group__FP.html#ga2caf1bb552d7ca0b1db5e785c55f5781">00906</a>     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;Var )
<a name="l00907"></a>00907     : _id( Var._id ), _num( Var._num ), _FP( Var._FP ), _Op( Var._Op )
<a name="l00908"></a>00908     {}
<a name="l00911"></a>00911 <span class="keyword">private</span>:
<a name="l00912"></a>00912 
<a name="l00914"></a>00914   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>
<a name="l00915"></a>00915     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*FP, <span class="keyword">const</span> T&amp;X, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*Op=0 )
<a name="l00916"></a>00916     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a1395eaa40cc1e14041e146173427a51b" title="Auxiliary continuous variable.">AUXCONT</a>, FP-&gt;_naux++ ), _num( X ), _FP( FP ), _Op( Op )
<a name="l00917"></a>00917     {}
<a name="l00918"></a>00918 
<a name="l00920"></a>00920   FPVar
<a name="l00921"></a>00921     ( FPRelax&lt;T&gt;*FP, FPOp&lt;T&gt;*<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>=0 )
<a name="l00922"></a>00922     : _id( <a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a64f74ff8a18c51b445a28fc304b84b15" title="Auxiliary binary variable.">AUXBIN</a>, FP-&gt;_naux++ ), _num( Op&lt;T&gt;::zeroone() ), _FP( FP ), _Op( <a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a> )
<a name="l00923"></a>00923     {}
<a name="l00924"></a>00924 
<a name="l00926"></a>00926   FPVar
<a name="l00927"></a>00927     ( FPRelax&lt;T&gt;*FP, <span class="keyword">const</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">pt_idVar</a>&amp;<span class="keywordtype">id</span> )
<a name="l00928"></a>00928     : _id( id ), _num( 0 ), _FP( FP ), _Op( 0 )
<a name="l00929"></a>00929     {}
<a name="l00930"></a>00930     
<a name="l00931"></a>00931 <span class="keyword">public</span>:
<a name="l00932"></a>00932 
<a name="l00936"></a>00936 
<a name="l00937"></a><a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534">00937</a>   <span class="keyword">const</span> std::pair&lt;TYPE,long&gt; <a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>()<span class="keyword"> const</span>
<a name="l00938"></a>00938 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _id; }
<a name="l00939"></a>00939 
<a name="l00941"></a><a class="code" href="group__FP.html#gad620c166e6efd137e248957ff30219f9">00941</a>   std::pair&lt;TYPE,long&gt;&amp; <a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>()
<a name="l00942"></a>00942     { <span class="keywordflow">return</span> _id; }
<a name="l00943"></a>00943 
<a name="l00945"></a><a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2">00945</a>   <span class="keyword">const</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;</a>&amp; <a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>()<span class="keyword"> const</span>
<a name="l00946"></a>00946 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _num; }
<a name="l00947"></a>00947 
<a name="l00949"></a><a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b">00949</a>   <span class="keyword">const</span> T&amp; <a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>()<span class="keyword"> const</span>
<a name="l00950"></a>00950 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _num.I; }
<a name="l00951"></a>00951 
<a name="l00953"></a><a class="code" href="group__FP.html#ga4769738e25d3b5aef011dcfd02848a88">00953</a>   T&amp; <a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>()
<a name="l00954"></a>00954     { <span class="keywordflow">return</span> _num.I; }
<a name="l00955"></a>00955 
<a name="l00957"></a><a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6">00957</a>   <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* <a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()<span class="keyword"> const</span>
<a name="l00958"></a>00958 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _Op; }
<a name="l00959"></a>00959 
<a name="l00961"></a><a class="code" href="group__FP.html#gafb3dc50d53a465e98c09ce525d22edfb">00961</a>   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*&amp; <a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()
<a name="l00962"></a>00962     { <span class="keywordflow">return</span> _Op; }
<a name="l00963"></a>00963 
<a name="l00965"></a><a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac">00965</a>   <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>* <a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac" title="Get const pointer to factorable program.">FP</a>()<span class="keyword"> const</span>
<a name="l00966"></a>00966 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _FP; }
<a name="l00967"></a>00967 
<a name="l00969"></a><a class="code" href="group__FP.html#ga143a2e1a454a8b8fe0880da3c9c79290">00969</a>   <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*&amp; <a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac" title="Get const pointer to factorable program.">FP</a>()
<a name="l00970"></a>00970     { <span class="keywordflow">return</span> _FP; }
<a name="l00971"></a>00971 
<a name="l00973"></a><a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90">00973</a>   std::string <a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90" title="Get variable name.">name</a>()<span class="keyword"> const</span>
<a name="l00974"></a>00974 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _name(_id); }
<a name="l00977"></a>00977 <span class="keyword">private</span>:
<a name="l00978"></a>00978 
<a name="l00980"></a>00980   <span class="keyword">static</span> std::string _name
<a name="l00981"></a>00981     ( <span class="keyword">const</span> std::pair&lt;TYPE,long&gt; <span class="keywordtype">id</span> )
<a name="l00982"></a>00982     { std::ostringstream ovar;
<a name="l00983"></a>00983       (<span class="keywordtype">id</span>.first==<a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a8fc38409855d72045a99c4a54d019fd5" title="Native continuous variable.">VARCONT</a>? ovar&lt;&lt;<span class="stringliteral">&quot;X&quot;</span>: (<span class="keywordtype">id</span>.first==<a class="code" href="group__FP.html#gga7b164aacf765e9d42ee6ba7531ca7362a3522727fe472c9cc8b0cfee98a772afd" title="Native binary variable.">VARBIN</a>? ovar&lt;&lt;<span class="stringliteral">&quot;Y&quot;</span>: ovar&lt;&lt;<span class="stringliteral">&quot;Z&quot;</span> ));
<a name="l00984"></a>00984       ovar&lt;&lt;<span class="keywordtype">id</span>.second;
<a name="l00985"></a>00985       <span class="keywordflow">return</span> ovar.str(); }
<a name="l00986"></a>00986 };
<a name="l00987"></a>00987 
<a name="l00993"></a>00993 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00994"></a><a class="code" href="structmc_1_1lt__FPVar.html">00994</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar</a>
<a name="l00996"></a>00996 {
<a name="l00997"></a>00997   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l00998"></a>00998     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 )<span class="keyword"> const</span>
<a name="l00999"></a>00999 <span class="keyword">    </span>{
<a name="l01000"></a>01000       <span class="comment">// Order variables/constants w.r.t. their types first</span>
<a name="l01001"></a>01001       <span class="keywordflow">if</span>( Var1-&gt;_id.first &lt; Var2-&gt;_id.first ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01002"></a>01002       <span class="keywordflow">if</span>( Var1-&gt;_id.first &gt; Var2-&gt;_id.first ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01003"></a>01003       <span class="comment">// If variables, order w.r.t. their index next</span>
<a name="l01004"></a>01004       <span class="keywordflow">switch</span>( Var1-&gt;_id.first ){
<a name="l01005"></a>01005         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::VARCONT</a>: <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::VARBIN</a>:
<a name="l01006"></a>01006         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXCONT</a>: <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXBIN</a>:
<a name="l01007"></a>01007           <span class="keywordflow">if</span>( Var1-&gt;_id.second &lt; Var2-&gt;_id.second ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01008"></a>01008           <span class="keywordflow">if</span>( Var1-&gt;_id.second &gt; Var2-&gt;_id.second ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01009"></a>01009           <span class="keywordflow">break</span>;
<a name="l01010"></a>01010         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a>: <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a>:
<a name="l01011"></a>01011           <a class="code" href="structmc_1_1lt__FPVarNum.html" title="C++ structure for comparing values of factorable program variables.">lt_FPVarNum&lt;T&gt;</a> ltNum;
<a name="l01012"></a>01012           <span class="keywordflow">return</span> ltNum( &amp;Var1-&gt;_num, &amp;Var2-&gt;_num );
<a name="l01013"></a>01013           <span class="keywordflow">break</span>;
<a name="l01014"></a>01014       }
<a name="l01015"></a>01015       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01016"></a>01016     }
<a name="l01017"></a>01017 };
<a name="l01018"></a>01018 
<a name="l01024"></a>01024 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01025"></a><a class="code" href="classmc_1_1FPCut.html">01025</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut</a>
<a name="l01027"></a>01027 {
<a name="l01028"></a>01028   <span class="comment">// friends of class FPCut for operator overloading</span>
<a name="l01029"></a>01029   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l01030"></a>01030     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;U&gt;</a>&amp; );
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="keyword">public</span>:
<a name="l01036"></a>01036 
<a name="l01037"></a><a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755">01037</a>   <span class="keyword">enum</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a>{
<a name="l01038"></a><a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755acc60872827cd5d60db66c2a91c49ed3a">01038</a>     <a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755acc60872827cd5d60db66c2a91c49ed3a" title="Equality constraint Ax=b.">EQ</a>=0,   
<a name="l01039"></a><a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a0d574a8be47a391774eba80a7e9c5b95">01039</a>     <a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a0d574a8be47a391774eba80a7e9c5b95" title="Inequality constraint Ax&lt;=b.">LE</a>,     
<a name="l01040"></a><a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a6c36d5904345128a92a4664bd829b2ae">01040</a>     <a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a6c36d5904345128a92a4664bd829b2ae" title="Inequality constraint Ax&gt;=b.">GE</a>,     
<a name="l01041"></a><a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a0351a10756386409727a9063473c7696">01041</a>     <a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a0351a10756386409727a9063473c7696" title="SOS1-type constraint.">SOS1</a>,   
<a name="l01042"></a><a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a6ca6a995991279ba847baf4633459cf9">01042</a>     <a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755a6ca6a995991279ba847baf4633459cf9" title="SOS2-type constraint.">SOS2</a> 
<a name="l01043"></a>01043   };
<a name="l01046"></a>01046 <span class="keyword">private</span>:
<a name="l01048"></a>01048   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> *_op;
<a name="l01050"></a>01050   <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> _type;
<a name="l01052"></a>01052   <span class="keywordtype">double</span> _rhs;
<a name="l01054"></a>01054   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _nvar;
<a name="l01056"></a>01056   <span class="keywordtype">double</span>* _coef;
<a name="l01058"></a>01058   <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>* _idvar;
<a name="l01059"></a>01059 
<a name="l01060"></a>01060 <span class="keyword">public</span>:
<a name="l01064"></a>01064 
<a name="l01065"></a><a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044">01065</a>   <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> <a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044" title="Retreive type of cut.">type</a>()<span class="keyword"> const</span>
<a name="l01066"></a>01066 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _type; }
<a name="l01068"></a><a class="code" href="group__FP.html#gafd365eccb600c1cf50eaaa9aeafc0522">01068</a>   <span class="keywordtype">double</span> <a class="code" href="group__FP.html#gafd365eccb600c1cf50eaaa9aeafc0522" title="Retreive right-hand side.">rhs</a>()<span class="keyword"> const</span>
<a name="l01069"></a>01069 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _rhs; }
<a name="l01071"></a><a class="code" href="group__FP.html#ga4ebe62be6241a3fdc2421f6975967c44">01071</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__FP.html#ga4ebe62be6241a3fdc2421f6975967c44" title="Retreive number of participating variables.">nvar</a>()<span class="keyword"> const</span>
<a name="l01072"></a>01072 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _nvar; }
<a name="l01074"></a><a class="code" href="group__FP.html#ga6362740e08ce96d046ade23950381ce5">01074</a>   <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="group__FP.html#ga6362740e08ce96d046ade23950381ce5" title="Retreive variable coefficients.">coef</a>()<span class="keyword"> const </span>
<a name="l01075"></a>01075 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _coef; }
<a name="l01077"></a><a class="code" href="group__FP.html#ga3a90a742ce8904031e1257efd3e06308">01077</a>   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>* <a class="code" href="group__FP.html#ga3a90a742ce8904031e1257efd3e06308" title="Retreive variable indices.">idvar</a>()<span class="keyword"> const </span>
<a name="l01078"></a>01078 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _idvar; }
<a name="l01080"></a><a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622">01080</a>   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*&amp; <a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>()
<a name="l01081"></a>01081     { <span class="keywordflow">return</span> _op; }
<a name="l01083"></a><a class="code" href="group__FP.html#ga920341fa169bcb56f083fe4353bc4975">01083</a>   <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* <a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>()<span class="keyword"> const</span>
<a name="l01084"></a>01084 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _op; }
<a name="l01085"></a>01085 
<a name="l01087"></a>01087   <a class="code" href="group__FP.html#ga90f70f350ea4fc220bb335154c788585" title="Default constructor for cut.">FPCut</a>
<a name="l01088"></a><a class="code" href="group__FP.html#ga90f70f350ea4fc220bb335154c788585">01088</a>     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*<a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>, <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> <a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044" title="Retreive type of cut.">type</a>=<a class="code" href="group__FP.html#ggaf42f21a24cd070666846afa763e6b755acc60872827cd5d60db66c2a91c49ed3a" title="Equality constraint Ax=b.">EQ</a> ):
<a name="l01089"></a>01089     _op(op), _type(<a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044" title="Retreive type of cut.">type</a>), _nvar(0), _coef(0), _idvar(0)
<a name="l01090"></a>01090     {}
<a name="l01091"></a>01091 
<a name="l01093"></a>01093   <a class="code" href="group__FP.html#ga90f70f350ea4fc220bb335154c788585" title="Default constructor for cut.">FPCut</a>
<a name="l01094"></a><a class="code" href="group__FP.html#gab49cb217f7387126903d4f6d7e89eaf6">01094</a>     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> <a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044" title="Retreive type of cut.">type</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> b,
<a name="l01095"></a>01095       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1, <span class="keyword">const</span> <span class="keywordtype">double</span> a1 ):
<a name="l01096"></a>01096     _op(op), _type(type), _rhs(b)
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098       _nvar  = 1;
<a name="l01099"></a>01099       _coef  = <span class="keyword">new</span> <span class="keywordtype">double</span>[_nvar];
<a name="l01100"></a>01100       _idvar = <span class="keyword">new</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>[_nvar];
<a name="l01101"></a>01101       _coef[0] = a1;
<a name="l01102"></a>01102       _idvar[0] = id1;
<a name="l01103"></a>01103     }
<a name="l01105"></a>01105   <a class="code" href="group__FP.html#ga90f70f350ea4fc220bb335154c788585" title="Default constructor for cut.">FPCut</a>
<a name="l01106"></a><a class="code" href="group__FP.html#gad3da3f182fa0b87c8fbf0998ee68fab6">01106</a>     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> type, <span class="keyword">const</span> <span class="keywordtype">double</span> b,
<a name="l01107"></a>01107       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1, <span class="keyword">const</span> <span class="keywordtype">double</span> a1,
<a name="l01108"></a>01108       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id2, <span class="keyword">const</span> <span class="keywordtype">double</span> a2 ):
<a name="l01109"></a>01109     _op(op), _type(type), _rhs(b)
<a name="l01110"></a>01110     {
<a name="l01111"></a>01111       _nvar  = 2;
<a name="l01112"></a>01112       _coef  = <span class="keyword">new</span> <span class="keywordtype">double</span>[_nvar];
<a name="l01113"></a>01113       _idvar = <span class="keyword">new</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>[_nvar];
<a name="l01114"></a>01114       _coef[0] = a1;
<a name="l01115"></a>01115       _coef[1] = a2;
<a name="l01116"></a>01116       _idvar[0] = id1;
<a name="l01117"></a>01117       _idvar[1] = id2;
<a name="l01118"></a>01118     }
<a name="l01120"></a>01120   <a class="code" href="group__FP.html#ga90f70f350ea4fc220bb335154c788585" title="Default constructor for cut.">FPCut</a>
<a name="l01121"></a><a class="code" href="group__FP.html#ga128b08b1d634a206933e0b57cb2f357d">01121</a>     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> type, <span class="keyword">const</span> <span class="keywordtype">double</span> b,
<a name="l01122"></a>01122       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1, <span class="keyword">const</span> <span class="keywordtype">double</span> a1,
<a name="l01123"></a>01123       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id2, <span class="keyword">const</span> <span class="keywordtype">double</span> a2,
<a name="l01124"></a>01124       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id3, <span class="keyword">const</span> <span class="keywordtype">double</span> a3 ):
<a name="l01125"></a>01125     _op(op), _type(type), _rhs(b)
<a name="l01126"></a>01126     {
<a name="l01127"></a>01127       _nvar  = 3;
<a name="l01128"></a>01128       _coef  = <span class="keyword">new</span> <span class="keywordtype">double</span>[_nvar];
<a name="l01129"></a>01129       _idvar = <span class="keyword">new</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>[_nvar];
<a name="l01130"></a>01130       _coef[0] = a1;
<a name="l01131"></a>01131       _coef[1] = a2;
<a name="l01132"></a>01132       _coef[2] = a3;
<a name="l01133"></a>01133       _idvar[0] = id1;
<a name="l01134"></a>01134       _idvar[1] = id2;
<a name="l01135"></a>01135       _idvar[2] = id3;
<a name="l01136"></a>01136     }
<a name="l01138"></a>01138   <a class="code" href="group__FP.html#ga90f70f350ea4fc220bb335154c788585" title="Default constructor for cut.">FPCut</a>
<a name="l01139"></a><a class="code" href="group__FP.html#ga9fbd83b00032a398ad1137df225af027">01139</a>     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">TYPE</a> type, <span class="keyword">const</span> <span class="keywordtype">double</span> b,
<a name="l01140"></a>01140       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>*<span class="keywordtype">id</span>,
<a name="l01141"></a>01141       <span class="keyword">const</span> <span class="keywordtype">double</span>*a ):
<a name="l01142"></a>01142     _op(op), _type(type), _rhs(b)
<a name="l01143"></a>01143     {
<a name="l01144"></a>01144       _nvar  = n;
<a name="l01145"></a>01145       _coef  = <span class="keyword">new</span> <span class="keywordtype">double</span>[_nvar];
<a name="l01146"></a>01146       _idvar = <span class="keyword">new</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>[_nvar];
<a name="l01147"></a>01147       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ivar=0; ivar&lt;_nvar; ivar++ ){
<a name="l01148"></a>01148         _coef[ivar] = a[ivar]; _idvar[ivar] = <span class="keywordtype">id</span>[ivar];
<a name="l01149"></a>01149       }
<a name="l01150"></a>01150     }
<a name="l01152"></a><a class="code" href="group__FP.html#gad794d71f29dfa71ca66226b16f2bf3a1">01152</a>   <a class="code" href="group__FP.html#gad794d71f29dfa71ca66226b16f2bf3a1" title="Destructor.">~FPCut</a>()
<a name="l01153"></a>01153     {
<a name="l01154"></a>01154       <span class="keyword">delete</span>[] _coef;
<a name="l01155"></a>01155       <span class="keyword">delete</span>[] _idvar;
<a name="l01156"></a>01156     }
<a name="l01158"></a>01158 };
<a name="l01159"></a>01159 
<a name="l01165"></a>01165 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01166"></a><a class="code" href="structmc_1_1lt__FPCut.html">01166</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__FPCut.html" title="C++ structure for cuts comparison.">lt_FPCut</a>
<a name="l01168"></a>01168 {
<a name="l01169"></a>01169   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l01170"></a>01170     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>*Cut1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>*Cut2 )<span class="keyword"> const</span>
<a name="l01171"></a>01171 <span class="keyword">    </span>{
<a name="l01172"></a>01172       <span class="comment">// Order cuts w.r.t. their types first</span>
<a name="l01173"></a>01173       <span class="keywordflow">if</span>( Cut1-&gt;<a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044" title="Retreive type of cut.">type</a>() &lt; Cut2-&gt;<a class="code" href="group__FP.html#gaad434e1495139dfe32f098d8c450c044" title="Retreive type of cut.">type</a>() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01174"></a>01174       <span class="comment">// then w.r.t. their defining operation next</span>
<a name="l01175"></a>01175       <span class="keywordflow">return</span> ( Cut1-&gt;<a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>() &amp;&amp; Cut2-&gt;<a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>() ?
<a name="l01176"></a>01176         <a class="code" href="structmc_1_1lt__FPOp.html" title="C++ structure for comparing operations in a factorable program.">lt_FPOp&lt;T&gt;</a>()( Cut1-&gt;<a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>(), Cut2-&gt;<a class="code" href="group__FP.html#gaa93cfb73ea235ba0be114f5e4a274622" title="Retreive pointer to defining operation.">op</a>() ):
<a name="l01177"></a>01177         <span class="keyword">false</span> );
<a name="l01178"></a>01178     }
<a name="l01179"></a>01179 };
<a name="l01180"></a>01180 
<a name="l01186"></a>01186 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01187"></a><a class="code" href="classmc_1_1FPRLT.html">01187</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT</a>
<a name="l01189"></a>01189 {
<a name="l01190"></a>01190   <span class="comment">// friends of class FPCut for operator overloading</span>
<a name="l01191"></a>01191   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l01192"></a>01192     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;U&gt;</a>&amp; );
<a name="l01193"></a>01193 
<a name="l01194"></a>01194 <span class="keyword">private</span>:
<a name="l01196"></a>01196   <span class="keyword">struct </span>RLTTerm
<a name="l01197"></a>01197   {
<a name="l01199"></a>01199     RLTTerm
<a name="l01200"></a>01200       ( <span class="keywordtype">double</span> a, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*e):
<a name="l01201"></a>01201       coef(a), nexp(n)
<a name="l01202"></a>01202       { iexp = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nexp];
<a name="l01203"></a>01203         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nexp; i++) iexp[i]=e[i]; }
<a name="l01205"></a>01205     RLTTerm
<a name="l01206"></a>01206       ( <span class="keyword">const</span> RLTTerm&amp;term ):
<a name="l01207"></a>01207       coef(term.coef), nexp(term.nexp)
<a name="l01208"></a>01208       { iexp = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nexp];
<a name="l01209"></a>01209         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nexp; i++) iexp[i]=term.iexp[i]; }
<a name="l01211"></a>01211     ~RLTTerm()
<a name="l01212"></a>01212       { <span class="keyword">delete</span>[] iexp; }
<a name="l01214"></a>01214     <span class="keywordtype">double</span> coef;
<a name="l01216"></a>01216     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *iexp;
<a name="l01218"></a>01218     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nexp;
<a name="l01219"></a>01219   };
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="keyword">public</span>:
<a name="l01225"></a>01225 
<a name="l01226"></a><a class="code" href="group__FP.html#ga6b3480c95d85d534c1941dc3d05a4118">01226</a>   <span class="keyword">typedef</span> std::pair&lt; const FPVar&lt;T&gt;*, RLTTerm &gt; <a class="code" href="group__FP.html#ga6b3480c95d85d534c1941dc3d05a4118" title="Typedef for left-hand side entry.">p_lhs</a>;
<a name="l01228"></a><a class="code" href="classmc_1_1FPRLT.html#a5f5d4afb943b454a6707c0076f934ea9">01228</a>   <span class="keyword">typedef</span> std::map&lt; const FPVar&lt;T&gt;*, RLTTerm, <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a> &gt; <a class="code" href="classmc_1_1FPRLT.html#a5f5d4afb943b454a6707c0076f934ea9" title="Typedef for left-hand side map.">t_lhs</a>;
<a name="l01230"></a><a class="code" href="classmc_1_1FPRLT.html#a836077c92ae19821ac9540c25ff60819">01230</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_lhs::iterator <a class="code" href="classmc_1_1FPRLT.html#a836077c92ae19821ac9540c25ff60819" title="Typedef for left-hand side map iterator.">it_lhs</a>;
<a name="l01232"></a><a class="code" href="classmc_1_1FPRLT.html#ac3ddd586348d20854178b3f2c7fdbaee">01232</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_lhs::const_iterator <a class="code" href="classmc_1_1FPRLT.html#ac3ddd586348d20854178b3f2c7fdbaee" title="Typedef for left-hand side map const_iterator.">cit_lhs</a>;
<a name="l01234"></a><a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4">01234</a>   <span class="keyword">enum</span> <a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4" title="Enumeration type for RLT constraints.">TYPE</a>{
<a name="l01235"></a><a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4a2044e750fdd995d2d1c6e8c879be2939">01235</a>     <a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4a2044e750fdd995d2d1c6e8c879be2939" title="Less-than-or-equal RLT constraint.">LE</a>=0,      
<a name="l01236"></a><a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4a7639cd4db0199e059ad8b3fc8c3468a7">01236</a>     <a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4a7639cd4db0199e059ad8b3fc8c3468a7" title="Greater-than-or-equal RLT constraint.">GE</a>         
<a name="l01237"></a>01237   };
<a name="l01240"></a>01240 <span class="keyword">private</span>:
<a name="l01242"></a>01242   TModel&lt; FPVar&lt;T&gt; &gt; *_pTM;
<a name="l01244"></a>01244   <a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4" title="Enumeration type for RLT constraints.">TYPE</a> _type;
<a name="l01246"></a>01246   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _order;
<a name="l01248"></a>01248   <a class="code" href="classmc_1_1FPRLT.html#a5f5d4afb943b454a6707c0076f934ea9" title="Typedef for left-hand side map.">t_lhs</a> _lhs;  
<a name="l01250"></a>01250   <span class="keywordtype">double</span> _rhs;
<a name="l01252"></a>01252   std::pair&lt;unsigned int, bool&gt; _flag;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 <span class="keyword">public</span>:
<a name="l01258"></a>01258 
<a name="l01259"></a><a class="code" href="group__FP.html#ga42cf72fa7deda34b958b61babadde947">01259</a>   TModel&lt; FPVar&lt;T&gt; &gt;*&amp; <a class="code" href="group__FP.html#ga42cf72fa7deda34b958b61babadde947" title="Retreive pointer to underyling Taylor model.">TM</a>()
<a name="l01260"></a>01260     { <span class="keywordflow">return</span> _pTM; }
<a name="l01262"></a><a class="code" href="group__FP.html#ga387acfcbcd8de756148089333dad1115">01262</a>   <span class="keyword">const</span> TModel&lt; FPVar&lt;T&gt; &gt;* <a class="code" href="group__FP.html#ga42cf72fa7deda34b958b61babadde947" title="Retreive pointer to underyling Taylor model.">TM</a>()<span class="keyword"> const</span>
<a name="l01263"></a>01263 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _pTM; }
<a name="l01265"></a><a class="code" href="group__FP.html#ga880fbb4f53c1dfc9b51a9c507e6d4e3c">01265</a>   <a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4" title="Enumeration type for RLT constraints.">TYPE</a> <a class="code" href="group__FP.html#ga880fbb4f53c1dfc9b51a9c507e6d4e3c" title="Retreive type of RLT constraint.">type</a>()<span class="keyword"> const</span>
<a name="l01266"></a>01266 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _type; }
<a name="l01268"></a><a class="code" href="group__FP.html#ga884ef9d4b1ed55fae98fc5a9ffcdd162">01268</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__FP.html#ga884ef9d4b1ed55fae98fc5a9ffcdd162" title="Retreive order of RLT constraint.">order</a>()<span class="keyword"> const</span>
<a name="l01269"></a>01269 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _order; }
<a name="l01271"></a><a class="code" href="group__FP.html#ga38e37b9602abaac0104ecd513ac465a2">01271</a>   <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRLT.html#a5f5d4afb943b454a6707c0076f934ea9" title="Typedef for left-hand side map.">t_lhs</a>&amp; <a class="code" href="group__FP.html#ga38e37b9602abaac0104ecd513ac465a2" title="Retreive reference to left-hand side map.">lhs</a>()<span class="keyword"> const </span>
<a name="l01272"></a>01272 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _lhs; }
<a name="l01274"></a><a class="code" href="group__FP.html#gadde4a41614eea58cc524bdbc3a98737a">01274</a>   <span class="keywordtype">double</span> <a class="code" href="group__FP.html#gadde4a41614eea58cc524bdbc3a98737a" title="Retreive right-hand side value.">rhs</a>()<span class="keyword"> const</span>
<a name="l01275"></a>01275 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _rhs; }
<a name="l01277"></a><a class="code" href="group__FP.html#ga0dd6f68e5d5f0b86c28672d9470a0044">01277</a>   std::pair&lt;unsigned int, bool&gt; <a class="code" href="group__FP.html#ga0dd6f68e5d5f0b86c28672d9470a0044" title="Retreive flag.">flag</a>()<span class="keyword"> const</span>
<a name="l01278"></a>01278 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _flag; }
<a name="l01279"></a>01279 
<a name="l01281"></a>01281   <a class="code" href="group__FP.html#gaa75975a26ee8dc1bff242a3979ba7170" title="Default constructor for RLT constraint.">FPRLT</a>
<a name="l01282"></a><a class="code" href="group__FP.html#gaa75975a26ee8dc1bff242a3979ba7170">01282</a>     ( TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*pTM ):
<a name="l01283"></a>01283     _pTM(pTM), _type(<a class="code" href="classmc_1_1FPRLT.html#a9cc2494de9228c258b581f58d3ef0bd4a7639cd4db0199e059ad8b3fc8c3468a7" title="Greater-than-or-equal RLT constraint.">GE</a>), _order(0), _lhs(), _rhs(0.), _flag(0,<span class="keyword">true</span>)
<a name="l01284"></a>01284     {}
<a name="l01286"></a><a class="code" href="group__FP.html#gae426daff4f23d1aba350ffd61d80080e">01286</a>   <a class="code" href="group__FP.html#gae426daff4f23d1aba350ffd61d80080e" title="Destructor.">~FPRLT</a>()
<a name="l01287"></a>01287     {}
<a name="l01288"></a>01288 
<a name="l01290"></a>01290   <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* <a class="code" href="group__FP.html#ga771ea871eaf78f29d9f5fad614387f8c" title="Generate new RLT constraint by multiplying with (X-XL) or (X-XU) - flag indicates the current variabl...">product</a>
<a name="l01291"></a>01291     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nexp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*iexp,
<a name="l01292"></a>01292       std::pair&lt;unsigned int, bool&gt; <a class="code" href="group__FP.html#ga0dd6f68e5d5f0b86c28672d9470a0044" title="Retreive flag.">flag</a> ) <span class="keyword">const</span>;
<a name="l01294"></a>01294   std::pair&lt;typename FPVar&lt;T&gt;::pt_idVar*, <span class="keywordtype">double</span>*&gt; <a class="code" href="group__FP.html#ga193233685a7e543dadf781f809442f60" title="Generate and return pair of variables indices (pt_idVar*) and coefficient (double*) arrays for RLT co...">lhs2cut</a>
<a name="l01295"></a>01295     () <span class="keyword">const</span>;
<a name="l01297"></a>01297   <span class="keywordtype">bool</span> <a class="code" href="group__FP.html#ga193233685a7e543dadf781f809442f60" title="Generate and return pair of variables indices (pt_idVar*) and coefficient (double*) arrays for RLT co...">lhs2cut</a>
<a name="l01298"></a>01298     ( std::pair&lt;<span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>*, <span class="keywordtype">double</span>*&gt;&amp;<a class="code" href="group__FP.html#ga38e37b9602abaac0104ecd513ac465a2" title="Retreive reference to left-hand side map.">lhs</a>,
<a name="l01299"></a>01299       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lhsmax ) <span class="keyword">const</span>;
<a name="l01301"></a>01301 };
<a name="l01302"></a>01302 
<a name="l01308"></a><a class="code" href="classmc_1_1FPOuter.html">01308</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPOuter.html" title="C++ structure for storing subintervals in an outer approximation.">FPOuter</a>
<a name="l01310"></a>01310 {
<a name="l01311"></a>01311 
<a name="l01312"></a>01312 <span class="keyword">public</span>:
<a name="l01314"></a><a class="code" href="classmc_1_1FPOuter.html#a3124f1222ae0ac89fd7a7f6d3872c3bd">01314</a>   <a class="code" href="classmc_1_1FPOuter.html#a3124f1222ae0ac89fd7a7f6d3872c3bd" title="Constructor.">FPOuter</a>( <span class="keyword">const</span> <span class="keywordtype">double</span> LB, <span class="keyword">const</span> <span class="keywordtype">double</span> UB, <span class="keyword">const</span> <span class="keywordtype">double</span> MID, 
<a name="l01315"></a>01315     <span class="keyword">const</span> <span class="keywordtype">double</span> GAP ):
<a name="l01316"></a>01316     _xL( LB ), _xU( UB ), _xM( MID ), _gap( GAP )
<a name="l01317"></a>01317     {}
<a name="l01319"></a><a class="code" href="classmc_1_1FPOuter.html#ad7168e023bf44104e1c4dae86203dc07">01319</a>   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classmc_1_1FPOuter.html#ad7168e023bf44104e1c4dae86203dc07" title="Retreive interval lower bound.">xL</a>()<span class="keyword"> const</span>
<a name="l01320"></a>01320 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _xL; }
<a name="l01322"></a><a class="code" href="classmc_1_1FPOuter.html#af18cbe6a93362066cf0b2af2603c9135">01322</a>   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classmc_1_1FPOuter.html#af18cbe6a93362066cf0b2af2603c9135" title="Retreive interval upper bound.">xU</a>()<span class="keyword"> const</span>
<a name="l01323"></a>01323 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _xU; }
<a name="l01325"></a><a class="code" href="classmc_1_1FPOuter.html#abd3e6ea03a60e9807ec12ef70d374ca7">01325</a>   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classmc_1_1FPOuter.html#abd3e6ea03a60e9807ec12ef70d374ca7" title="Retreive bisection point.">xM</a>()<span class="keyword"> const</span>
<a name="l01326"></a>01326 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _xM; }
<a name="l01328"></a><a class="code" href="classmc_1_1FPOuter.html#af7ee20ba73cde1f8579e528c8fb9ee50">01328</a>   <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="classmc_1_1FPOuter.html#af7ee20ba73cde1f8579e528c8fb9ee50" title="Retreive maximum gap.">gap</a>()<span class="keyword"> const</span>
<a name="l01329"></a>01329 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _gap; }
<a name="l01330"></a>01330 
<a name="l01331"></a>01331 <span class="keyword">private</span>:
<a name="l01333"></a>01333   <span class="keywordtype">double</span> _xL;
<a name="l01335"></a>01335   <span class="keywordtype">double</span> _xU;
<a name="l01337"></a>01337   <span class="keywordtype">double</span> _xM;
<a name="l01339"></a>01339   <span class="keywordtype">double</span> _gap;
<a name="l01340"></a>01340 };
<a name="l01341"></a>01341 
<a name="l01347"></a><a class="code" href="structmc_1_1lt__FPOuter.html">01347</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__FPOuter.html" title="C++ structure for comparing subintervals in an outer approximation.">lt_FPOuter</a>
<a name="l01349"></a>01349 {
<a name="l01350"></a>01350   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l01351"></a>01351     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOuter.html" title="C++ structure for storing subintervals in an outer approximation.">FPOuter</a>&amp;Dom1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOuter.html" title="C++ structure for storing subintervals in an outer approximation.">FPOuter</a>&amp;Dom2 )<span class="keyword"> const</span>
<a name="l01352"></a>01352 <span class="keyword">    </span>{
<a name="l01353"></a>01353       <span class="keywordflow">return</span>( Dom1.<a class="code" href="classmc_1_1FPOuter.html#af7ee20ba73cde1f8579e528c8fb9ee50" title="Retreive maximum gap.">gap</a>() &lt; Dom2.<a class="code" href="classmc_1_1FPOuter.html#af7ee20ba73cde1f8579e528c8fb9ee50" title="Retreive maximum gap.">gap</a>() );
<a name="l01354"></a>01354     }
<a name="l01355"></a>01355 };
<a name="l01356"></a>01356 
<a name="l01363"></a>01363 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01364"></a><a class="code" href="classmc_1_1FPOp.html">01364</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp</a>
<a name="l01366"></a>01366 {
<a name="l01367"></a>01367 <span class="keyword">public</span>:
<a name="l01368"></a>01368 
<a name="l01369"></a>01369   <span class="keyword">typedef</span> double (*p_Univ)( <span class="keyword">const</span> double, <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* );
<a name="l01370"></a>01370   <span class="keyword">typedef</span> std::pair&lt;double,double&gt; (*p_dUniv)( <span class="keyword">const</span> double, <span class="keyword">const</span> <span class="keywordtype">double</span>*,
<a name="l01371"></a>01371     <span class="keyword">const</span> <span class="keywordtype">int</span>* );
<a name="l01372"></a>01372   <span class="keyword">typedef</span> void (<a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>::*p_Cut)( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*,
<a name="l01373"></a>01373     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l01374"></a>01374     <span class="keyword">const</span> double, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>, <span class="keyword">const</span> double,
<a name="l01375"></a>01375     <span class="keyword">const</span> double );
<a name="l01376"></a>01376   <span class="keyword">typedef</span> void (<a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>::*p_Cutpar)( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*, <span class="keyword">const</span> double,
<a name="l01377"></a>01377     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l01378"></a>01378     <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l01379"></a>01379     <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* );
<a name="l01380"></a>01380   <span class="keyword">typedef</span> std::priority_queue&lt; FPOuter, std::vector&lt;FPOuter&gt;, <a class="code" href="structmc_1_1lt__FPOuter.html" title="C++ structure for comparing subintervals in an outer approximation.">lt_FPOuter</a> &gt; t_Outer;
<a name="l01381"></a>01381 
<a name="l01385"></a>01385 
<a name="l01386"></a><a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9">01386</a>   <span class="keyword">enum</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">TYPE</a>{
<a name="l01387"></a>01387     CNST=0, RANGE, VAR, MC, TM, TMMC,
<a name="l01388"></a>01388     EQ, LE, MIN, MAX, RLT,
<a name="l01389"></a>01389     PLUS, NEG, MINUS, TIMES, SCALE, DIV, INTER, BILIN,
<a name="l01390"></a>01390     EXP, LOG, SQRT, SQR, IPOW, POW, COS, TAN, ASIN, ATAN,
<a name="l01391"></a>01391     FABS, XLOG, ARH, ERF, FSTEP, MINF, MAXF
<a name="l01392"></a>01392   };
<a name="l01393"></a>01393 
<a name="l01395"></a><a class="code" href="group__FP.html#ga800750c7919507567b747cfba6b9cdfd">01395</a>   <a class="code" href="group__FP.html#ga800750c7919507567b747cfba6b9cdfd" title="Constructor.">FPOp</a>( <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">TYPE</a> op, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*lop=0, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*rop=0, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*res=0 ):
<a name="l01396"></a>01396     type( op ), <a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>( res ), _visited(false), _pMC(0), _pTM(0), _pTMMC(0)
<a name="l01397"></a>01397     {
<a name="l01398"></a>01398       <span class="comment">// Order operands for commutative binary operators</span>
<a name="l01399"></a>01399       <span class="keywordflow">if</span>( !lop
<a name="l01400"></a>01400         || ( op != PLUS &amp;&amp; op != TIMES &amp;&amp; op != SCALE &amp;&amp; op != INTER &amp;&amp; op != EQ )
<a name="l01401"></a>01401         || <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a>()( lop, rop ) )
<a name="l01402"></a>01402         { <a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> = lop; <a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093" title="Pointer to right operand.">prop</a> = rop; }
<a name="l01403"></a>01403       <span class="keywordflow">else</span>
<a name="l01404"></a>01404         { <a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> = rop; <a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093" title="Pointer to right operand.">prop</a> = lop; }
<a name="l01405"></a>01405     }
<a name="l01406"></a>01406 
<a name="l01408"></a><a class="code" href="group__FP.html#ga7856920c3cbc8603e98e803633fce9c3">01408</a>   <a class="code" href="group__FP.html#ga7856920c3cbc8603e98e803633fce9c3" title="Destructor.">~FPOp</a>()
<a name="l01409"></a>01409     {
<a name="l01410"></a>01410       <span class="keyword">delete</span> _pMC;
<a name="l01411"></a>01411       <span class="keyword">delete</span> _pTM;
<a name="l01412"></a>01412       <span class="keyword">delete</span> _pTMMC;
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414 
<a name="l01416"></a><a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a">01416</a>   <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">TYPE</a> <a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a>;
<a name="l01418"></a><a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d">01418</a>   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>;
<a name="l01420"></a><a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3">01420</a>   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a>;
<a name="l01422"></a><a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093">01422</a>   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093" title="Pointer to right operand.">prop</a>;
<a name="l01423"></a>01423 
<a name="l01425"></a>01425   <span class="keywordtype">void</span> <a class="code" href="group__FP.html#ga7ec730514eb7a24c327760859963d516" title="Generate polyhedral cuts for all operations in the factorable program pFP">generate_cuts</a>
<a name="l01426"></a>01426     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP );
<a name="l01428"></a>01428   <span class="keywordtype">void</span> <a class="code" href="group__FP.html#ga5e662e9cc5e0d49cb088966e43dab89c" title="Append polyhedral cuts for the current operation in the factorable program pFP">append_cuts</a>
<a name="l01429"></a>01429     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP );
<a name="l01431"></a>01431   <span class="keywordtype">bool</span> <a class="code" href="group__FP.html#gac2debf37675cff7ace49921505250f1e" title="Propagate bounds for all operations in the factorable program pFP">propagate_bounds</a>
<a name="l01432"></a>01432     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP );
<a name="l01434"></a>01434   <span class="keywordtype">bool</span> <a class="code" href="group__FP.html#ga820f6b68a854cb7f026918da3c384f1e" title="Tighten variable bounds for the current operation in the factorable program pFP via constraint propag...">tighten_bounds</a>
<a name="l01435"></a>01435     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP );
<a name="l01436"></a>01436 
<a name="l01438"></a>01438   <span class="keywordtype">void</span> <a class="code" href="group__FP.html#ga6a35bd8997fcfa3d88e4fed7c75eb573" title="Attach Taylor model to variable to be handled during cut generation.">attach</a>
<a name="l01439"></a><a class="code" href="group__FP.html#ga6a35bd8997fcfa3d88e4fed7c75eb573">01439</a>     ( <span class="keyword">const</span> McCormick&lt;T&gt;&amp;MC )
<a name="l01440"></a>01440     { _pMC = <span class="keyword">new</span> McCormick&lt;T&gt;( MC ); }
<a name="l01442"></a>01442   <span class="keywordtype">void</span> <a class="code" href="group__FP.html#ga6a35bd8997fcfa3d88e4fed7c75eb573" title="Attach Taylor model to variable to be handled during cut generation.">attach</a>
<a name="l01443"></a><a class="code" href="group__FP.html#ga34461104dc373b3aabd8c1705caad4e6">01443</a>     ( <span class="keyword">const</span> TVar&lt;T&gt;&amp;TV, TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP )
<a name="l01444"></a>01444     { _pTM = <span class="keyword">new</span> std::pair&lt; TVar&lt;T&gt;, TModel&lt; FPVar&lt;T&gt; &gt;* &gt;( TV, TMFP ); }
<a name="l01446"></a>01446   <span class="keywordtype">void</span> <a class="code" href="group__FP.html#ga6a35bd8997fcfa3d88e4fed7c75eb573" title="Attach Taylor model to variable to be handled during cut generation.">attach</a>
<a name="l01447"></a><a class="code" href="group__FP.html#gac494105c4b1f85f5769e0ab536961715">01447</a>     ( <span class="keyword">const</span> TVar&lt; McCormick&lt;T&gt; &gt;&amp;TVMC, TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP )
<a name="l01448"></a>01448     { _pTMMC = <span class="keyword">new</span> std::pair&lt; TVar&lt; McCormick&lt;T&gt; &gt;, TModel&lt; FPVar&lt;T&gt; &gt;* &gt;( TVMC, TMFP ); }
<a name="l01449"></a>01449 
<a name="l01451"></a>01451   <span class="keywordtype">void</span> <span class="keyword">set</span>
<a name="l01452"></a><a class="code" href="group__FP.html#gaba648610106c718da20f53a81a898cbe">01452</a>     ( <span class="keyword">const</span> <span class="keywordtype">bool</span> visited=true )
<a name="l01453"></a>01453     { _visited = visited; }
<a name="l01455"></a><a class="code" href="group__FP.html#ga58e63ffb9c20514fff7513fbf5051c86">01455</a>   <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="group__FP.html#ga58e63ffb9c20514fff7513fbf5051c86" title="Retreive operation status (visited or not)">status</a>()<span class="keyword"> const</span>
<a name="l01456"></a>01456 <span class="keyword">    </span>{ <span class="keywordflow">return</span> _visited; }
<a name="l01458"></a><a class="code" href="group__FP.html#gae353089b87672ca6f2e9747fbee51248">01458</a>   <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; <a class="code" href="group__FP.html#ga58e63ffb9c20514fff7513fbf5051c86" title="Retreive operation status (visited or not)">status</a>()
<a name="l01459"></a>01459     { <span class="keywordflow">return</span> _visited; }
<a name="l01462"></a>01462 <span class="keyword">private</span>:
<a name="l01464"></a>01464   <span class="keywordtype">bool</span> _visited;
<a name="l01465"></a>01465 
<a name="l01467"></a>01467   McCormick&lt;T&gt; *_pMC;
<a name="l01469"></a>01469   std::pair&lt; TVar&lt;T&gt;, TModel&lt; FPVar&lt;T&gt; &gt;* &gt; *_pTM;
<a name="l01471"></a>01471   std::pair&lt; TVar&lt; McCormick&lt;T&gt; &gt;, TModel&lt; FPVar&lt;T&gt; &gt;* &gt; *_pTMMC;
<a name="l01472"></a>01472 
<a name="l01474"></a>01474   <span class="keywordtype">bool</span> _EQ_bounds
<a name="l01475"></a>01475     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01477"></a>01477   <span class="keywordtype">bool</span> _LE_bounds
<a name="l01478"></a>01478     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01480"></a>01480   <span class="keywordtype">bool</span> _PLUS_bounds
<a name="l01481"></a>01481     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01482"></a>01482       <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01484"></a>01484   <span class="keywordtype">bool</span> _NEG_bounds
<a name="l01485"></a>01485     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1 );
<a name="l01487"></a>01487   <span class="keywordtype">bool</span> _MINUS_bounds
<a name="l01488"></a>01488     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01489"></a>01489       <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01491"></a>01491   <span class="keywordtype">bool</span> _TIMES_bounds
<a name="l01492"></a>01492     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01493"></a>01493       <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01495"></a>01495   <span class="keywordtype">bool</span> _DIV_bounds
<a name="l01496"></a>01496     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01497"></a>01497       <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01499"></a>01499   <span class="keywordtype">bool</span> _EXP_bounds
<a name="l01500"></a>01500     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01502"></a>01502   <span class="keywordtype">bool</span> _LOG_bounds
<a name="l01503"></a>01503     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01505"></a>01505   <span class="keywordtype">bool</span> _SQR_bounds
<a name="l01506"></a>01506     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01508"></a>01508   <span class="keywordtype">bool</span> _SQRT_bounds
<a name="l01509"></a>01509     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01511"></a>01511   <span class="keywordtype">bool</span> _FABS_bounds
<a name="l01512"></a>01512     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01514"></a>01514   <span class="keywordtype">bool</span> _IPOW_bounds
<a name="l01515"></a>01515     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Exp );
<a name="l01516"></a>01516 
<a name="l01518"></a>01518   <span class="keywordtype">void</span> _EQ_cuts
<a name="l01519"></a>01519     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01521"></a>01521   <span class="keywordtype">void</span> _LE_cuts
<a name="l01522"></a>01522     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01524"></a>01524   <span class="keywordtype">void</span> _PLUS_cuts
<a name="l01525"></a>01525     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01526"></a>01526       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01528"></a>01528   <span class="keywordtype">void</span> _NEG_cuts
<a name="l01529"></a>01529     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1 );
<a name="l01531"></a>01531   <span class="keywordtype">void</span> _MINUS_cuts
<a name="l01532"></a>01532     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01533"></a>01533       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01535"></a>01535   <span class="keywordtype">void</span> _TIMES_cuts
<a name="l01536"></a>01536     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01537"></a>01537       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01539"></a>01539   <span class="keywordtype">void</span> _DIV_cuts
<a name="l01540"></a>01540     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01541"></a>01541       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01543"></a>01543   <span class="keywordtype">void</span> _INTER_cuts
<a name="l01544"></a>01544     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01545"></a>01545       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01547"></a>01547   <span class="keywordtype">void</span> _MINF_cuts
<a name="l01548"></a>01548     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01549"></a>01549       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01551"></a>01551   <span class="keywordtype">void</span> _MAXF_cuts
<a name="l01552"></a>01552     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01553"></a>01553       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01555"></a>01555   <span class="keywordtype">void</span> _BILIN_cuts
<a name="l01556"></a>01556     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01557"></a>01557       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01559"></a>01559   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>** _subdivide
<a name="l01560"></a>01560     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv,
<a name="l01561"></a>01561       <span class="keywordtype">double</span>*a, <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>*<span class="keywordtype">id</span> );
<a name="l01563"></a>01563   <span class="keywordtype">void</span> _semilinear_cut
<a name="l01564"></a>01564     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01565"></a>01565       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>**dVarX, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01566"></a>01566       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, p_Univ f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0,
<a name="l01567"></a>01567       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01569"></a>01569   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>** _subdivide_SOS
<a name="l01570"></a>01570     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv,
<a name="l01571"></a>01571       <span class="keywordtype">double</span>*a, <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>*<span class="keywordtype">id</span> );
<a name="l01573"></a>01573   <span class="keywordtype">void</span> _semilinear_SOS
<a name="l01574"></a>01574     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01575"></a>01575       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>**dVarX, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01576"></a>01576       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, p_Univ f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0,
<a name="l01577"></a>01577       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01579"></a>01579   std::pair&lt; double, double &gt; _distmax
<a name="l01580"></a>01580     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, p_dUniv f, <span class="keyword">const</span> <span class="keywordtype">double</span> xL, <span class="keyword">const</span> <span class="keywordtype">double</span> xU,
<a name="l01581"></a>01581       <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 ) <span class="keyword">const</span>;
<a name="l01583"></a>01583   <span class="keywordtype">void</span> _sandwich_cuts
<a name="l01584"></a>01584     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01585"></a>01585       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l01586"></a>01586       <span class="keyword">const</span> <span class="keywordtype">double</span> YU, p_Cutpar Cut, p_dUniv f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0,
<a name="l01587"></a>01587       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01589"></a>01589   <span class="keywordtype">double</span> _newton
<a name="l01590"></a>01590     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> x0, <span class="keyword">const</span> <span class="keywordtype">double</span> xL,
<a name="l01591"></a>01591       <span class="keyword">const</span> <span class="keywordtype">double</span> xU, p_dUniv f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr=0 ) <span class="keyword">const</span>;
<a name="l01593"></a>01593   <span class="keywordtype">double</span> _secant
<a name="l01594"></a>01594     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> x0, <span class="keyword">const</span> <span class="keywordtype">double</span> x1, <span class="keyword">const</span> <span class="keywordtype">double</span> xL,
<a name="l01595"></a>01595       <span class="keyword">const</span> <span class="keywordtype">double</span> xU, p_Univ f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr=0 ) <span class="keyword">const</span>;
<a name="l01597"></a>01597   <span class="keywordtype">void</span> _EXP_cuts
<a name="l01598"></a>01598     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01600"></a>01600   <span class="keywordtype">void</span> _LOG_cuts
<a name="l01601"></a>01601     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01603"></a>01603   <span class="keywordtype">void</span> _addcut_expcv
<a name="l01604"></a>01604     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01605"></a>01605       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01606"></a>01606       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01608"></a>01608   <span class="keywordtype">void</span> _addcut_expcc
<a name="l01609"></a>01609     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01610"></a>01610       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l01611"></a>01611       <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01613"></a>01613   <span class="keywordtype">void</span> _SQR_cuts
<a name="l01614"></a>01614     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01616"></a>01616   <span class="keywordtype">void</span> _SQRT_cuts
<a name="l01617"></a>01617     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01619"></a>01619   <span class="keywordtype">void</span> _addcut_sqrcv
<a name="l01620"></a>01620     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01621"></a>01621       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01622"></a>01622       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01624"></a>01624   <span class="keywordtype">void</span> _addcut_sqrcc
<a name="l01625"></a>01625     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01626"></a>01626       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l01627"></a>01627       <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar=0, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar=0 );
<a name="l01629"></a>01629   <span class="keywordtype">void</span> _FABS_cuts
<a name="l01630"></a>01630     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01632"></a>01632   <span class="keywordtype">void</span> _IPOW_cuts
<a name="l01633"></a>01633     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var,
<a name="l01634"></a>01634       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Exp );
<a name="l01636"></a>01636   <span class="keywordtype">void</span> _addcut_powcv_lin
<a name="l01637"></a>01637     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01638"></a>01638       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01639"></a>01639       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp );
<a name="l01641"></a>01641   <span class="keywordtype">void</span> _addcut_powcc_lin
<a name="l01642"></a>01642     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01643"></a>01643       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01644"></a>01644       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp );
<a name="l01646"></a>01646   <span class="keywordtype">void</span> _addcut_powcv_sec
<a name="l01647"></a>01647     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01648"></a>01648       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01649"></a>01649       <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp );
<a name="l01651"></a>01651   <span class="keywordtype">void</span> _addcut_powcc_sec
<a name="l01652"></a>01652     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01653"></a>01653       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01654"></a>01654       <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp );
<a name="l01656"></a>01656   <span class="keywordtype">void</span> _COS_cuts
<a name="l01657"></a>01657     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01659"></a>01659   <span class="keywordtype">void</span> _addcut_coscv_lin
<a name="l01660"></a>01660     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01661"></a>01661       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01662"></a>01662       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01664"></a>01664   <span class="keywordtype">void</span> _addcut_coscc_lin
<a name="l01665"></a>01665     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01666"></a>01666       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01667"></a>01667       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01669"></a>01669   <span class="keywordtype">void</span> _addcut_coscv_sec
<a name="l01670"></a>01670     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01671"></a>01671       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01672"></a>01672       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01674"></a>01674   <span class="keywordtype">void</span> _addcut_coscc_sec
<a name="l01675"></a>01675     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01676"></a>01676       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01677"></a>01677       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01679"></a>01679   <span class="keywordtype">void</span> _ASIN_cuts
<a name="l01680"></a>01680     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01682"></a>01682   <span class="keywordtype">void</span> _addcut_asin1cv
<a name="l01683"></a>01683     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01684"></a>01684       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01685"></a>01685       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01687"></a>01687   <span class="keywordtype">void</span> _addcut_asin1cc
<a name="l01688"></a>01688     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01689"></a>01689       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l01690"></a>01690       <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01692"></a>01692   <span class="keywordtype">void</span> _addcut_asin2cc
<a name="l01693"></a>01693     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01694"></a>01694       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01695"></a>01695       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01697"></a>01697   <span class="keywordtype">void</span> _addcut_asin2cv
<a name="l01698"></a>01698     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01699"></a>01699       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l01700"></a>01700       <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01702"></a>01702   <span class="keywordtype">void</span> _addcut_asin3cc
<a name="l01703"></a>01703     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01704"></a>01704       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01705"></a>01705       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01707"></a>01707   <span class="keywordtype">void</span> _addcut_asin3cv
<a name="l01708"></a>01708     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01709"></a>01709       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l01710"></a>01710       <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01712"></a>01712   <span class="keywordtype">void</span> _ATAN_cuts
<a name="l01713"></a>01713     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01715"></a>01715   <span class="keywordtype">void</span> _TAN_cuts
<a name="l01716"></a>01716     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01718"></a>01718   <span class="keywordtype">void</span> _addcut_atancv_lin
<a name="l01719"></a>01719     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01720"></a>01720       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01721"></a>01721       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01723"></a>01723   <span class="keywordtype">void</span> _addcut_atancc_lin
<a name="l01724"></a>01724     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01725"></a>01725       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01726"></a>01726       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01728"></a>01728   <span class="keywordtype">void</span> _addcut_atancv_sec
<a name="l01729"></a>01729     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01730"></a>01730       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01731"></a>01731       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01733"></a>01733   <span class="keywordtype">void</span> _addcut_atancc_sec
<a name="l01734"></a>01734     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01735"></a>01735       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01736"></a>01736       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01738"></a>01738   <span class="keywordtype">void</span> _ERF_cuts
<a name="l01739"></a>01739     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01741"></a>01741   <span class="keywordtype">void</span> _addcut_erfcv_lin
<a name="l01742"></a>01742     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01743"></a>01743       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01744"></a>01744       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01746"></a>01746   <span class="keywordtype">void</span> _addcut_erfcc_lin
<a name="l01747"></a>01747     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX,
<a name="l01748"></a>01748       <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY,
<a name="l01749"></a>01749       <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01751"></a>01751   <span class="keywordtype">void</span> _addcut_erfcv_sec
<a name="l01752"></a>01752     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01753"></a>01753       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01754"></a>01754       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01756"></a>01756   <span class="keywordtype">void</span> _addcut_erfcc_sec
<a name="l01757"></a>01757     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l01758"></a>01758       <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l01759"></a>01759       <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar );
<a name="l01761"></a>01761   <span class="keywordtype">void</span> _FSTEP_cuts
<a name="l01762"></a>01762     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var );
<a name="l01764"></a>01764   <span class="keywordtype">void</span> _FMAX_cuts
<a name="l01765"></a>01765     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01766"></a>01766       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01768"></a>01768   <span class="keywordtype">void</span> _FMIN_cuts
<a name="l01769"></a>01769     ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*VarR, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1,
<a name="l01770"></a>01770       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 );
<a name="l01771"></a>01771 };
<a name="l01772"></a>01772 
<a name="l01778"></a>01778 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01779"></a><a class="code" href="structmc_1_1lt__FPOp.html">01779</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__FPOp.html" title="C++ structure for comparing operations in a factorable program.">lt_FPOp</a>
<a name="l01781"></a>01781 {
<a name="l01782"></a>01782   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l01783"></a>01783     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*Op1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*Op2 )<span class="keyword"> const</span>
<a name="l01784"></a>01784 <span class="keyword">    </span>{
<a name="l01785"></a>01785       <span class="comment">// Sort by type of operation first</span>
<a name="l01786"></a>01786       <span class="keywordflow">if</span>( Op1-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> &lt; Op2-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01787"></a>01787       <span class="keywordflow">if</span>( Op1-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> &gt; Op2-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01788"></a>01788       <span class="keywordflow">if</span>( Op1-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> == <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::RLT</a> ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01789"></a>01789 
<a name="l01790"></a>01790       <span class="comment">// Sort by variable type next</span>
<a name="l01791"></a>01791       <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a> ltVar;
<a name="l01792"></a>01792       <span class="keywordflow">if</span>( !Op1-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> ) <span class="keywordflow">return</span> ltVar( Op1-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>, Op2-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> );
<a name="l01793"></a>01793       <span class="keywordflow">if</span>( ltVar( Op1-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a>, Op2-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> ) ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01794"></a>01794       <span class="keywordflow">if</span>( ltVar( Op2-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a>, Op1-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01795"></a>01795       <span class="keywordflow">if</span>( Op1-&gt;<a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093" title="Pointer to right operand.">prop</a> ) <span class="keywordflow">return</span> ltVar( Op1-&gt;<a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093" title="Pointer to right operand.">prop</a>, Op2-&gt;<a class="code" href="group__FP.html#ga91df94a271b2fb7581200fb4ed380093" title="Pointer to right operand.">prop</a> );
<a name="l01796"></a>01796       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01797"></a>01797     }
<a name="l01798"></a>01798 };
<a name="l01799"></a>01799 
<a name="l01805"></a>01805 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01806"></a><a class="code" href="structmc_1_1range__FPOp.html">01806</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1range__FPOp.html" title="C++ structure for comparing operations in a factorable program.">range_FPOp</a>
<a name="l01808"></a>01808 {
<a name="l01809"></a>01809   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l01810"></a>01810     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*Op1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*Op2 )<span class="keyword"> const</span>
<a name="l01811"></a>01811 <span class="keyword">    </span>{ <span class="keywordflow">return</span> ( Op1-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> &lt; Op2-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> ); }
<a name="l01812"></a>01812 };
<a name="l01813"></a>01813 
<a name="l01820"></a>01820 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01821"></a><a class="code" href="classmc_1_1FPRelax.html">01821</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax</a>
<a name="l01823"></a>01823 {
<a name="l01824"></a>01824   <span class="comment">// friends of class FPRelax</span>
<a name="l01825"></a>01825   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>;
<a name="l01826"></a>01826   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp</a>;
<a name="l01827"></a>01827   <span class="comment">//template &lt;typename U&gt; friend void FPOp&lt;U&gt;::append_cuts( FPRelax&lt;U&gt;*pFP );</span>
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   <span class="comment">// friends of class FPVar for operator overloading</span>
<a name="l01830"></a>01830   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l01831"></a>01831     ( std::ostream&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;U&gt;</a>&amp; );
<a name="l01832"></a>01832   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l01833"></a>01833     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01834"></a>01834   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l01835"></a>01835     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01836"></a>01836   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l01837"></a>01837     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01838"></a>01838   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l01839"></a>01839     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l01840"></a>01840   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l01841"></a>01841     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01842"></a>01842   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>+
<a name="l01843"></a>01843     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l01844"></a>01844   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l01845"></a>01845     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01846"></a>01846   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l01847"></a>01847     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01848"></a>01848   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l01849"></a>01849     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01850"></a>01850   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l01851"></a>01851     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l01852"></a>01852   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l01853"></a>01853     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01854"></a>01854   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>-
<a name="l01855"></a>01855     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l01856"></a>01856   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l01857"></a>01857     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01858"></a>01858   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l01859"></a>01859     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01860"></a>01860   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l01861"></a>01861     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l01862"></a>01862   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l01863"></a>01863     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01864"></a>01864   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>*
<a name="l01865"></a>01865     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l01866"></a>01866   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l01867"></a>01867     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01868"></a>01868   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l01869"></a>01869     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01870"></a>01870   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l01871"></a>01871     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l01872"></a>01872   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l01873"></a>01873     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01874"></a>01874   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>/
<a name="l01875"></a>01875     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l01876"></a>01876   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> <span class="keyword">operator</span>^
<a name="l01877"></a>01877     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01878"></a>01878   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l01879"></a>01879     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01880"></a>01880   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l01881"></a>01881     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01882"></a>01882   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l01883"></a>01883     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l01884"></a>01884   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l01885"></a>01885     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01886"></a>01886   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l01887"></a>01887     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l01888"></a>01888   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> max
<a name="l01889"></a>01889     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>* );
<a name="l01890"></a>01890   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l01891"></a>01891     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01892"></a>01892   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l01893"></a>01893     ( <span class="keyword">const</span> U&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01894"></a>01894   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l01895"></a>01895     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> U&amp; );
<a name="l01896"></a>01896   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l01897"></a>01897     ( <span class="keyword">const</span> V&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01898"></a>01898   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l01899"></a>01899     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> V&amp; );
<a name="l01900"></a>01900   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> min
<a name="l01901"></a>01901     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>* );
<a name="l01902"></a>01902 
<a name="l01903"></a>01903   <span class="comment">// friends of class FPVar for function overloading</span>
<a name="l01904"></a>01904   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> inv
<a name="l01905"></a>01905     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01906"></a>01906   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> sqr
<a name="l01907"></a>01907     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01908"></a>01908   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> exp
<a name="l01909"></a>01909     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01910"></a>01910   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> log
<a name="l01911"></a>01911     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01912"></a>01912   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> sqrt
<a name="l01913"></a>01913     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01914"></a>01914   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> fabs
<a name="l01915"></a>01915     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01916"></a>01916   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> pow
<a name="l01917"></a>01917     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <span class="keywordtype">int</span> );
<a name="l01918"></a>01918   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> cos
<a name="l01919"></a>01919     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01920"></a>01920   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> sin
<a name="l01921"></a>01921     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01922"></a>01922   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> tan
<a name="l01923"></a>01923     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01924"></a>01924   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> acos
<a name="l01925"></a>01925     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01926"></a>01926   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> asin
<a name="l01927"></a>01927     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01928"></a>01928   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> atan
<a name="l01929"></a>01929     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01930"></a>01930 <span class="comment">//   template &lt;typename U&gt; friend FPVar&lt;U&gt; xlog</span>
<a name="l01931"></a>01931 <span class="comment">//     ( const FPVar&lt;U&gt;&amp; );</span>
<a name="l01932"></a>01932 <span class="comment">//   template &lt;typename U&gt; friend FPVar&lt;U&gt; arh</span>
<a name="l01933"></a>01933 <span class="comment">//     ( const FPVar&lt;U&gt;&amp;, const double );</span>
<a name="l01934"></a>01934   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> erf
<a name="l01935"></a>01935     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01936"></a>01936   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> erfc
<a name="l01937"></a>01937     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01938"></a>01938   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> fstep
<a name="l01939"></a>01939     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01940"></a>01940   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> bstep
<a name="l01941"></a>01941     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01942"></a>01942   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a> bilin
<a name="l01943"></a>01943     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;U&gt;</a>&amp; );
<a name="l01944"></a>01944 
<a name="l01945"></a>01945 <span class="keyword">public</span>:
<a name="l01949"></a>01949   <span class="keyword">typedef</span> std::multimap&lt; const FPVar&lt;T&gt;*, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*, <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a> &gt; t_Vars_Ops;
<a name="l01950"></a>01950   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars_Ops::iterator it_Vars_Ops;
<a name="l01951"></a>01951   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars_Ops::const_iterator cit_Vars_Ops;
<a name="l01952"></a>01952   <span class="keyword">typedef</span> std::multiset&lt; FPCut&lt;T&gt;*, <a class="code" href="structmc_1_1lt__FPCut.html" title="C++ structure for cuts comparison.">lt_FPCut&lt;T&gt;</a> &gt; t_Cuts;
<a name="l01953"></a>01953   <span class="keyword">typedef</span> std::set&lt; FPVar&lt;T&gt;*, <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a> &gt; t_Vars;
<a name="l01954"></a>01954   <span class="keyword">typedef</span> std::set&lt; FPOp&lt;T&gt;*,  <a class="code" href="structmc_1_1lt__FPOp.html" title="C++ structure for comparing operations in a factorable program.">lt_FPOp&lt;T&gt;</a> &gt; t_Ops;
<a name="l01955"></a>01955   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Cuts::iterator it_Cuts;
<a name="l01956"></a>01956   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Cuts::const_iterator cit_Cuts;
<a name="l01957"></a>01957   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars::iterator it_Vars;
<a name="l01958"></a>01958   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars::const_iterator cit_Vars;
<a name="l01959"></a>01959   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Ops::iterator  it_Ops;
<a name="l01960"></a>01960   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Ops::const_iterator  cit_Ops;
<a name="l01961"></a>01961   <span class="keyword">typedef</span> <span class="keyword">typename</span> std::pair&lt; it_Vars, bool &gt; pt_Vars;
<a name="l01962"></a>01962   <span class="keyword">typedef</span> <span class="keyword">typename</span> std::pair&lt; it_Ops, bool &gt; pt_Ops;
<a name="l01963"></a>01963   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> pt_idVar;
<a name="l01966"></a>01966 <span class="keyword">protected</span>:
<a name="l01968"></a><a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40">01968</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a>;
<a name="l01970"></a><a class="code" href="classmc_1_1FPRelax.html#ae186ed32dfca710e221266751ac14b7f">01970</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classmc_1_1FPRelax.html#ae186ed32dfca710e221266751ac14b7f" title="Number of auxiliary variables in factorable program.">_naux</a>;
<a name="l01971"></a>01971 
<a name="l01973"></a><a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec">01973</a>   t_Vars <a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>;
<a name="l01975"></a><a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5">01975</a>   t_Ops  <a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>;
<a name="l01977"></a><a class="code" href="classmc_1_1FPRelax.html#a0c90754865d2a3ed01b99fb595c29140">01977</a>   t_Cuts <a class="code" href="classmc_1_1FPRelax.html#a0c90754865d2a3ed01b99fb595c29140" title="Set of cuts in relaxed factorable program.">_Cuts</a>;
<a name="l01978"></a>01978 
<a name="l01979"></a>01979 <span class="keyword">public</span>:
<a name="l01983"></a>01983 
<a name="l01984"></a><a class="code" href="group__FP.html#ga60fbfc7c65a08eea4178f9f5170237cf">01984</a>   <a class="code" href="group__FP.html#ga60fbfc7c65a08eea4178f9f5170237cf" title="Default Constructor.">FPRelax</a>():
<a name="l01985"></a>01985     <a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a>( 0 ), <a class="code" href="classmc_1_1FPRelax.html#ae186ed32dfca710e221266751ac14b7f" title="Number of auxiliary variables in factorable program.">_naux</a>( 0 ) 
<a name="l01986"></a>01986     {}
<a name="l01987"></a>01987 
<a name="l01989"></a><a class="code" href="classmc_1_1FPRelax.html#a44071d637846f654bc5f65a7503e3a7f">01989</a>   <span class="keyword">virtual</span> <a class="code" href="classmc_1_1FPRelax.html#a44071d637846f654bc5f65a7503e3a7f" title="Destructor.">~FPRelax</a>()
<a name="l01990"></a>01990     { <a class="code" href="classmc_1_1FPRelax.html#a1d2adb7b0e3ca9b9a31fc1b53e760295" title="Clear the factorable program (all variables and operations)">reset</a>(); }
<a name="l01991"></a>01991 
<a name="l01993"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html">01993</a>   <span class="keyword">class </span><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">Exceptions</a>
<a name="l01994"></a>01994   {
<a name="l01995"></a>01995   <span class="keyword">public</span>:
<a name="l01997"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284">01997</a>     <span class="keyword">enum</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284" title="Enumeration type for exception handling.">TYPE</a>{
<a name="l01998"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284afbac358e613caff128304d4be781e620">01998</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284afbac358e613caff128304d4be781e620" title="Failure of Newton&#39;s method during the calculation of the convex or concave envelope of a univariate t...">NEWTON</a>=1,   
<a name="l01999"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03">01999</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">INTER</a>,   
<a name="l02000"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284af7a9ea93653936b7806bd2d6562b4df5">02000</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284af7a9ea93653936b7806bd2d6562b4df5" title="Error in constraint definition (e.g., number = number)">CONSTRAINT</a>, 
<a name="l02001"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ac0fdb32599f74a2c8857b664e63cf9c4">02001</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ac0fdb32599f74a2c8857b664e63cf9c4" title="Error in objective definition (e.g., minimize interval)">OBJECTIVE</a>,  
<a name="l02002"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a052b947740098582e0f00127c1be7401">02002</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a052b947740098582e0f00127c1be7401" title="Error during initialization with a variable of class mc::McCormick or mc::Taylor.">INIT</a>,    
<a name="l02003"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151">02003</a>       FP=-1,   
<a name="l02004"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a01eca89896a7a82ff58f63726b55afbf">02004</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a01eca89896a7a82ff58f63726b55afbf" title="Error due to calling a function/feature not yet implemented in MC++.">UNDEF</a>=-2,   
<a name="l02005"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a16924b8a3445bf87649086a3e17eaa06">02005</a>       <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a16924b8a3445bf87649086a3e17eaa06" title="Internal error.">INTERNAL</a>=-3 
<a name="l02006"></a>02006     };
<a name="l02008"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a89c1015690bcb8ab69602b123651def1">02008</a>     <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a89c1015690bcb8ab69602b123651def1" title="Constructor for error ierr">Exceptions</a>( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284" title="Enumeration type for exception handling.">TYPE</a> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#ab269df48b170c41a320dc8760de95649" title="Inline function returning the error flag.">ierr</a> ) : _ierr( ierr ){}
<a name="l02010"></a><a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#ab269df48b170c41a320dc8760de95649">02010</a>     <span class="keywordtype">int</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#ab269df48b170c41a320dc8760de95649" title="Inline function returning the error flag.">ierr</a>(){ <span class="keywordflow">return</span> _ierr; }
<a name="l02011"></a>02011 
<a name="l02012"></a>02012   <span class="keyword">private</span>:
<a name="l02013"></a>02013     <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284" title="Enumeration type for exception handling.">TYPE</a> _ierr;
<a name="l02014"></a>02014   };
<a name="l02015"></a>02015 
<a name="l02017"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html">02017</a>   <span class="keyword">struct </span><a class="code" href="structmc_1_1FPRelax_1_1Options.html" title="FPRelax options.">Options</a>
<a name="l02018"></a>02018   {
<a name="l02020"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a2c9c5ea21c1b89a9fb6ea45faab3b6a0">02020</a>     <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a2c9c5ea21c1b89a9fb6ea45faab3b6a0" title="Constructor.">Options</a>():
<a name="l02021"></a>02021       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#aa3c15e307e960f646235afbca6f05499" title="Flag to indicate whether Newton&#39;s method is to be used.">NEWTON_USE</a>(true), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ad5e9603f71ae2db3ad883daec69640cd" title="Maximal number of iterations in Newton&#39;s method.">NEWTON_MAXIT</a>(100), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#aa3d05eaa091862fa9dc88569c3bd5a25" title="Termination tolerance in Newton&#39;s method.">NEWTON_TOL</a>(1e-10),
<a name="l02022"></a>02022       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6d6b8daea2690c295e8ee3d1b7e914f0" title="Absolute tolerance in outer approximation of nonlinear convex/concave terms.">SANDWICH_ATOL</a>(1e-3), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#aebabc174679979a4fae2dca774a8da8e" title="Relative tolerance in outer approximation of nonlinear convex/concave terms.">SANDWICH_RTOL</a>(1e-3), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a09d099751ea11198fd7d84ca1fcabc56" title="Maximal number of cuts in outer approximation of nonlinear convex/concave terms.">SANDWICH_MAXCUT</a>(5),
<a name="l02023"></a>02023       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a3cf1a06ba31bd226c4ca7abac22c7f52" title="Rule for outer approximation of nonlinear convex/concave terms.">SANDWICH_RULE</a>(<a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62" title="Maximum error rule.">MAXERR</a>), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab2e5681dd0fe226f270ba666ad59469c" title="Absolute tolerance in (real) fractional terms to prevent division by zero.">FRACTIONAL_ATOL</a>(machprec()),
<a name="l02024"></a>02024       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6d58c158cf3f9fe021cd3b3dd3749d78" title="Relative tolerance in (real) fractional terms to prevent division by zero.">FRACTIONAL_RTOL</a>(machprec()), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a3cef008d4661968f2f36bea0f5449e83" title="Rule for relaxation of bilinear terms.">BILINEAR_RULE</a>(<a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76a54a2202f690db21dce49a3b14712bf03" title="Bisection along the first variable in bilinear term.">UNIVARIATE</a>),
<a name="l02025"></a>02025       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a947856cae5793bf10554a46d40ed7cbf" title="Subdivision for semi-linear relaxation of bilinear terms.">BILINEAR_SUBDIV</a>(1), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#acd132af9124cd40b88b5f5a0e577994a" title="Maximum order for RLT constraints.">RLT_MAXORDER</a>(4), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a43cc6a270accb98fd02e3e2df5589a0c" title="Option for RLT display.">RLT_DISPLAY</a>(0),
<a name="l02026"></a>02026       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6004e74d01ed2dffe3daf18966adc68b" title="Option for RRLT strategy.">RRLT_STRATEGY</a>(<a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544caffeb2bb1119a114a5b37da3b36810c32" title="RRLT with primary variables as operands only.">PRIMRRLT</a>), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#afe2ab2e39e0e951b3d46de24ee3fc712" title="Option for RRLT display.">RRLT_DISPLAY</a>(0), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a55a351361a914466f2dff04802c2d6ac" title="Feasibility tolerance of LP solver.">LP_FEASTOL</a>(1e-9),
<a name="l02027"></a>02027       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a92e73ad84dd0816deb0a84061b5a5654" title="Optimality tolerance of LP solver.">LP_OPTIMTOL</a>(1e-9), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a203be556089bffde61fac39cd4c73609" title="Relative optimality gap of MILP solver.">MILP_RELGAP</a>(0e0), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#af9a20c7d99db4f134382870d2f3b1564" title="Absolute optimality gap of MILP solver.">MILP_ABSGAP</a>(0e0),
<a name="l02028"></a>02028       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a51b6abc78bc0f06faa36993198ef3b30" title="Flag to indicate whether presolve is to be used by solver.">SOLVER_PRESOLVE</a>(true), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a76d6e95864938ee212d62d6352f5422d" title="Flag to indicate whether solver output is to be displayed.">SOLVER_DISPLAY</a>(false), <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ac5baa853e91121cf3debf25db4b168bb" title="Name of output file for optimization model.">SOLVER_OUTPUT_FILE</a>(<span class="stringliteral">&quot;&quot;</span>)
<a name="l02029"></a>02029       {}
<a name="l02031"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846">02031</a>     <span class="keyword">enum</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846" title="Enumeration type for sandwich strategy.">SANDWICH</a>{
<a name="l02032"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a7df2113bf9806331b80e4ef543153332">02032</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a7df2113bf9806331b80e4ef543153332" title="Interval bisection.">BISECT</a>=0,   
<a name="l02033"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62">02033</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62" title="Maximum error rule.">MAXERR</a>   
<a name="l02034"></a>02034     };
<a name="l02036"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544c">02036</a>     <span class="keyword">enum</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544c" title="Enumeration type for reduced (R)RLT strategy.">RRLT</a>{
<a name="l02037"></a>02037       <span class="comment">//NORRLT=0, //!&lt; No reduced RLT constraints</span>
<a name="l02038"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544caffeb2bb1119a114a5b37da3b36810c32">02038</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544caffeb2bb1119a114a5b37da3b36810c32" title="RRLT with primary variables as operands only.">PRIMRRLT</a>=0, 
<a name="l02039"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544ca02780cf42d2191976b6c28dcd941195d">02039</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544ca02780cf42d2191976b6c28dcd941195d" title="RRLT with primary and auxiliary variables as operands.">ALLRRLT</a>     
<a name="l02040"></a>02040     };
<a name="l02042"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76">02042</a>     <span class="keyword">enum</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76" title="Enumeration type for bilinear term relaxation strategy.">BILINEAR</a>{
<a name="l02043"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76a54a2202f690db21dce49a3b14712bf03">02043</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76a54a2202f690db21dce49a3b14712bf03" title="Bisection along the first variable in bilinear term.">UNIVARIATE</a>=0,  
<a name="l02044"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76af297b3a2ff67ac343c01acbe88a79117">02044</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76af297b3a2ff67ac343c01acbe88a79117" title="Reformulation as separable terms before relaxation w/o SOS.">SEPARABLE</a>,     
<a name="l02045"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76aa124bbb8337e47858ded7db99484db23">02045</a>       <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76aa124bbb8337e47858ded7db99484db23" title="Reformulation as separable terms before relaxation w/ SOS.">SEPARSOS</a>    
<a name="l02046"></a>02046     };
<a name="l02048"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#aa3c15e307e960f646235afbca6f05499">02048</a>     <span class="keywordtype">bool</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#aa3c15e307e960f646235afbca6f05499" title="Flag to indicate whether Newton&#39;s method is to be used.">NEWTON_USE</a>;
<a name="l02050"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#ad5e9603f71ae2db3ad883daec69640cd">02050</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ad5e9603f71ae2db3ad883daec69640cd" title="Maximal number of iterations in Newton&#39;s method.">NEWTON_MAXIT</a>;
<a name="l02052"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#aa3d05eaa091862fa9dc88569c3bd5a25">02052</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#aa3d05eaa091862fa9dc88569c3bd5a25" title="Termination tolerance in Newton&#39;s method.">NEWTON_TOL</a>;
<a name="l02054"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6d6b8daea2690c295e8ee3d1b7e914f0">02054</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6d6b8daea2690c295e8ee3d1b7e914f0" title="Absolute tolerance in outer approximation of nonlinear convex/concave terms.">SANDWICH_ATOL</a>;
<a name="l02056"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#aebabc174679979a4fae2dca774a8da8e">02056</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#aebabc174679979a4fae2dca774a8da8e" title="Relative tolerance in outer approximation of nonlinear convex/concave terms.">SANDWICH_RTOL</a>;
<a name="l02058"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a09d099751ea11198fd7d84ca1fcabc56">02058</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a09d099751ea11198fd7d84ca1fcabc56" title="Maximal number of cuts in outer approximation of nonlinear convex/concave terms.">SANDWICH_MAXCUT</a>;
<a name="l02060"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a3cf1a06ba31bd226c4ca7abac22c7f52">02060</a>     <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846" title="Enumeration type for sandwich strategy.">SANDWICH</a> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a3cf1a06ba31bd226c4ca7abac22c7f52" title="Rule for outer approximation of nonlinear convex/concave terms.">SANDWICH_RULE</a>;
<a name="l02062"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab2e5681dd0fe226f270ba666ad59469c">02062</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab2e5681dd0fe226f270ba666ad59469c" title="Absolute tolerance in (real) fractional terms to prevent division by zero.">FRACTIONAL_ATOL</a>;
<a name="l02064"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6d58c158cf3f9fe021cd3b3dd3749d78">02064</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6d58c158cf3f9fe021cd3b3dd3749d78" title="Relative tolerance in (real) fractional terms to prevent division by zero.">FRACTIONAL_RTOL</a>;
<a name="l02066"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a3cef008d4661968f2f36bea0f5449e83">02066</a>     <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76" title="Enumeration type for bilinear term relaxation strategy.">BILINEAR</a> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a3cef008d4661968f2f36bea0f5449e83" title="Rule for relaxation of bilinear terms.">BILINEAR_RULE</a>;
<a name="l02068"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a947856cae5793bf10554a46d40ed7cbf">02068</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a947856cae5793bf10554a46d40ed7cbf" title="Subdivision for semi-linear relaxation of bilinear terms.">BILINEAR_SUBDIV</a>;
<a name="l02070"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#acd132af9124cd40b88b5f5a0e577994a">02070</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#acd132af9124cd40b88b5f5a0e577994a" title="Maximum order for RLT constraints.">RLT_MAXORDER</a>;
<a name="l02072"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a43cc6a270accb98fd02e3e2df5589a0c">02072</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a43cc6a270accb98fd02e3e2df5589a0c" title="Option for RLT display.">RLT_DISPLAY</a>;
<a name="l02074"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6004e74d01ed2dffe3daf18966adc68b">02074</a>     <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544c" title="Enumeration type for reduced (R)RLT strategy.">RRLT</a> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a6004e74d01ed2dffe3daf18966adc68b" title="Option for RRLT strategy.">RRLT_STRATEGY</a>;
<a name="l02076"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#afe2ab2e39e0e951b3d46de24ee3fc712">02076</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#afe2ab2e39e0e951b3d46de24ee3fc712" title="Option for RRLT display.">RRLT_DISPLAY</a>;
<a name="l02078"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a55a351361a914466f2dff04802c2d6ac">02078</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a55a351361a914466f2dff04802c2d6ac" title="Feasibility tolerance of LP solver.">LP_FEASTOL</a>;
<a name="l02080"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a92e73ad84dd0816deb0a84061b5a5654">02080</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a92e73ad84dd0816deb0a84061b5a5654" title="Optimality tolerance of LP solver.">LP_OPTIMTOL</a>;
<a name="l02082"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a203be556089bffde61fac39cd4c73609">02082</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a203be556089bffde61fac39cd4c73609" title="Relative optimality gap of MILP solver.">MILP_RELGAP</a>;
<a name="l02084"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#af9a20c7d99db4f134382870d2f3b1564">02084</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#af9a20c7d99db4f134382870d2f3b1564" title="Absolute optimality gap of MILP solver.">MILP_ABSGAP</a>;
<a name="l02086"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a51b6abc78bc0f06faa36993198ef3b30">02086</a>     <span class="keywordtype">bool</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a51b6abc78bc0f06faa36993198ef3b30" title="Flag to indicate whether presolve is to be used by solver.">SOLVER_PRESOLVE</a>;
<a name="l02088"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#a76d6e95864938ee212d62d6352f5422d">02088</a>     <span class="keywordtype">bool</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a76d6e95864938ee212d62d6352f5422d" title="Flag to indicate whether solver output is to be displayed.">SOLVER_DISPLAY</a>;
<a name="l02090"></a><a class="code" href="structmc_1_1FPRelax_1_1Options.html#ac5baa853e91121cf3debf25db4b168bb">02090</a>     std::string <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ac5baa853e91121cf3debf25db4b168bb" title="Name of output file for optimization model.">SOLVER_OUTPUT_FILE</a>;
<a name="l02091"></a>02091   } options;
<a name="l02092"></a>02092   
<a name="l02094"></a><a class="code" href="classmc_1_1FPRelax.html#a53ffc46bc6af5203dd8c38366ac0270d">02094</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classmc_1_1FPRelax.html#a53ffc46bc6af5203dd8c38366ac0270d" title="Retreive number of original variables in factorable program.">nvar</a>()<span class="keyword"> const</span>
<a name="l02095"></a>02095 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a>; }
<a name="l02096"></a>02096   
<a name="l02098"></a><a class="code" href="classmc_1_1FPRelax.html#ad4a94102e230fda56c8e1ff34dd541c4">02098</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="classmc_1_1FPRelax.html#ad4a94102e230fda56c8e1ff34dd541c4" title="Retreive number of auxiliary variables in factorable program.">naux</a>()<span class="keyword"> const</span>
<a name="l02099"></a>02099 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPRelax.html#ae186ed32dfca710e221266751ac14b7f" title="Number of auxiliary variables in factorable program.">_naux</a>; }
<a name="l02100"></a>02100   
<a name="l02102"></a><a class="code" href="classmc_1_1FPRelax.html#a9252df46c1fa1dd8769d0c328e837fcc">02102</a>   <span class="keyword">const</span> t_Cuts&amp; <a class="code" href="classmc_1_1FPRelax.html#a9252df46c1fa1dd8769d0c328e837fcc" title="Retreive reference to set of cuts in factorable program relaxation.">Cuts</a>()<span class="keyword"> const</span>
<a name="l02103"></a>02103 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPRelax.html#a0c90754865d2a3ed01b99fb595c29140" title="Set of cuts in relaxed factorable program.">_Cuts</a>; }
<a name="l02104"></a>02104   
<a name="l02106"></a><a class="code" href="classmc_1_1FPRelax.html#a882aa002bb6bcb08b43337970f2c43d6">02106</a>   <span class="keyword">const</span> t_Vars&amp; <a class="code" href="classmc_1_1FPRelax.html#a882aa002bb6bcb08b43337970f2c43d6" title="Retreive reference to set of (all) variables in factorable program.">Vars</a>()<span class="keyword"> const</span>
<a name="l02107"></a>02107 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>; }
<a name="l02108"></a>02108 
<a name="l02110"></a><a class="code" href="classmc_1_1FPRelax.html#a1d2adb7b0e3ca9b9a31fc1b53e760295">02110</a>   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a1d2adb7b0e3ca9b9a31fc1b53e760295" title="Clear the factorable program (all variables and operations)">reset</a>()
<a name="l02111"></a>02111     { <a class="code" href="classmc_1_1FPRelax.html#a49cb376ec1138e08472d4462cae15c62" title="Erase all relaxation cuts in _Cuts.">_erase_cuts</a>(); <a class="code" href="classmc_1_1FPRelax.html#a3a7c166a88d2a6e054a4ef36cd85c039" title="Erase all variables in _Vars.">_erase_vars</a>(); <a class="code" href="classmc_1_1FPRelax.html#a499d7aec399fcdd30a36fc031cbafa63" title="Erase all operations in set _Ops">_erase_operations</a>(); <a class="code" href="classmc_1_1FPRelax.html#ae186ed32dfca710e221266751ac14b7f" title="Number of auxiliary variables in factorable program.">_naux</a>=<a class="code" href="classmc_1_1FPRelax.html#a74c9aa19d2058be3d52c93d97e1f1c40" title="Number of native variables in factorable program.">_nvar</a>=0; }
<a name="l02112"></a>02112 
<a name="l02114"></a><a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117">02114</a>   <span class="keyword">enum</span> <a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117" title="Enumeration for objective function type in factorable program.">OBJTYPE</a>{
<a name="l02115"></a><a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117aab40d1eb718b6f00196307aa0ee51f50">02115</a>     <a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117aab40d1eb718b6f00196307aa0ee51f50" title="Minimization.">MIN</a>=0,  
<a name="l02116"></a><a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117a94a0c06287113cc68b55650800199538">02116</a>     <a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117a94a0c06287113cc68b55650800199538" title="Maximization.">MAX</a>     
<a name="l02117"></a>02117   };
<a name="l02118"></a>02118 
<a name="l02120"></a>02120   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#acc5a0b6864118490094bb59c19e32d92" title="Set objective function in factorable program.">set_objective</a>
<a name="l02121"></a>02121     ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117" title="Enumeration for objective function type in factorable program.">FPRelax&lt;T&gt;::OBJTYPE</a> type, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;objVar );
<a name="l02122"></a>02122 
<a name="l02124"></a><a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8">02124</a>   <span class="keyword">enum</span> <a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8" title="Enumeration for constraint type in factorable program.">CTRTYPE</a>{
<a name="l02125"></a><a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8a86dc8b6991db2854d83afbf59dd67d8f">02125</a>     <a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8a86dc8b6991db2854d83afbf59dd67d8f" title="Equality constraint.">EQ</a>=0,   
<a name="l02126"></a><a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8a68e34a6686681ee74de8b04e2abf1198">02126</a>     <a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8a68e34a6686681ee74de8b04e2abf1198" title="Inequality constraint.">LE</a>,     
<a name="l02127"></a><a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8a4fe677254da7f58967da323e08a22dd5">02127</a>     <a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8a4fe677254da7f58967da323e08a22dd5" title="Inequality constraint.">GE</a>      
<a name="l02128"></a>02128   };
<a name="l02129"></a>02129 
<a name="l02131"></a>02131   <span class="keyword">virtual</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a73af7c422d8727ad932c385bdb4a15a7" title="Add constraint to factorable program.">add_constraint</a>
<a name="l02132"></a>02132     ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;lhsVar, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8" title="Enumeration for constraint type in factorable program.">FPRelax&lt;T&gt;::CTRTYPE</a> type,
<a name="l02133"></a>02133       <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;rhsVar );
<a name="l02135"></a>02135   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classmc_1_1FPRelax.html#afed6a4c2a8a06b555cfdbf1fda19c30d" title="Remove constraint from factorable program.">remove_constraint</a>
<a name="l02136"></a><a class="code" href="classmc_1_1FPRelax.html#afed6a4c2a8a06b555cfdbf1fda19c30d">02136</a>     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* constr )
<a name="l02137"></a>02137     { <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPRelax.html#a6bae03eeb3a84845c5d354fd8529e519" title="Erase operation op in set _Ops">_erase_operation</a>( constr ); }
<a name="l02138"></a>02138 
<a name="l02140"></a>02140   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a90277409a6e357ca8ff819a3f9201289" title="Generate polyhedral cuts for the objective and all constraints in the factorable program, after removing or not the existing cuts.">generate_cuts</a>
<a name="l02141"></a>02141     ( <span class="keywordtype">bool</span> <a class="code" href="classmc_1_1FPRelax.html#a1d2adb7b0e3ca9b9a31fc1b53e760295" title="Clear the factorable program (all variables and operations)">reset</a>=<span class="keyword">false</span> );
<a name="l02143"></a>02143   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a90277409a6e357ca8ff819a3f9201289" title="Generate polyhedral cuts for the objective and all constraints in the factorable program, after removing or not the existing cuts.">generate_cuts</a>
<a name="l02144"></a>02144     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*constr );
<a name="l02146"></a>02146   <span class="keywordtype">bool</span> <a class="code" href="classmc_1_1FPRelax.html#a0c33eee46c2ebb35921425f3ae8833d9" title="Propagate constraints in the factorable program to reduce variable range, for the constraint constr o...">propagate_constraints</a>
<a name="l02147"></a>02147     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*constr=0 );
<a name="l02149"></a>02149   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a1d4f8b79ad0d4a0b25d16d9ea0784c37" title="Generate reduction constraints via Liberti &amp; Pantelides&#39;s RRLT approach.">generate_reduction_constraints</a>();
<a name="l02151"></a>02151   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#ad98673c4b979d11cc26ef7f0ff989481" title="Generate tightening constraints via Sherali&#39;s RLT approach for variables participating in the Taylor ...">generate_RLT_TModel</a>
<a name="l02152"></a>02152     ( TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP );
<a name="l02153"></a>02153 
<a name="l02155"></a>02155   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; mc::TModel&lt; FPVar&lt;T&gt; &gt;* <a class="code" href="classmc_1_1FPRelax.html#a0979b2291106cf2fbd5447f8b6bee899" title="Build Taylor model environment mc::TModel&lt; FPVar&lt;U&gt; &gt; corresponding to environment mc::TModel&lt;U&gt; TM...">create_TModel</a>
<a name="l02156"></a>02156     ( <span class="keyword">const</span> mc::TModel&lt;U&gt;*TM, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub=0 );
<a name="l02158"></a>02158   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#abacbf0ab1918b92aa5520e5073fe05bc" title="Update Taylor model environment mc::TModel&lt; FPVar&lt;U&gt; &gt; corresponding to environment mc::TModel&lt;U&gt; TM...">update_TModel</a>
<a name="l02159"></a>02159     ( mc::TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;* TMFP, <span class="keyword">const</span> mc::TModel&lt;U&gt;*TM,
<a name="l02160"></a>02160       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub=0 );
<a name="l02163"></a>02163 <span class="keyword">protected</span>:
<a name="l02165"></a>02165   <span class="keywordtype">bool</span> <a class="code" href="classmc_1_1FPRelax.html#a6bae03eeb3a84845c5d354fd8529e519" title="Erase operation op in set _Ops">_erase_operation</a>
<a name="l02166"></a>02166     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* op );
<a name="l02168"></a><a class="code" href="classmc_1_1FPRelax.html#a499d7aec399fcdd30a36fc031cbafa63">02168</a>   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a499d7aec399fcdd30a36fc031cbafa63" title="Erase all operations in set _Ops">_erase_operations</a>()
<a name="l02169"></a>02169     { it_Ops ito = <a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.begin();
<a name="l02170"></a>02170       <span class="keywordflow">for</span>( ; ito != <a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.end(); ++ito ) <span class="keyword">delete</span> *ito;
<a name="l02171"></a>02171       <a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.clear(); }
<a name="l02173"></a><a class="code" href="classmc_1_1FPRelax.html#aa8707b89ea3781bb1670573bab143471">02173</a>   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#aa8707b89ea3781bb1670573bab143471" title="Reset all operations in set _Ops">_reset_operations</a>()
<a name="l02174"></a>02174     { it_Ops ito = <a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.begin();
<a name="l02175"></a>02175       <span class="keywordflow">for</span>( ; ito != <a class="code" href="classmc_1_1FPRelax.html#a357f703099f3e19d6bcc8f231c345eb5" title="Set of operations in factorable program.">_Ops</a>.end(); ++ito ) (*ito)-&gt;set( <span class="keyword">false</span> ); }
<a name="l02177"></a>02177   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*<a class="code" href="classmc_1_1FPRelax.html#ab8c7126d3f23ec946da0fb687449e954" title="Looks for the operation of type op with left and right operands lop, rop in set _Ops and adds it if n...">_operation</a>
<a name="l02178"></a>02178     ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> op, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*lop, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*rop=0 );
<a name="l02179"></a>02179 
<a name="l02181"></a>02181   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#ac20884ec2b7a4d2bd7dc2acc4e7fe822" title="Adds the auxiliary continuous variable with bounds X from operation pOp">_auxiliary_variable</a>
<a name="l02182"></a>02182     ( <span class="keyword">const</span> T&amp;X, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*pOp );
<a name="l02184"></a>02184   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#ac20884ec2b7a4d2bd7dc2acc4e7fe822" title="Adds the auxiliary continuous variable with bounds X from operation pOp">_auxiliary_variable</a>
<a name="l02185"></a>02185     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*pOp );
<a name="l02187"></a>02187   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3" title="Looks for the real auxiliary constant x and adds it if not found.">_auxiliary_constant</a>
<a name="l02188"></a>02188     ( <span class="keyword">const</span> <span class="keywordtype">double</span> x );
<a name="l02190"></a>02190   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3" title="Looks for the real auxiliary constant x and adds it if not found.">_auxiliary_constant</a>
<a name="l02191"></a>02191     ( <span class="keyword">const</span> <span class="keywordtype">int</span> n );
<a name="l02193"></a>02193   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3" title="Looks for the real auxiliary constant x and adds it if not found.">_auxiliary_constant</a>
<a name="l02194"></a>02194     ( <span class="keyword">const</span> T&amp;I );
<a name="l02195"></a>02195 
<a name="l02197"></a><a class="code" href="classmc_1_1FPRelax.html#a3a7c166a88d2a6e054a4ef36cd85c039">02197</a>   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a3a7c166a88d2a6e054a4ef36cd85c039" title="Erase all variables in _Vars.">_erase_vars</a>()
<a name="l02198"></a>02198     { it_Vars itv = <a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.begin();
<a name="l02199"></a>02199       <span class="keywordflow">for</span>( ; itv != <a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.end(); ++itv ) <span class="keyword">delete</span> *itv;
<a name="l02200"></a>02200       <a class="code" href="classmc_1_1FPRelax.html#aa0841db81ad0e5d4284a4c794247d5ec" title="Set of variables in factorable program.">_Vars</a>.clear(); }
<a name="l02202"></a>02202   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a35e7be64f140a34982162ffad129c659" title="Appends the auxiliary variable pAux and define it in _Ops with type tOp">_append_aux</a>
<a name="l02203"></a>02203     ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pAux, <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> tOp );
<a name="l02205"></a>02205   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a35e7be64f140a34982162ffad129c659" title="Appends the auxiliary variable pAux and define it in _Ops with type tOp">_append_aux</a>
<a name="l02206"></a>02206     ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pAux );
<a name="l02208"></a>02208   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#ae869e37c863d88ea9bc2b7074fa03672" title="Appends new original variable.">_append_var</a>
<a name="l02209"></a>02209     ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pVar );
<a name="l02211"></a>02211   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a57f5a651122a5e0bb7f1094564766fbd" title="Update the bounds of the variable Var as Bnd">_update_var</a>
<a name="l02212"></a><a class="code" href="classmc_1_1FPRelax.html#a57f5a651122a5e0bb7f1094564766fbd">02212</a>     ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pVar, <span class="keyword">const</span> T&amp;Bnd )
<a name="l02213"></a>02213     { pVar-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() = Bnd; }
<a name="l02215"></a>02215   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#aeb076bff44dd597ef45b7ed609d2e095" title="Search for the variable with identify id in _Vars">_find_var</a>
<a name="l02216"></a>02216     ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>&amp;<span class="keywordtype">id</span> );
<a name="l02217"></a>02217 
<a name="l02219"></a><a class="code" href="classmc_1_1FPRelax.html#a49cb376ec1138e08472d4462cae15c62">02219</a>   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a49cb376ec1138e08472d4462cae15c62" title="Erase all relaxation cuts in _Cuts.">_erase_cuts</a>()
<a name="l02220"></a>02220     { it_Cuts itc = <a class="code" href="classmc_1_1FPRelax.html#a0c90754865d2a3ed01b99fb595c29140" title="Set of cuts in relaxed factorable program.">_Cuts</a>.begin();
<a name="l02221"></a>02221       <span class="keywordflow">for</span>( ; itc != <a class="code" href="classmc_1_1FPRelax.html#a0c90754865d2a3ed01b99fb595c29140" title="Set of cuts in relaxed factorable program.">_Cuts</a>.end(); ++itc ) <span class="keyword">delete</span> *itc;
<a name="l02222"></a>02222       <a class="code" href="classmc_1_1FPRelax.html#a0c90754865d2a3ed01b99fb595c29140" title="Set of cuts in relaxed factorable program.">_Cuts</a>.clear(); }
<a name="l02224"></a>02224   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a49cb376ec1138e08472d4462cae15c62" title="Erase all relaxation cuts in _Cuts.">_erase_cuts</a>
<a name="l02225"></a>02225     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* op );
<a name="l02227"></a>02227   <span class="keyword">virtual</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>
<a name="l02228"></a>02228     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l02229"></a>02229       <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1,
<a name="l02230"></a>02230       <span class="keyword">const</span> <span class="keywordtype">double</span> a1 );
<a name="l02232"></a>02232   <span class="keyword">virtual</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>
<a name="l02233"></a>02233     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l02234"></a>02234       <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1,
<a name="l02235"></a>02235       <span class="keyword">const</span> <span class="keywordtype">double</span> a1, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id2,
<a name="l02236"></a>02236       <span class="keyword">const</span> <span class="keywordtype">double</span> a2 );
<a name="l02238"></a>02238   <span class="keyword">virtual</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>
<a name="l02239"></a>02239     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l02240"></a>02240       <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1,
<a name="l02241"></a>02241       <span class="keyword">const</span> <span class="keywordtype">double</span> a1, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id2,
<a name="l02242"></a>02242       <span class="keyword">const</span> <span class="keywordtype">double</span> a2, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id3,
<a name="l02243"></a>02243       <span class="keyword">const</span> <span class="keywordtype">double</span> a3 );
<a name="l02245"></a>02245   <span class="keyword">virtual</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>
<a name="l02246"></a>02246     ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l02247"></a>02247       <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,
<a name="l02248"></a>02248       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>* <span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">double</span>*a );
<a name="l02249"></a>02249 
<a name="l02251"></a>02251   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#a9ae269849d0f026ddafc47e67a3e45bc" title="Lift RLT constraints in RLT_lst by 1 order for variables participating in the Taylor model TMFP...">_lift_RLT_TModel</a>
<a name="l02252"></a>02252     ( TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP, std::list&lt; <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* &gt;&amp; RLT_lst,
<a name="l02253"></a>02253       <span class="keyword">const</span> <span class="keywordtype">bool</span> disp );
<a name="l02255"></a>02255   <span class="keywordtype">void</span> <a class="code" href="classmc_1_1FPRelax.html#ad0cf327139aa537cc915a1befc0646d6" title="Append cuts for RLT constraints in RLT_lst">_append_cuts_RLT_TModel</a>
<a name="l02256"></a>02256     ( std::list&lt; <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* &gt;&amp; RLT_lst, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nord );
<a name="l02257"></a>02257 };
<a name="l02258"></a>02258 
<a name="l02259"></a>02259 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>lt_RLTVar;
<a name="l02260"></a>02260 
<a name="l02266"></a>02266 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l02267"></a><a class="code" href="classmc_1_1FPRRLT.html">02267</a> <span class="keyword">class </span><a class="code" href="classmc_1_1FPRRLT.html" title="C++ template class for reduced RLT constraint generation.">FPRRLT</a>
<a name="l02268"></a>02268 {
<a name="l02269"></a>02269 <span class="keyword">public</span>:
<a name="l02270"></a>02270 
<a name="l02271"></a>02271   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> pt_idVar;
<a name="l02272"></a>02272   <span class="keyword">typedef</span> std::pair&lt; FPOp&lt;T&gt;*, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &gt; pt_Op;
<a name="l02273"></a>02273 
<a name="l02274"></a>02274   <span class="keyword">typedef</span> std::set&lt; FPVar&lt;T&gt;*, <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a> &gt; t_Vars;
<a name="l02275"></a>02275   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars::iterator it_Vars;
<a name="l02276"></a>02276   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars::const_iterator cit_Vars;
<a name="l02277"></a>02277 
<a name="l02278"></a>02278   <span class="keyword">typedef</span> std::set&lt; FPOp&lt;T&gt;*,  <a class="code" href="structmc_1_1lt__FPOp.html" title="C++ structure for comparing operations in a factorable program.">lt_FPOp&lt;T&gt;</a> &gt; t_Ops;
<a name="l02279"></a>02279   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Ops::iterator  it_Ops;
<a name="l02280"></a>02280   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Ops::const_iterator  cit_Ops;
<a name="l02281"></a>02281 
<a name="l02282"></a>02282   <span class="keyword">typedef</span> std::multimap&lt; const FPVar&lt;T&gt;*, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*, <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a> &gt; t_Vars_Ops;
<a name="l02283"></a>02283   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars_Ops::iterator it_Vars_Ops;
<a name="l02284"></a>02284   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_Vars_Ops::const_iterator cit_Vars_Ops;
<a name="l02285"></a>02285 
<a name="l02286"></a>02286   <span class="keyword">typedef</span> std::pair&lt; FPVar&lt;T&gt;*, <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> &gt; t_RLTVar;
<a name="l02287"></a>02287   <span class="keyword">typedef</span> std::multimap&lt; const t_RLTVar, FPOp&lt;T&gt;*, <a class="code" href="structmc_1_1lt__RLTVar.html" title="C++ structure for comparing variables in a factorable program.">lt_RLTVar&lt;T&gt;</a> &gt; t_RLTMap;
<a name="l02288"></a>02288   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_RLTMap::iterator it_RLTMap;
<a name="l02289"></a>02289   <span class="keyword">typedef</span> <span class="keyword">typename</span> t_RLTMap::const_iterator cit_RLTMap;
<a name="l02290"></a>02290   
<a name="l02291"></a>02291 <span class="keyword">private</span>:
<a name="l02293"></a>02293   <span class="keyword">const</span> t_Vars&amp; _Vars;
<a name="l02295"></a>02295   <span class="keyword">const</span> t_Ops&amp; _Ops;
<a name="l02296"></a>02296 
<a name="l02298"></a>02298   t_Ops _linTerms;
<a name="l02300"></a>02300   t_Vars _linVars;
<a name="l02302"></a>02302   t_Vars_Ops _linEdges;
<a name="l02304"></a>02304   t_Vars _RLTVars;
<a name="l02306"></a>02306   t_Vars_Ops _RLTEdges;
<a name="l02307"></a>02307 
<a name="l02309"></a>02309   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _nRLTVars;
<a name="l02311"></a>02311   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _nlinTerms;
<a name="l02312"></a>02312 
<a name="l02313"></a>02313   <span class="comment">// subsets of bilinear terms</span>
<a name="l02314"></a>02314   t_Ops _bilTerms;
<a name="l02315"></a>02315   <span class="comment">// subsets of fractional terms</span>
<a name="l02316"></a>02316   t_Ops _divTerms;
<a name="l02317"></a>02317   <span class="comment">// subsets of square terms</span>
<a name="l02318"></a>02318   t_Ops _sqrTerms;
<a name="l02319"></a>02319   <span class="comment">// subsets of square root terms</span>
<a name="l02320"></a>02320   t_Ops _sqrtTerms;
<a name="l02321"></a>02321 
<a name="l02323"></a>02323   t_RLTMap _RLTMap;
<a name="l02324"></a>02324 
<a name="l02326"></a>02326   pt_Op* _VarAssigned;
<a name="l02328"></a>02328   <span class="keywordtype">bool</span>* _VarVisited;
<a name="l02330"></a>02330   <span class="keywordtype">bool</span>* _TermVisited;  
<a name="l02331"></a>02331   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _display;
<a name="l02332"></a>02332 
<a name="l02333"></a>02333 <span class="keyword">public</span>:
<a name="l02334"></a>02334   
<a name="l02336"></a>02336   <a class="code" href="classmc_1_1FPRRLT.html#addad91accbf9175a80e8b29c8b203cfd" title="Default Constructor.">FPRRLT</a>
<a name="l02337"></a><a class="code" href="classmc_1_1FPRRLT.html#addad91accbf9175a80e8b29c8b203cfd">02337</a>     ( <span class="keyword">const</span> t_Vars&amp; Vars, <span class="keyword">const</span> t_Ops&amp; Ops ):
<a name="l02338"></a>02338     _Vars( Vars ), _Ops( Ops ), _nRLTVars( 0 ), _nlinTerms( 0 ),
<a name="l02339"></a>02339     _VarAssigned( 0 ), _VarVisited(0), _TermVisited(0)
<a name="l02340"></a>02340     {}
<a name="l02341"></a>02341 
<a name="l02343"></a><a class="code" href="classmc_1_1FPRRLT.html#ab0ca82a5bbd4ddb825d3c87a1cc281be">02343</a>   <a class="code" href="classmc_1_1FPRRLT.html#ab0ca82a5bbd4ddb825d3c87a1cc281be" title="Destructor.">~FPRRLT</a>()
<a name="l02344"></a>02344     { <span class="keyword">delete</span>[] _VarAssigned; <span class="keyword">delete</span>[] _VarVisited; <span class="keyword">delete</span>[] _TermVisited; }
<a name="l02345"></a>02345 
<a name="l02347"></a>02347   t_RLTMap&amp; <a class="code" href="classmc_1_1FPRRLT.html#ae1ec5dd75c2239386de2e1398612ea2e" title="Identify valid reduction constraints with the possible candidate multiplier variables.">map_RLT</a>
<a name="l02348"></a>02348     ( <span class="keyword">typename</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544c" title="Enumeration type for reduced (R)RLT strategy.">FPRelax&lt;T&gt;::Options::RRLT</a> option, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> display );
<a name="l02349"></a>02349 
<a name="l02350"></a>02350 <span class="keyword">private</span>:
<a name="l02352"></a>02352   <span class="keywordtype">void</span> _define_linear();
<a name="l02354"></a>02354   <span class="keywordtype">void</span> _define_bilinear();
<a name="l02356"></a>02356   <span class="keywordtype">void</span> _bigraph_RLT
<a name="l02357"></a>02357     ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>&amp; idMult, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a>&amp; idOp );
<a name="l02359"></a>02359   <span class="keywordtype">void</span> _bigraph_RLT_mult
<a name="l02360"></a>02360     ( <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars &amp;linVars, <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars_Ops &amp;linEdges,
<a name="l02361"></a>02361       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>&amp; idMult );
<a name="l02363"></a>02363   <span class="keywordtype">void</span> _bigraph_RLT_div
<a name="l02364"></a>02364     ( <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars &amp;linVars, <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars_Ops &amp;linEdges,
<a name="l02365"></a>02365       <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>&amp; idDiv );
<a name="l02367"></a>02367   <span class="keywordtype">void</span> _reduction_RLT
<a name="l02368"></a>02368     ( <span class="keyword">const</span> t_RLTVar&amp; VarRed );
<a name="l02370"></a>02370   <span class="keywordtype">bool</span> _augpath_RLT
<a name="l02371"></a>02371     ( <span class="keyword">const</span> pt_Op&amp; pOp );
<a name="l02372"></a>02372 
<a name="l02373"></a>02373 <span class="keyword">public</span>:
<a name="l02375"></a>02375   t_Ops <a class="code" href="classmc_1_1FPRRLT.html#ada6dd0a2375b697c9ddccf47e0ee0300" title="Create subset of operations of given type.">subset_op</a>
<a name="l02376"></a>02376     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nOp, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a>*typeOp ) <span class="keyword">const</span>;
<a name="l02378"></a>02378   t_Ops <a class="code" href="classmc_1_1FPRRLT.html#ada6dd0a2375b697c9ddccf47e0ee0300" title="Create subset of operations of given type.">subset_op</a>
<a name="l02379"></a>02379     ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a>&amp;typeOp ) <span class="keyword">const</span>;
<a name="l02381"></a>02381   <span class="keyword">static</span> t_Vars <a class="code" href="classmc_1_1FPRRLT.html#adb37ba95851d28331ab76cefcad398be" title="Create subset of variables participating in operations Ops.">subset_var</a>
<a name="l02382"></a>02382     ( <span class="keyword">const</span> t_Ops&amp; Ops );
<a name="l02384"></a>02384   <span class="keyword">static</span> t_Vars_Ops <a class="code" href="classmc_1_1FPRRLT.html#aa148ee92664872e0f81a39ceac8067cf" title="Create subset of variables participating in operations Ops and corresponding edges.">submap_var</a>
<a name="l02385"></a>02385     ( <span class="keyword">const</span> t_Ops&amp; Ops );
<a name="l02386"></a>02386 };
<a name="l02387"></a>02387 
<a name="l02393"></a>02393 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l02394"></a><a class="code" href="structmc_1_1lt__RLTVar.html">02394</a> <span class="keyword">struct </span><a class="code" href="structmc_1_1lt__RLTVar.html" title="C++ structure for comparing variables in a factorable program.">lt_RLTVar</a>
<a name="l02396"></a>02396 {
<a name="l02397"></a>02397   <span class="keywordtype">bool</span> <span class="keyword">operator</span>()
<a name="l02398"></a>02398     ( <span class="keyword">const</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_RLTVar&amp; Var1,
<a name="l02399"></a>02399       <span class="keyword">const</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_RLTVar&amp; Var2 )<span class="keyword"> const</span>
<a name="l02400"></a>02400 <span class="keyword">    </span>{
<a name="l02401"></a>02401       <span class="comment">// Order RLT variables w.r.t. their RLT operation types first</span>
<a name="l02402"></a>02402       <span class="keywordflow">if</span>( Var1.second &lt; Var2.second ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02403"></a>02403       <span class="keywordflow">if</span>( Var1.second &gt; Var2.second ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02404"></a>02404       <span class="comment">// Order RLT variables w.r.t. to their index next</span>
<a name="l02405"></a>02405       <span class="keywordflow">return</span> <a class="code" href="structmc_1_1lt__FPVar.html" title="C++ structure for comparing variables in a factorable program.">lt_FPVar&lt;T&gt;</a>()( Var1.first, Var2.first );
<a name="l02406"></a>02406     }
<a name="l02407"></a>02407 };
<a name="l02408"></a>02408 
<a name="l02410"></a>02410 
<a name="l02411"></a>02411 <span class="keyword">inline</span> std::ostream&amp;
<a name="l02412"></a>02412 <span class="keyword">operator</span> &lt;&lt;
<a name="l02413"></a>02413 ( std::ostream&amp;out, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPOuter.html" title="C++ structure for storing subintervals in an outer approximation.">FPOuter</a>&amp;Int )
<a name="l02414"></a>02414 {
<a name="l02415"></a>02415   <span class="keyword">const</span> <span class="keywordtype">int</span> iprec = 5;
<a name="l02416"></a>02416   out &lt;&lt; std::right &lt;&lt; std::scientific &lt;&lt; std::setprecision(iprec)
<a name="l02417"></a>02417       &lt;&lt; <span class="stringliteral">&quot;Bounds: [ &quot;</span> &lt;&lt; std::setw(iprec+7) &lt;&lt; Int.xL() &lt;&lt; <span class="stringliteral">&quot; : &quot;</span>
<a name="l02418"></a>02418       &lt;&lt; std::setw(iprec+7) &lt;&lt; Int.xU() &lt;&lt; <span class="stringliteral">&quot;]    OA Point: &quot;</span>
<a name="l02419"></a>02419       &lt;&lt; std::setw(iprec+7) &lt;&lt; Int.xM() &lt;&lt; <span class="stringliteral">&quot;    OA Gap: &quot;</span>
<a name="l02420"></a>02420       &lt;&lt; std::setw(iprec+7) &lt;&lt; Int.gap();
<a name="l02421"></a>02421   <span class="keywordflow">return</span> out;
<a name="l02422"></a>02422 }
<a name="l02423"></a>02423 
<a name="l02425"></a>02425 
<a name="l02426"></a>02426 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::ostream&amp;
<a name="l02427"></a>02427 <span class="keyword">operator</span> &lt;&lt;
<a name="l02428"></a>02428 ( std::ostream&amp;out, <span class="keyword">const</span> FPCut&lt;T&gt;&amp;Cut )
<a name="l02429"></a>02429 {
<a name="l02430"></a>02430   <span class="keyword">const</span> <span class="keywordtype">int</span> iprec = 5;
<a name="l02431"></a>02431   out &lt;&lt; std::right &lt;&lt; std::scientific &lt;&lt; std::setprecision(iprec);
<a name="l02432"></a>02432   
<a name="l02433"></a>02433   <span class="keywordflow">switch</span>( Cut._type ){
<a name="l02434"></a>02434     <span class="keywordflow">case</span> FPCut&lt;T&gt;::EQ: <span class="keywordflow">case</span> FPCut&lt;T&gt;::LE: <span class="keywordflow">case</span> FPCut&lt;T&gt;::GE:
<a name="l02435"></a>02435       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;Cut.nvar(); k++ ){
<a name="l02436"></a>02436         <span class="keywordflow">if</span>( isequal( Cut._coef[k], 0. ) )
<a name="l02437"></a>02437           out &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::setw(iprec+6) &lt;&lt; 0.;
<a name="l02438"></a>02438         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Cut._coef[k] &gt; 0. )
<a name="l02439"></a>02439           out &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::setw(iprec+6) &lt;&lt; Cut._coef[k];
<a name="l02440"></a>02440         <span class="keywordflow">else</span>
<a name="l02441"></a>02441           out &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; std::setw(iprec+6) &lt;&lt; -Cut._coef[k];
<a name="l02442"></a>02442         out &lt;&lt; FPVar&lt;T&gt;::_name( Cut._idvar[k] );  
<a name="l02443"></a>02443       }
<a name="l02444"></a>02444       <span class="keywordflow">break</span>;
<a name="l02445"></a>02445 
<a name="l02446"></a>02446     <span class="keywordflow">case</span> FPCut&lt;T&gt;::SOS1: <span class="keywordflow">case</span> FPCut&lt;T&gt;::SOS2:
<a name="l02447"></a>02447       out &lt;&lt; <span class="stringliteral">&quot; {&quot;</span>;
<a name="l02448"></a>02448       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k&lt;Cut.nvar(); k++ )
<a name="l02449"></a>02449         out &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Cut._idvar[k] );
<a name="l02450"></a>02450       out &lt;&lt; <span class="stringliteral">&quot; }&quot;</span>;
<a name="l02451"></a>02451   }
<a name="l02452"></a>02452   
<a name="l02453"></a>02453   <span class="keywordflow">switch</span>( Cut._type ){
<a name="l02454"></a>02454     <span class="keywordflow">case</span> FPCut&lt;T&gt;::EQ: out &lt;&lt; <span class="stringliteral">&quot; = &quot;</span>; <span class="keywordflow">break</span>;
<a name="l02455"></a>02455     <span class="keywordflow">case</span> FPCut&lt;T&gt;::LE: out &lt;&lt; <span class="stringliteral">&quot; &lt;= &quot;</span>; <span class="keywordflow">break</span>;
<a name="l02456"></a>02456     <span class="keywordflow">case</span> FPCut&lt;T&gt;::GE: out &lt;&lt; <span class="stringliteral">&quot; &gt;= &quot;</span>; <span class="keywordflow">break</span>;
<a name="l02457"></a>02457     <span class="keywordflow">case</span> FPCut&lt;T&gt;::SOS1: out &lt;&lt; <span class="stringliteral">&quot; SOS1&quot;</span>; <span class="keywordflow">return</span> out;
<a name="l02458"></a>02458     <span class="keywordflow">case</span> FPCut&lt;T&gt;::SOS2: out &lt;&lt; <span class="stringliteral">&quot; SOS2&quot;</span>; <span class="keywordflow">return</span> out;
<a name="l02459"></a>02459   }
<a name="l02460"></a>02460   
<a name="l02461"></a>02461   out &lt;&lt; std::setw(iprec+6) &lt;&lt; Cut._rhs;
<a name="l02462"></a>02462   <span class="keywordflow">return</span> out;
<a name="l02463"></a>02463 }
<a name="l02464"></a>02464 
<a name="l02466"></a>02466 
<a name="l02467"></a>02467 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::ostream&amp;
<a name="l02468"></a>02468 <span class="keyword">operator</span> &lt;&lt;
<a name="l02469"></a>02469 ( std::ostream&amp;out, <span class="keyword">const</span> FPVarNum&lt;T&gt;&amp;VarNum )
<a name="l02470"></a>02470 {
<a name="l02471"></a>02471   <span class="keywordflow">switch</span>( VarNum.t ){
<a name="l02472"></a>02472     <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l02473"></a>02473       out &lt;&lt; <span class="stringliteral">&quot;(I) &quot;</span> &lt;&lt; VarNum.n ; <span class="keywordflow">break</span>;
<a name="l02474"></a>02474     <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l02475"></a>02475       out &lt;&lt; <span class="stringliteral">&quot;(D) &quot;</span> &lt;&lt; VarNum.x; <span class="keywordflow">break</span>;
<a name="l02476"></a>02476     <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l02477"></a>02477       out &lt;&lt; VarNum.I; <span class="keywordflow">break</span>;
<a name="l02478"></a>02478   }
<a name="l02479"></a>02479   <span class="keywordflow">return</span> out;
<a name="l02480"></a>02480 }
<a name="l02481"></a>02481 
<a name="l02482"></a>02482 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::ostream&amp;
<a name="l02483"></a>02483 <span class="keyword">operator</span> &lt;&lt;
<a name="l02484"></a>02484 ( std::ostream&amp;out, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var)
<a name="l02485"></a>02485 {
<a name="l02486"></a>02486   <span class="comment">//std::ostringstream num; num &lt;&lt; Var._num;</span>
<a name="l02487"></a>02487   <span class="comment">//out &lt;&lt; Var.name() &lt;&lt; &quot; &lt;= &quot; &lt;&lt; std::left &lt;&lt; std::setw(40) &lt;&lt; num.str();</span>
<a name="l02488"></a>02488   <span class="comment">// // &lt;&lt; &quot;\t(&quot; &lt;&lt; Var._FP &lt;&lt; &quot;)&quot;;</span>
<a name="l02489"></a>02489   <span class="comment">//return out;</span>
<a name="l02490"></a>02490 
<a name="l02491"></a>02491   out &lt;&lt; Var.<a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90" title="Get variable name.">name</a>()
<a name="l02492"></a>02492       &lt;&lt; <span class="stringliteral">&quot; &lt;= &quot;</span> &lt;&lt; std::left &lt;&lt; Var._num;<span class="comment">// &lt;&lt; &quot;\t(&quot; &lt;&lt; Var._FP &lt;&lt; &quot;)&quot;;</span>
<a name="l02493"></a>02493   <span class="keywordflow">return</span> out;
<a name="l02494"></a>02494 }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> 
<a name="l02497"></a>02497 FPVar&lt;T&gt;::FPVar
<a name="l02498"></a>02498 ( FPRelax&lt;T&gt;*FP, <span class="keyword">const</span> McCormick&lt;T&gt;&amp;MCX, <span class="keyword">const</span> <span class="keywordtype">double</span>*pref,
<a name="l02499"></a>02499   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub )
<a name="l02500"></a>02500 : _id( AUXCONT, FP-&gt;_naux++ ), _num( MCX.I() ), _FP( FP ), _Op(0)
<a name="l02501"></a>02501 {
<a name="l02502"></a>02502   <span class="comment">// Insert new auxiliary in _Vars and corresponding operation in _Ops</span>
<a name="l02503"></a>02503   FPVar&lt;T&gt;* pAux = <span class="keyword">new</span> FPVar&lt;T&gt;( *this );
<a name="l02504"></a>02504   _Op = <span class="keyword">new</span> FPOp&lt;T&gt;( FPOp&lt;T&gt;::MC, 0, 0, pAux );
<a name="l02505"></a>02505   <span class="comment">//_Op-&gt;attach( MCX );</span>
<a name="l02506"></a>02506   pAux-&gt;_Op = _Op;
<a name="l02507"></a>02507   FP-&gt;_Ops.insert( _Op );
<a name="l02508"></a>02508   FP-&gt;_append_aux( pAux );
<a name="l02509"></a>02509 
<a name="l02510"></a>02510   <span class="comment">// Build up polyhedral relaxation</span>
<a name="l02511"></a>02511   <span class="keywordflow">if</span>( !pref || !MCX.nsub() ) <span class="keywordflow">return</span>;
<a name="l02512"></a>02512   FPVar&lt;T&gt; LAff = MCX.cv();
<a name="l02513"></a>02513   FPVar&lt;T&gt; UAff = MCX.cc();
<a name="l02514"></a>02514   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;MCX.nsub(); ip++ ){
<a name="l02515"></a>02515     FPVar&lt;T&gt;*pVar = FP-&gt;_find_var( pt_idVar( VARCONT, isub?isub[ip]:ip ) );
<a name="l02516"></a>02516     <span class="keywordflow">if</span>( !pVar ) pVar = FP-&gt;_find_var( pt_idVar( VARBIN, isub?isub[ip]:ip ) );
<a name="l02517"></a>02517     <span class="comment">// Throw exception if variable ix+ioff is undefined</span>
<a name="l02518"></a>02518     <span class="keywordflow">if</span>( !pVar ) <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a052b947740098582e0f00127c1be7401" title="Error during initialization with a variable of class mc::McCormick or mc::Taylor.">FPRelax&lt;T&gt;::Exceptions::INIT</a> );
<a name="l02519"></a>02519     LAff += MCX.cvsub(ip) * ( *pVar - pref[ip] );
<a name="l02520"></a>02520     UAff += MCX.ccsub(ip) * ( *pVar - pref[ip] );
<a name="l02521"></a>02521   }
<a name="l02522"></a>02522   FP-&gt;add_constraint( *pAux, FPRelax&lt;T&gt;::GE, LAff );
<a name="l02523"></a>02523   FP-&gt;add_constraint( *pAux, FPRelax&lt;T&gt;::LE, UAff );
<a name="l02524"></a>02524 }
<a name="l02525"></a>02525 
<a name="l02526"></a>02526 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> 
<a name="l02527"></a>02527 FPVar&lt;T&gt;::FPVar
<a name="l02528"></a>02528 ( FPRelax&lt;T&gt;*FP, <span class="keyword">const</span> TVar&lt;T&gt;&amp;TVX, TModel&lt; FPVar&lt;T&gt; &gt;*TMFP )
<a name="l02529"></a>02529 : _id( AUXCONT, FP-&gt;_naux++ ), _num( TVX.B() ), _FP( FP ), _Op(0)
<a name="l02530"></a>02530 {
<a name="l02531"></a>02531   <span class="comment">// Insert new auxiliary in _Vars and corresponding operation in _Ops</span>
<a name="l02532"></a>02532   FPVar&lt;T&gt;* pAux = <span class="keyword">new</span> FPVar&lt;T&gt;( *this );
<a name="l02533"></a>02533   _Op = <span class="keyword">new</span> FPOp&lt;T&gt;( FPOp&lt;T&gt;::TM, 0, 0, pAux );
<a name="l02534"></a>02534   <span class="comment">//_Op-&gt;attach( TVX, TMFP );</span>
<a name="l02535"></a>02535   pAux-&gt;_Op = _Op;
<a name="l02536"></a>02536   FP-&gt;_Ops.insert( _Op );
<a name="l02537"></a>02537   FP-&gt;_append_aux( pAux );
<a name="l02538"></a>02538 
<a name="l02539"></a>02539   <span class="comment">// Build up polyhedral relaxation</span>
<a name="l02540"></a>02540   <span class="keyword">typedef</span> mc::TVar&lt; FPVar&lt;T&gt; &gt; TVFP;
<a name="l02541"></a>02541   TVFP TPFPX( TMFP, TVX );
<a name="l02542"></a>02542   FP-&gt;add_constraint( *pAux, FPRelax&lt;T&gt;::EQ, TPFPX.B() );
<a name="l02543"></a>02543 }
<a name="l02544"></a>02544 
<a name="l02545"></a>02545 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> 
<a name="l02546"></a>02546 FPVar&lt;T&gt;::FPVar
<a name="l02547"></a>02547 ( FPRelax&lt;T&gt;*FP, <span class="keyword">const</span> TVar&lt; McCormick&lt;T&gt; &gt;&amp;TVMCX, TModel&lt; FPVar&lt;T&gt; &gt;*TMFP,
<a name="l02548"></a>02548   <span class="keyword">const</span> <span class="keywordtype">double</span>*MCXref, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub )
<a name="l02549"></a>02549 : _id( AUXCONT, FP-&gt;_naux++ ), _num( TVMCX.B().I() ), _FP( FP ), _Op(0)
<a name="l02550"></a>02550 {
<a name="l02551"></a>02551   <span class="comment">// Insert new auxiliary in _Vars and corresponding operation in _Ops</span>
<a name="l02552"></a>02552   FPVar&lt;T&gt;* pAux = <span class="keyword">new</span> FPVar&lt;T&gt;( *this );
<a name="l02553"></a>02553   _Op = <span class="keyword">new</span> FPOp&lt;T&gt;( FPOp&lt;T&gt;::TMMC, 0, 0, pAux );
<a name="l02554"></a>02554   <span class="comment">//_Op-&gt;attach( TVMCX, TMFP );</span>
<a name="l02555"></a>02555   pAux-&gt;_Op = _Op;
<a name="l02556"></a>02556   FP-&gt;_Ops.insert( _Op );
<a name="l02557"></a>02557   FP-&gt;_append_aux( pAux );
<a name="l02558"></a>02558 
<a name="l02559"></a>02559   <span class="comment">// Build up polyhedral relaxation by separating remainder term and</span>
<a name="l02560"></a>02560   <span class="comment">// polynomial part</span>
<a name="l02561"></a>02561   <span class="keyword">typedef</span> mc::McCormick&lt;T&gt; MC;
<a name="l02562"></a>02562   <span class="keyword">typedef</span> mc::TVar&lt;T&gt; TV;
<a name="l02563"></a>02563   <span class="keyword">struct </span>loc{ <span class="keyword">static</span> FPVar&lt;T&gt; conv( <span class="keyword">const</span> MC&amp;X ){ <span class="keywordflow">return</span> FPVar&lt;T&gt;( X.I() ); } };
<a name="l02564"></a>02564   <span class="keyword">typedef</span> mc::TVar&lt; FPVar&lt;T&gt; &gt; TVFP;
<a name="l02565"></a>02565   TVFP TPFPX( TMFP, TVMCX.P(), loc::conv );
<a name="l02566"></a>02566   FPVar&lt;T&gt; TRFPX( FP, TVMCX.R(), MCXref, isub );
<a name="l02567"></a>02567   FP-&gt;add_constraint( *pAux, FPRelax&lt;T&gt;::EQ, TPFPX.B() + TRFPX );
<a name="l02568"></a>02568 }
<a name="l02569"></a>02569 
<a name="l02570"></a>02570 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02571"></a>02571 FPVar&lt;T&gt;::operator=
<a name="l02572"></a>02572 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l02573"></a>02573 {
<a name="l02574"></a>02574   <span class="keywordflow">if</span>( <span class="keyword">this</span> == &amp;Var )
<a name="l02575"></a>02575     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02576"></a>02576 
<a name="l02577"></a>02577   _id  = Var._id;
<a name="l02578"></a>02578   _num = Var._num;
<a name="l02579"></a>02579   _FP  = Var._FP;
<a name="l02580"></a>02580   _Op  = Var._Op;
<a name="l02581"></a>02581   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02582"></a>02582 }
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02585"></a>02585 FPVar&lt;T&gt;::operator=
<a name="l02586"></a>02586 ( <span class="keyword">const</span> T&amp;I )
<a name="l02587"></a>02587 {
<a name="l02588"></a>02588   _id  = std::make_pair(AUXCONT,NOREF);
<a name="l02589"></a>02589   _num = I;
<a name="l02590"></a>02590   _FP  = 0;
<a name="l02591"></a>02591   _Op  = 0;
<a name="l02592"></a>02592   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02593"></a>02593 }
<a name="l02594"></a>02594 
<a name="l02595"></a>02595 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02596"></a>02596 FPVar&lt;T&gt;::operator=
<a name="l02597"></a>02597 ( <span class="keyword">const</span> <span class="keywordtype">int</span> n )
<a name="l02598"></a>02598 {
<a name="l02599"></a>02599   _id  = std::make_pair(AUXINT,NOREF);
<a name="l02600"></a>02600   _num = n;
<a name="l02601"></a>02601   _FP  = 0;
<a name="l02602"></a>02602   _Op  = 0;
<a name="l02603"></a>02603   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02604"></a>02604 }
<a name="l02605"></a>02605 
<a name="l02606"></a>02606 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02607"></a>02607 FPVar&lt;T&gt;::operator=
<a name="l02608"></a>02608 ( <span class="keyword">const</span> <span class="keywordtype">double</span> x )
<a name="l02609"></a>02609 {
<a name="l02610"></a>02610   _id  = std::make_pair(AUXREAL,NOREF);
<a name="l02611"></a>02611   _num = x;
<a name="l02612"></a>02612   _FP  = 0;
<a name="l02613"></a>02613   _Op  = 0;
<a name="l02614"></a>02614   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02615"></a>02615 }
<a name="l02616"></a>02616 
<a name="l02617"></a>02617 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02618"></a>02618 <span class="keyword">operator</span>+
<a name="l02619"></a>02619 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l02620"></a>02620 {
<a name="l02621"></a>02621   <span class="keywordflow">return</span> Var;
<a name="l02622"></a>02622 }
<a name="l02623"></a>02623 
<a name="l02624"></a>02624 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02625"></a>02625 FPVar&lt;T&gt;::operator+=
<a name="l02626"></a>02626 ( <span class="keyword">const</span> U&amp;Var )
<a name="l02627"></a>02627 {
<a name="l02628"></a>02628   FPVar&lt;T&gt; VarNew = *<span class="keyword">this</span> + Var;
<a name="l02629"></a>02629   *<span class="keyword">this</span> = VarNew;
<a name="l02630"></a>02630   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02631"></a>02631 }
<a name="l02632"></a>02632 
<a name="l02633"></a>02633 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02634"></a>02634 <span class="keyword">operator</span>+
<a name="l02635"></a>02635 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02636"></a>02636 { 
<a name="l02637"></a>02637   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l02638"></a>02638    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02639"></a>02639     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02640"></a>02640       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l02641"></a>02641         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02642"></a>02642           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.n + Var2._num.n );
<a name="l02643"></a>02643           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.n + Var2._num.x );
<a name="l02644"></a>02644           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n + Var2._num.I );
<a name="l02645"></a>02645         }
<a name="l02646"></a>02646       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l02647"></a>02647         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02648"></a>02648           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.x + Var2._num.n );
<a name="l02649"></a>02649           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x + Var2._num.x );
<a name="l02650"></a>02650           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.x + Var2._num.I );
<a name="l02651"></a>02651         }
<a name="l02652"></a>02652       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l02653"></a>02653         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02654"></a>02654           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.I + (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02655"></a>02655           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.I + Var2._num.x );
<a name="l02656"></a>02656           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I + Var2._num.I );
<a name="l02657"></a>02657         }
<a name="l02658"></a>02658     }
<a name="l02659"></a>02659   }
<a name="l02660"></a>02660 
<a name="l02661"></a>02661   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02662"></a>02662     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02663"></a>02663       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var2 + (<span class="keywordtype">double</span>)Var1._num.n );
<a name="l02664"></a>02664       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var2 + Var1._num.x );
<a name="l02665"></a>02665       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var2 + Var1._num.I );
<a name="l02666"></a>02666     }
<a name="l02667"></a>02667   }
<a name="l02668"></a>02668   
<a name="l02669"></a>02669   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02670"></a>02670     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02671"></a>02671       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1 + (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02672"></a>02672       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1 + Var2._num.x );
<a name="l02673"></a>02673       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1 + Var2._num.I );
<a name="l02674"></a>02674     }
<a name="l02675"></a>02675   }
<a name="l02676"></a>02676 
<a name="l02677"></a>02677   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02678"></a>02678   <span class="comment">// (only if necessary)</span>
<a name="l02679"></a>02679   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l02680"></a>02680     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l02681"></a>02681   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l02682"></a>02682   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::PLUS, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l02683"></a>02683   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02684"></a>02684   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Var1._num.I+Var2._num.I, pOp );
<a name="l02685"></a>02685   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02686"></a>02686 }
<a name="l02687"></a>02687 
<a name="l02688"></a>02688 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02689"></a>02689 <span class="keyword">operator</span>+
<a name="l02690"></a>02690 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> T&amp;Bnd2 )
<a name="l02691"></a>02691 {
<a name="l02692"></a>02692   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02693"></a>02693     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02694"></a>02694       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n + Bnd2 );
<a name="l02695"></a>02695       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x + Bnd2 );
<a name="l02696"></a>02696       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I + Bnd2 );
<a name="l02697"></a>02697     }
<a name="l02698"></a>02698   }
<a name="l02699"></a>02699 
<a name="l02700"></a>02700   <span class="comment">// Append new interval Bnd2</span>
<a name="l02701"></a>02701   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l02702"></a>02702   FPVar&lt;T&gt;* pBnd2 = pFP-&gt;_auxiliary_constant( Bnd2 );
<a name="l02703"></a>02703   <span class="keywordflow">return</span>( Var1 + *pBnd2 );
<a name="l02704"></a>02704 }
<a name="l02705"></a>02705 
<a name="l02706"></a>02706 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02707"></a>02707 <span class="keyword">operator</span>+
<a name="l02708"></a>02708 ( <span class="keyword">const</span> T&amp;Bnd1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02709"></a>02709 {
<a name="l02710"></a>02710   <span class="keywordflow">return</span>( Var2 + Bnd1 );
<a name="l02711"></a>02711 }
<a name="l02712"></a>02712 
<a name="l02713"></a>02713 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02714"></a>02714 <span class="keyword">operator</span>+
<a name="l02715"></a>02715 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Cst2 )
<a name="l02716"></a>02716 {
<a name="l02717"></a>02717   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02718"></a>02718     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02719"></a>02719       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.n + Cst2 );
<a name="l02720"></a>02720       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x + Cst2 );
<a name="l02721"></a>02721       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I + (<span class="keywordtype">double</span>)Cst2 );
<a name="l02722"></a>02722     }
<a name="l02723"></a>02723   }
<a name="l02724"></a>02724 
<a name="l02725"></a>02725   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02726"></a>02726   <span class="comment">// (only if necessary); Also append constant Cst2 if not defined</span>
<a name="l02727"></a>02727   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l02728"></a>02728   FPVar&lt;T&gt;* pCst2 = pFP-&gt;_auxiliary_constant( Cst2 );
<a name="l02729"></a>02729   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::PLUS, Var1._Op-&gt;pres, pCst2-&gt;_Op-&gt;pres );
<a name="l02730"></a>02730   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02731"></a>02731   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Var1._num.I+(<span class="keywordtype">double</span>)Cst2, pOp );
<a name="l02732"></a>02732   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02733"></a>02733 }
<a name="l02734"></a>02734 
<a name="l02735"></a>02735 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02736"></a>02736 <span class="keyword">operator</span>+
<a name="l02737"></a>02737 ( <span class="keyword">const</span> U&amp;Cst1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02738"></a>02738 {
<a name="l02739"></a>02739   <span class="keywordflow">return</span>( Var2 + Cst1 );
<a name="l02740"></a>02740 }
<a name="l02741"></a>02741 
<a name="l02742"></a>02742 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02743"></a>02743 <span class="keyword">operator</span>-
<a name="l02744"></a>02744 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l02745"></a>02745 {
<a name="l02746"></a>02746   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02747"></a>02747     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l02748"></a>02748       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( -Var._num.n );
<a name="l02749"></a>02749       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( -Var._num.x );
<a name="l02750"></a>02750       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( -Var._num.I );
<a name="l02751"></a>02751     }
<a name="l02752"></a>02752   }
<a name="l02753"></a>02753 
<a name="l02754"></a>02754   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02755"></a>02755   <span class="comment">// (only if necessary)</span>
<a name="l02756"></a>02756   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l02757"></a>02757   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::NEG, Var._Op-&gt;pres );
<a name="l02758"></a>02758   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02759"></a>02759   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( -Var._num.I, pOp );
<a name="l02760"></a>02760   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02761"></a>02761 }
<a name="l02762"></a>02762 
<a name="l02763"></a>02763 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02764"></a>02764 FPVar&lt;T&gt;::operator-=
<a name="l02765"></a>02765 ( <span class="keyword">const</span> U&amp;Var )
<a name="l02766"></a>02766 {
<a name="l02767"></a>02767   FPVar&lt;T&gt; VarNew = *<span class="keyword">this</span> - Var;
<a name="l02768"></a>02768   *<span class="keyword">this</span> = VarNew;
<a name="l02769"></a>02769   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02770"></a>02770 }
<a name="l02771"></a>02771 
<a name="l02772"></a>02772 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02773"></a>02773 <span class="keyword">operator</span>-
<a name="l02774"></a>02774 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02775"></a>02775 {
<a name="l02776"></a>02776   <span class="keywordflow">if</span>( &amp;Var1 == &amp;Var2 ) <span class="keywordflow">return</span> 0.;
<a name="l02777"></a>02777 
<a name="l02778"></a>02778   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l02779"></a>02779    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02780"></a>02780     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02781"></a>02781       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l02782"></a>02782         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02783"></a>02783           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.n - Var2._num.n );
<a name="l02784"></a>02784           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.n - Var2._num.x );
<a name="l02785"></a>02785           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n - Var2._num.I );
<a name="l02786"></a>02786         }
<a name="l02787"></a>02787       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l02788"></a>02788         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02789"></a>02789           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.x - Var2._num.n );
<a name="l02790"></a>02790           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x - Var2._num.x );
<a name="l02791"></a>02791           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.x - Var2._num.I );
<a name="l02792"></a>02792         }
<a name="l02793"></a>02793       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l02794"></a>02794         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02795"></a>02795           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.I - (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02796"></a>02796           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.I - Var2._num.x );
<a name="l02797"></a>02797           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I - Var2._num.I );
<a name="l02798"></a>02798         }
<a name="l02799"></a>02799     }
<a name="l02800"></a>02800   }
<a name="l02801"></a>02801 
<a name="l02802"></a>02802   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02803"></a>02803     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02804"></a>02804       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n - Var2 );
<a name="l02805"></a>02805       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x - Var2 );
<a name="l02806"></a>02806       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I - Var2 );
<a name="l02807"></a>02807     }
<a name="l02808"></a>02808   }
<a name="l02809"></a>02809   
<a name="l02810"></a>02810   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02811"></a>02811     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02812"></a>02812       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1 - (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02813"></a>02813       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1 - Var2._num.x );
<a name="l02814"></a>02814       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1 - Var2._num.I );
<a name="l02815"></a>02815     }
<a name="l02816"></a>02816   }
<a name="l02817"></a>02817 
<a name="l02818"></a>02818   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02819"></a>02819   <span class="comment">// (only if necessary)</span>
<a name="l02820"></a>02820   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l02821"></a>02821     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l02822"></a>02822   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l02823"></a>02823   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MINUS, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l02824"></a>02824   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02825"></a>02825   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Var1._num.I-Var2._num.I, pOp );
<a name="l02826"></a>02826   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02827"></a>02827 }
<a name="l02828"></a>02828 
<a name="l02829"></a>02829 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02830"></a>02830 <span class="keyword">operator</span>-
<a name="l02831"></a>02831 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> T&amp;Bnd2 )
<a name="l02832"></a>02832 {
<a name="l02833"></a>02833   <span class="keywordflow">return</span>( Var1 + (-Bnd2) );
<a name="l02834"></a>02834 }
<a name="l02835"></a>02835 
<a name="l02836"></a>02836 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02837"></a>02837 <span class="keyword">operator</span>-
<a name="l02838"></a>02838 ( <span class="keyword">const</span> T&amp;Bnd1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02839"></a>02839 {
<a name="l02840"></a>02840   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02841"></a>02841     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02842"></a>02842       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Bnd1 - (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02843"></a>02843       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Bnd1 - Var2._num.x );
<a name="l02844"></a>02844       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Bnd1 - Var2._num.I );
<a name="l02845"></a>02845     }
<a name="l02846"></a>02846   }
<a name="l02847"></a>02847 
<a name="l02848"></a>02848   <span class="comment">// Append new interval Bnd1</span>
<a name="l02849"></a>02849   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l02850"></a>02850   FPVar&lt;T&gt;* pBnd1 = pFP-&gt;_auxiliary_constant( Bnd1 );
<a name="l02851"></a>02851   <span class="keywordflow">return</span>( *pBnd1 - Var2 );
<a name="l02852"></a>02852 }
<a name="l02853"></a>02853 
<a name="l02854"></a>02854 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02855"></a>02855 <span class="keyword">operator</span>-
<a name="l02856"></a>02856 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Cst2 )
<a name="l02857"></a>02857 {
<a name="l02858"></a>02858   <span class="keywordflow">return</span>( Var1 + (-Cst2) );
<a name="l02859"></a>02859 }
<a name="l02860"></a>02860 
<a name="l02861"></a>02861 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02862"></a>02862 <span class="keyword">operator</span>-
<a name="l02863"></a>02863 ( <span class="keyword">const</span> U&amp;Cst1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02864"></a>02864 {
<a name="l02865"></a>02865   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02866"></a>02866     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02867"></a>02867       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Cst1 - Var2._num.n );
<a name="l02868"></a>02868       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Cst1 - Var2._num.x );
<a name="l02869"></a>02869       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Cst1 - Var2._num.I );
<a name="l02870"></a>02870     }
<a name="l02871"></a>02871   }
<a name="l02872"></a>02872 
<a name="l02873"></a>02873   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02874"></a>02874   <span class="comment">// (only if necessary); Also append constant Cst2 if not defined</span>
<a name="l02875"></a>02875   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l02876"></a>02876   FPVar&lt;T&gt;* pCst1 = pFP-&gt;_auxiliary_constant( Cst1 );
<a name="l02877"></a>02877   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MINUS, pCst1-&gt;_Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l02878"></a>02878   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02879"></a>02879   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Cst1-Var2._num.I, pOp );
<a name="l02880"></a>02880   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02881"></a>02881 }
<a name="l02882"></a>02882 
<a name="l02883"></a>02883 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l02884"></a>02884 FPVar&lt;T&gt;::operator*=
<a name="l02885"></a>02885 ( <span class="keyword">const</span> U&amp;Var )
<a name="l02886"></a>02886 {
<a name="l02887"></a>02887   FPVar&lt;T&gt; VarNew = *<span class="keyword">this</span> * Var;
<a name="l02888"></a>02888   *<span class="keyword">this</span> = VarNew;
<a name="l02889"></a>02889   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l02890"></a>02890 }
<a name="l02891"></a>02891 
<a name="l02892"></a>02892 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02893"></a>02893 <span class="keyword">operator</span>*
<a name="l02894"></a>02894 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02895"></a>02895 {
<a name="l02896"></a>02896   <span class="keywordflow">if</span>( &amp;Var1 == &amp;Var2 ) <span class="keywordflow">return</span> sqr(Var1);
<a name="l02897"></a>02897 
<a name="l02898"></a>02898   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l02899"></a>02899    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02900"></a>02900     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02901"></a>02901       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l02902"></a>02902         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02903"></a>02903           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.n * Var2._num.n );
<a name="l02904"></a>02904           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.n * Var2._num.x );
<a name="l02905"></a>02905           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n * Var2._num.I );
<a name="l02906"></a>02906         }
<a name="l02907"></a>02907       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l02908"></a>02908         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02909"></a>02909           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.x * Var2._num.n );
<a name="l02910"></a>02910           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x * Var2._num.x );
<a name="l02911"></a>02911           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.x * Var2._num.I );
<a name="l02912"></a>02912         }
<a name="l02913"></a>02913       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l02914"></a>02914         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02915"></a>02915           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.I * (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02916"></a>02916           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.I * Var2._num.x );
<a name="l02917"></a>02917           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I * Var2._num.I );
<a name="l02918"></a>02918         }
<a name="l02919"></a>02919     }
<a name="l02920"></a>02920   }
<a name="l02921"></a>02921 
<a name="l02922"></a>02922   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02923"></a>02923     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02924"></a>02924       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n * Var2 );
<a name="l02925"></a>02925       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x * Var2 );
<a name="l02926"></a>02926       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I * Var2 );
<a name="l02927"></a>02927     }
<a name="l02928"></a>02928   }
<a name="l02929"></a>02929   
<a name="l02930"></a>02930   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02931"></a>02931     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02932"></a>02932       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1 * (<span class="keywordtype">double</span>)Var2._num.n );
<a name="l02933"></a>02933       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1 * Var2._num.x );
<a name="l02934"></a>02934       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1 * Var2._num.I );
<a name="l02935"></a>02935     }
<a name="l02936"></a>02936   }
<a name="l02937"></a>02937 
<a name="l02938"></a>02938   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02939"></a>02939   <span class="comment">// (only if necessary)</span>
<a name="l02940"></a>02940   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l02941"></a>02941     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l02942"></a>02942   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l02943"></a>02943   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::TIMES, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l02944"></a>02944   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02945"></a>02945   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Var1._num.I*Var2._num.I, pOp );
<a name="l02946"></a>02946   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l02947"></a>02947 }
<a name="l02948"></a>02948 
<a name="l02949"></a>02949 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02950"></a>02950 <span class="keyword">operator</span>*
<a name="l02951"></a>02951 ( <span class="keyword">const</span> T&amp;Bnd1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02952"></a>02952 {
<a name="l02953"></a>02953   <span class="keywordflow">return</span>( Var2 * Bnd1 );
<a name="l02954"></a>02954 }
<a name="l02955"></a>02955 
<a name="l02956"></a>02956 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02957"></a>02957 <span class="keyword">operator</span>*
<a name="l02958"></a>02958 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> T&amp;Bnd2 )
<a name="l02959"></a>02959 {
<a name="l02960"></a>02960   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02961"></a>02961     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l02962"></a>02962       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Var1._num.n * Bnd2 );
<a name="l02963"></a>02963       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x * Bnd2 );
<a name="l02964"></a>02964       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I * Bnd2 );
<a name="l02965"></a>02965     }
<a name="l02966"></a>02966   }
<a name="l02967"></a>02967 
<a name="l02968"></a>02968   <span class="comment">// Append new interval Bnd2</span>
<a name="l02969"></a>02969   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l02970"></a>02970   FPVar&lt;T&gt;* pBnd2 = pFP-&gt;_auxiliary_constant( Bnd2 );
<a name="l02971"></a>02971   <span class="keywordflow">return</span>( Var1 * *pBnd2 );
<a name="l02972"></a>02972 }
<a name="l02973"></a>02973 
<a name="l02974"></a>02974 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02975"></a>02975 <span class="keyword">operator</span>*
<a name="l02976"></a>02976 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Cst2 )
<a name="l02977"></a>02977 {
<a name="l02978"></a>02978   <span class="keywordflow">return</span>( Cst2 * Var1 );
<a name="l02979"></a>02979 }
<a name="l02980"></a>02980 
<a name="l02981"></a>02981 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l02982"></a>02982 <span class="keyword">operator</span>*
<a name="l02983"></a>02983 ( <span class="keyword">const</span> U&amp;Cst1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l02984"></a>02984 {
<a name="l02985"></a>02985   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l02986"></a>02986     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l02987"></a>02987       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Cst1 * Var2._num.n );
<a name="l02988"></a>02988       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Cst1 * Var2._num.x );
<a name="l02989"></a>02989       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( (<span class="keywordtype">double</span>)Cst1 * Var2._num.I );
<a name="l02990"></a>02990     }
<a name="l02991"></a>02991   }
<a name="l02992"></a>02992   <span class="comment">//if( mc::isequal( Cst1, 0. ) ) return( 0. );</span>
<a name="l02993"></a>02993 
<a name="l02994"></a>02994   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l02995"></a>02995   <span class="comment">// (only if necessary); Also append constant Cst2 if not defined</span>
<a name="l02996"></a>02996   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l02997"></a>02997   FPVar&lt;T&gt;* pCst1 = pFP-&gt;_auxiliary_constant( Cst1 );
<a name="l02998"></a>02998   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::SCALE, pCst1-&gt;_Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l02999"></a>02999   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03000"></a>03000   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( (<span class="keywordtype">double</span>)Cst1*Var2._num.I, pOp );
<a name="l03001"></a>03001   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03002"></a>03002 }
<a name="l03003"></a>03003 
<a name="l03004"></a>03004 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;&amp;
<a name="l03005"></a>03005 FPVar&lt;T&gt;::operator/=
<a name="l03006"></a>03006 ( <span class="keyword">const</span> U&amp;Var )
<a name="l03007"></a>03007 {
<a name="l03008"></a>03008   FPVar&lt;T&gt; VarNew = *<span class="keyword">this</span> / Var;
<a name="l03009"></a>03009   *<span class="keyword">this</span> = VarNew;
<a name="l03010"></a>03010   <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l03011"></a>03011 }
<a name="l03012"></a>03012 
<a name="l03013"></a>03013 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03014"></a>03014 <span class="keyword">operator</span>/
<a name="l03015"></a>03015 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03016"></a>03016 {
<a name="l03017"></a>03017   <span class="keywordflow">if</span>( &amp;Var1 == &amp;Var2 ) <span class="keywordflow">return</span> 1.;
<a name="l03018"></a>03018 
<a name="l03019"></a>03019   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l03020"></a>03020    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03021"></a>03021     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03022"></a>03022       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03023"></a>03023         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03024"></a>03024           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.n / Var2._num.n );
<a name="l03025"></a>03025           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.n / Var2._num.x );
<a name="l03026"></a>03026           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.n / Var2._num.I );
<a name="l03027"></a>03027         }
<a name="l03028"></a>03028       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03029"></a>03029         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03030"></a>03030           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.x / Var2._num.n );
<a name="l03031"></a>03031           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x / Var2._num.x );
<a name="l03032"></a>03032           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.x / Var2._num.I );
<a name="l03033"></a>03033         }
<a name="l03034"></a>03034       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03035"></a>03035         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03036"></a>03036           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.I / Var2._num.n );
<a name="l03037"></a>03037           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.I / Var2._num.x );
<a name="l03038"></a>03038           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I / Var2._num.I );
<a name="l03039"></a>03039         }
<a name="l03040"></a>03040     }
<a name="l03041"></a>03041   }
<a name="l03042"></a>03042 
<a name="l03043"></a>03043   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03044"></a>03044     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03045"></a>03045       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1._num.n / Var2 );
<a name="l03046"></a>03046       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1._num.x / Var2 );
<a name="l03047"></a>03047       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1._num.I / Var2 );
<a name="l03048"></a>03048     }
<a name="l03049"></a>03049   }
<a name="l03050"></a>03050   
<a name="l03051"></a>03051   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03052"></a>03052     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03053"></a>03053       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Var1 / Var2._num.n );
<a name="l03054"></a>03054       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Var1 / Var2._num.x );
<a name="l03055"></a>03055       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Var1 / Var2._num.I );
<a name="l03056"></a>03056     }
<a name="l03057"></a>03057   }
<a name="l03058"></a>03058 
<a name="l03059"></a>03059   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03060"></a>03060   <span class="comment">// (only if necessary)</span>
<a name="l03061"></a>03061   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l03062"></a>03062     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l03063"></a>03063   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03064"></a>03064   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::DIV, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03065"></a>03065   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03066"></a>03066   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Var1._num.I/Var2._num.I, pOp );
<a name="l03067"></a>03067   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03068"></a>03068 }
<a name="l03069"></a>03069 
<a name="l03070"></a>03070 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03071"></a>03071 <span class="keyword">operator</span>/
<a name="l03072"></a>03072 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> T&amp;Int2 )
<a name="l03073"></a>03073 {
<a name="l03074"></a>03074   <span class="keywordflow">return</span>( ( 1 / Int2 ) * Var1 );
<a name="l03075"></a>03075 }
<a name="l03076"></a>03076 
<a name="l03077"></a>03077 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03078"></a>03078 <span class="keyword">operator</span>/
<a name="l03079"></a>03079 ( <span class="keyword">const</span> T&amp;Bnd1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03080"></a>03080 {
<a name="l03081"></a>03081   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03082"></a>03082     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03083"></a>03083       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Bnd1 / Var2._num.n );
<a name="l03084"></a>03084       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Bnd1 / Var2._num.x );
<a name="l03085"></a>03085       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Bnd1 / Var2._num.I );
<a name="l03086"></a>03086     }
<a name="l03087"></a>03087   }
<a name="l03088"></a>03088 
<a name="l03089"></a>03089   <span class="comment">// Append new interval Bnd1</span>
<a name="l03090"></a>03090   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l03091"></a>03091   FPVar&lt;T&gt;* pBnd1 = pFP-&gt;_auxiliary_constant( Bnd1 );
<a name="l03092"></a>03092   <span class="keywordflow">return</span>( *pBnd1 / Var2 );
<a name="l03093"></a>03093 }
<a name="l03094"></a>03094 
<a name="l03095"></a>03095 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03096"></a>03096 <span class="keyword">operator</span>/
<a name="l03097"></a>03097 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Cst2 )
<a name="l03098"></a>03098 {
<a name="l03099"></a>03099   <span class="keywordflow">return</span>( ( 1 / Cst2 ) * Var1 );
<a name="l03100"></a>03100 }
<a name="l03101"></a>03101 
<a name="l03102"></a>03102 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03103"></a>03103 <span class="keyword">operator</span>/
<a name="l03104"></a>03104 ( <span class="keyword">const</span> U&amp;Cst1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03105"></a>03105 {
<a name="l03106"></a>03106   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03107"></a>03107     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03108"></a>03108       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Cst1 / Var2._num.n );
<a name="l03109"></a>03109       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Cst1 / Var2._num.x );
<a name="l03110"></a>03110       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Cst1 / Var2._num.I );
<a name="l03111"></a>03111     }
<a name="l03112"></a>03112   }
<a name="l03113"></a>03113 
<a name="l03114"></a>03114   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03115"></a>03115   <span class="comment">// (only if necessary); Also append constant Cst2 if not defined</span>
<a name="l03116"></a>03116   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l03117"></a>03117   FPVar&lt;T&gt;* pCst1 = pFP-&gt;_auxiliary_constant( Cst1 );
<a name="l03118"></a>03118   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::DIV, pCst1-&gt;_Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03119"></a>03119   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03120"></a>03120   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Cst1/Var2._num.I, pOp );
<a name="l03121"></a>03121   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03122"></a>03122 }
<a name="l03123"></a>03123 
<a name="l03124"></a>03124 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03125"></a>03125 inv
<a name="l03126"></a>03126 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03127"></a>03127 {
<a name="l03128"></a>03128   <span class="keywordflow">return</span>( 1 / Var );
<a name="l03129"></a>03129 }
<a name="l03130"></a>03130 
<a name="l03131"></a>03131 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03132"></a>03132 <span class="keyword">operator</span>^
<a name="l03133"></a>03133 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03134"></a>03134 {
<a name="l03135"></a>03135   <span class="keywordflow">if</span>( &amp;Var1 == &amp;Var2 ) <span class="keywordflow">return</span> Var1;
<a name="l03136"></a>03136 
<a name="l03137"></a>03137   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l03138"></a>03138    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03139"></a>03139     T Inter;
<a name="l03140"></a>03140     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03141"></a>03141       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03142"></a>03142         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03143"></a>03143           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03144"></a>03144             <span class="keywordflow">if</span> ( Var1._num.n == Var2._num.n ) <span class="keywordflow">return</span>( Var1._num.n );
<a name="l03145"></a>03145             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03146"></a>03146           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03147"></a>03147             <span class="keywordflow">if</span>( isequal( Var1._num.n, Var2._num.x ) ) <span class="keywordflow">return</span>( Var1._num.n );
<a name="l03148"></a>03148             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03149"></a>03149           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03150"></a>03150             <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.n, Var2._num.I ) ) <span class="keywordflow">return</span>( Var1._num.n );
<a name="l03151"></a>03151             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03152"></a>03152         }
<a name="l03153"></a>03153       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03154"></a>03154         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03155"></a>03155           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03156"></a>03156             <span class="keywordflow">if</span>( isequal( Var1._num.x, Var2._num.n ) ) <span class="keywordflow">return</span>( Var2._num.n );
<a name="l03157"></a>03157             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03158"></a>03158           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03159"></a>03159             <span class="keywordflow">if</span>( isequal( Var1._num.x, Var2._num.x ) ) <span class="keywordflow">return</span>( Var1._num.x );
<a name="l03160"></a>03160             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03161"></a>03161           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03162"></a>03162             <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.x, Var2._num.I ) ) <span class="keywordflow">return</span>( Var1._num.x );
<a name="l03163"></a>03163             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03164"></a>03164         }
<a name="l03165"></a>03165       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03166"></a>03166         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03167"></a>03167           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03168"></a>03168             <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.n ) ) <span class="keywordflow">return</span>( Var2._num.n );
<a name="l03169"></a>03169             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03170"></a>03170           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03171"></a>03171             <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.x ) ) <span class="keywordflow">return</span>( Var2._num.x );
<a name="l03172"></a>03172             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03173"></a>03173           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03174"></a>03174             <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.I ) ) <span class="keywordflow">return</span>( Inter );
<a name="l03175"></a>03175             <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03176"></a>03176         }
<a name="l03177"></a>03177     }
<a name="l03178"></a>03178   }
<a name="l03179"></a>03179 
<a name="l03180"></a>03180   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03181"></a>03181     T Inter;
<a name="l03182"></a>03182     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03183"></a>03183       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03184"></a>03184         <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.n, Var2._num.I ) ) <span class="keywordflow">return</span>( Var1._num.n );
<a name="l03185"></a>03185         <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03186"></a>03186       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03187"></a>03187         <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.x, Var2._num.I ) ) <span class="keywordflow">return</span>( Var1._num.x );
<a name="l03188"></a>03188         <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03189"></a>03189       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03190"></a>03190         <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.I ) ) <span class="keywordflow">return</span>( Inter );
<a name="l03191"></a>03191         <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03192"></a>03192     }
<a name="l03193"></a>03193   }
<a name="l03194"></a>03194 
<a name="l03195"></a>03195   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03196"></a>03196     T Inter;
<a name="l03197"></a>03197     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03198"></a>03198       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03199"></a>03199         <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.n ) ) <span class="keywordflow">return</span>( Var2._num.n );
<a name="l03200"></a>03200         <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03201"></a>03201       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03202"></a>03202         <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.x ) ) <span class="keywordflow">return</span>( Var2._num.x );
<a name="l03203"></a>03203         <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03204"></a>03204       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03205"></a>03205         <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.I ) ) <span class="keywordflow">return</span>( Inter );
<a name="l03206"></a>03206         <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03207"></a>03207     }
<a name="l03208"></a>03208   }
<a name="l03209"></a>03209 
<a name="l03210"></a>03210   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03211"></a>03211   <span class="comment">// (only if necessary)</span>
<a name="l03212"></a>03212   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l03213"></a>03213     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l03214"></a>03214   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03215"></a>03215   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::INTER, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03216"></a>03216   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03217"></a>03217   T Inter;
<a name="l03218"></a>03218   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( Inter, Var1._num.I, Var2._num.I ) )
<a name="l03219"></a>03219     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a70ccd19d0e2a52b7c1cbdd82e64c0b03" title="Error during intersection of two terms (terms may not intersect)">FPRelax&lt;T&gt;::Exceptions::INTER</a> );
<a name="l03220"></a>03220   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Inter, pOp );
<a name="l03221"></a>03221   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03222"></a>03222 }
<a name="l03223"></a>03223 
<a name="l03224"></a>03224 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03225"></a>03225 max
<a name="l03226"></a>03226 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03227"></a>03227 {
<a name="l03228"></a>03228   <span class="keywordflow">if</span>( &amp;Var1 == &amp;Var2 ) <span class="keywordflow">return</span> Var1;
<a name="l03229"></a>03229 
<a name="l03230"></a>03230   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l03231"></a>03231    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03232"></a>03232     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03233"></a>03233       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03234"></a>03234         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03235"></a>03235           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( max(Var1._num.n,Var2._num.n) );
<a name="l03236"></a>03236           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( max(Var1._num.n,Var2._num.x) );
<a name="l03237"></a>03237           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::max((<span class="keywordtype">double</span>)Var1._num.n,Var2._num.I) );
<a name="l03238"></a>03238         }
<a name="l03239"></a>03239       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03240"></a>03240         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03241"></a>03241           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( max(Var1._num.x,Var2._num.n) );
<a name="l03242"></a>03242           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( max(Var1._num.x,Var2._num.x) );
<a name="l03243"></a>03243           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::max(Var1._num.x,Var2._num.I) );
<a name="l03244"></a>03244         }
<a name="l03245"></a>03245       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03246"></a>03246         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03247"></a>03247           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Op&lt;T&gt;::max(Var1._num.I,(<span class="keywordtype">double</span>)Var2._num.n) );
<a name="l03248"></a>03248           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Op&lt;T&gt;::max(Var1._num.I,Var2._num.x) );
<a name="l03249"></a>03249           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::max(Var1._num.I,Var2._num.I) );
<a name="l03250"></a>03250         }
<a name="l03251"></a>03251     }
<a name="l03252"></a>03252   }
<a name="l03253"></a>03253 
<a name="l03254"></a>03254   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03255"></a>03255     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03256"></a>03256       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( max((<span class="keywordtype">double</span>)Var1._num.n,Var2) );
<a name="l03257"></a>03257       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( max(Var1._num.x,Var2) );
<a name="l03258"></a>03258       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( max(Var1._num.I,Var2) );
<a name="l03259"></a>03259     }
<a name="l03260"></a>03260   }
<a name="l03261"></a>03261   
<a name="l03262"></a>03262   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03263"></a>03263     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03264"></a>03264       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( max((<span class="keywordtype">double</span>)Var2._num.n,Var1) );
<a name="l03265"></a>03265       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( max(Var2._num.x,Var1) );
<a name="l03266"></a>03266       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( max(Var2._num.I,Var1) );
<a name="l03267"></a>03267     }
<a name="l03268"></a>03268   }
<a name="l03269"></a>03269 
<a name="l03270"></a>03270   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03271"></a>03271   <span class="comment">// (only if necessary)</span>
<a name="l03272"></a>03272   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l03273"></a>03273     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l03274"></a>03274   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03275"></a>03275   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MAXF, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03276"></a>03276   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03277"></a>03277   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::max(Var1._num.I,Var2._num.I), pOp );
<a name="l03278"></a>03278   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03279"></a>03279 }
<a name="l03280"></a>03280 
<a name="l03281"></a>03281 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03282"></a>03282 max
<a name="l03283"></a>03283 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Cst2 )
<a name="l03284"></a>03284 {
<a name="l03285"></a>03285   <span class="keywordflow">return</span>( max( Cst2, Var1 ) );
<a name="l03286"></a>03286 }
<a name="l03287"></a>03287 
<a name="l03288"></a>03288 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03289"></a>03289 max
<a name="l03290"></a>03290 ( <span class="keyword">const</span> U&amp;Cst1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03291"></a>03291 {
<a name="l03292"></a>03292   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03293"></a>03293     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03294"></a>03294       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( max(Cst1,Var2._num.n) );
<a name="l03295"></a>03295       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( max(Cst1,Var2._num.x) );
<a name="l03296"></a>03296       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::max((<span class="keywordtype">double</span>)Cst1,Var2._num.I) );
<a name="l03297"></a>03297     }
<a name="l03298"></a>03298   }
<a name="l03299"></a>03299 
<a name="l03300"></a>03300   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03301"></a>03301   <span class="comment">// (only if necessary); Also append constant Cst2 if not defined</span>
<a name="l03302"></a>03302   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l03303"></a>03303   FPVar&lt;T&gt;* pCst1 = pFP-&gt;_auxiliary_constant( Cst1 );
<a name="l03304"></a>03304   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MAXF, pCst1-&gt;_Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03305"></a>03305   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03306"></a>03306   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::max((<span class="keywordtype">double</span>)Cst1,Var2._num.I), pOp );
<a name="l03307"></a>03307   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03308"></a>03308 }
<a name="l03309"></a>03309 
<a name="l03310"></a>03310 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03311"></a>03311 max
<a name="l03312"></a>03312 ( <span class="keyword">const</span> T&amp;Bnd1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03313"></a>03313 {
<a name="l03314"></a>03314   <span class="keywordflow">return</span>( max( Var2, Bnd1 ) );
<a name="l03315"></a>03315 }
<a name="l03316"></a>03316 
<a name="l03317"></a>03317 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03318"></a>03318 max
<a name="l03319"></a>03319 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> T&amp;Bnd2 )
<a name="l03320"></a>03320 {
<a name="l03321"></a>03321   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03322"></a>03322     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03323"></a>03323       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Op&lt;T&gt;::max((<span class="keywordtype">double</span>)Var1._num.n,Bnd2) );
<a name="l03324"></a>03324       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Op&lt;T&gt;::max(Var1._num.x,Bnd2) );
<a name="l03325"></a>03325       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::max(Var1._num.I,Bnd2) );
<a name="l03326"></a>03326     }
<a name="l03327"></a>03327   }
<a name="l03328"></a>03328 
<a name="l03329"></a>03329   <span class="comment">// Append new interval Bnd2</span>
<a name="l03330"></a>03330   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03331"></a>03331   FPVar&lt;T&gt;* pBnd2 = pFP-&gt;_auxiliary_constant( Bnd2 );
<a name="l03332"></a>03332   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MAXF, Var1._Op-&gt;pres, pBnd2-&gt;_Op-&gt;pres );
<a name="l03333"></a>03333   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03334"></a>03334   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::max(Var1._num.I,Bnd2), pOp );
<a name="l03335"></a>03335   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03336"></a>03336   <span class="comment">//return( max(Var1,*pBnd2) );</span>
<a name="l03337"></a>03337 }
<a name="l03338"></a>03338 
<a name="l03339"></a>03339 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03340"></a>03340 max
<a name="l03341"></a>03341 ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nVar, <span class="keyword">const</span> FPVar&lt;T&gt;*pVar )
<a name="l03342"></a>03342 {
<a name="l03343"></a>03343   <span class="keywordflow">if</span>( nVar&lt;=0 || !pVar ) <span class="keywordflow">return</span>( 0 );
<a name="l03344"></a>03344   
<a name="l03345"></a>03345   FPVar&lt;T&gt; VarR = pVar[0];
<a name="l03346"></a>03346   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;nVar; i++ ) VarR = max( VarR, pVar[i] );
<a name="l03347"></a>03347   <span class="keywordflow">return</span>( VarR );
<a name="l03348"></a>03348 }
<a name="l03349"></a>03349 
<a name="l03350"></a>03350 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03351"></a>03351 min
<a name="l03352"></a>03352 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03353"></a>03353 {
<a name="l03354"></a>03354   <span class="keywordflow">if</span>( &amp;Var1 == &amp;Var2 ) <span class="keywordflow">return</span> Var1;
<a name="l03355"></a>03355 
<a name="l03356"></a>03356   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF
<a name="l03357"></a>03357    &amp;&amp; Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03358"></a>03358     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03359"></a>03359       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:
<a name="l03360"></a>03360         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03361"></a>03361           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( min(Var1._num.n,Var2._num.n) );
<a name="l03362"></a>03362           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( min(Var1._num.n,Var2._num.x) );
<a name="l03363"></a>03363           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::min((<span class="keywordtype">double</span>)Var1._num.n,Var2._num.I) );
<a name="l03364"></a>03364         }
<a name="l03365"></a>03365       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:
<a name="l03366"></a>03366         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03367"></a>03367           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( min(Var1._num.x,Var2._num.n) );
<a name="l03368"></a>03368           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( min(Var1._num.x,Var2._num.x) );
<a name="l03369"></a>03369           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::min(Var1._num.x,Var2._num.I) );
<a name="l03370"></a>03370         }
<a name="l03371"></a>03371       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE:
<a name="l03372"></a>03372         <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03373"></a>03373           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Op&lt;T&gt;::min(Var1._num.I,(<span class="keywordtype">double</span>)Var2._num.n) );
<a name="l03374"></a>03374           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Op&lt;T&gt;::min(Var1._num.I,Var2._num.x) );
<a name="l03375"></a>03375           <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::min(Var1._num.I,Var2._num.I) );
<a name="l03376"></a>03376         }
<a name="l03377"></a>03377     }
<a name="l03378"></a>03378   }
<a name="l03379"></a>03379 
<a name="l03380"></a>03380   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03381"></a>03381     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03382"></a>03382       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( min((<span class="keywordtype">double</span>)Var1._num.n,Var2) );
<a name="l03383"></a>03383       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( min(Var1._num.x,Var2) );
<a name="l03384"></a>03384       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( min(Var1._num.I,Var2) );
<a name="l03385"></a>03385     }
<a name="l03386"></a>03386   }
<a name="l03387"></a>03387   
<a name="l03388"></a>03388   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03389"></a>03389     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03390"></a>03390       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( min((<span class="keywordtype">double</span>)Var2._num.n,Var1) );
<a name="l03391"></a>03391       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( min(Var2._num.x,Var1) );
<a name="l03392"></a>03392       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( min(Var2._num.I,Var1) );
<a name="l03393"></a>03393     }
<a name="l03394"></a>03394   }
<a name="l03395"></a>03395 
<a name="l03396"></a>03396   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03397"></a>03397   <span class="comment">// (only if necessary)</span>
<a name="l03398"></a>03398   <span class="keywordflow">if</span>( Var1._FP != Var2._FP )
<a name="l03399"></a>03399     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284ab57926eff37bcbf759972e9c396ed151" title="Error due to an operation between variables participating in different factorable programs...">FPRelax&lt;T&gt;::Exceptions::FP</a> );
<a name="l03400"></a>03400   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03401"></a>03401   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MINF, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03402"></a>03402   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03403"></a>03403   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::min(Var1._num.I,Var2._num.I), pOp );
<a name="l03404"></a>03404   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03405"></a>03405 }
<a name="l03406"></a>03406 
<a name="l03407"></a>03407 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03408"></a>03408 min
<a name="l03409"></a>03409 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Cst2 )
<a name="l03410"></a>03410 {
<a name="l03411"></a>03411   <span class="keywordflow">return</span>( min( Cst2, Var1 ) );
<a name="l03412"></a>03412 }
<a name="l03413"></a>03413 
<a name="l03414"></a>03414 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03415"></a>03415 min
<a name="l03416"></a>03416 ( <span class="keyword">const</span> U&amp;Cst1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03417"></a>03417 {
<a name="l03418"></a>03418   <span class="keywordflow">if</span>( Var2._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03419"></a>03419     <span class="keywordflow">switch</span>( Var2._num.t ){
<a name="l03420"></a>03420       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( min(Cst1,Var2._num.n) );
<a name="l03421"></a>03421       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( min(Cst1,Var2._num.x) );
<a name="l03422"></a>03422       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::min((<span class="keywordtype">double</span>)Cst1,Var2._num.I) );
<a name="l03423"></a>03423     }
<a name="l03424"></a>03424   }
<a name="l03425"></a>03425 
<a name="l03426"></a>03426   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03427"></a>03427   <span class="comment">// (only if necessary); Also append constant Cst2 if not defined</span>
<a name="l03428"></a>03428   FPRelax&lt;T&gt;* pFP = Var2._FP;
<a name="l03429"></a>03429   FPVar&lt;T&gt;* pCst1 = pFP-&gt;_auxiliary_constant( Cst1 );
<a name="l03430"></a>03430   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MINF, pCst1-&gt;_Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03431"></a>03431   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03432"></a>03432   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::min((<span class="keywordtype">double</span>)Cst1,Var2._num.I), pOp );
<a name="l03433"></a>03433   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03434"></a>03434 }
<a name="l03435"></a>03435 
<a name="l03436"></a>03436 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03437"></a>03437 min
<a name="l03438"></a>03438 ( <span class="keyword">const</span> T&amp;Bnd1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03439"></a>03439 {
<a name="l03440"></a>03440   <span class="keywordflow">return</span>( min( Var2, Bnd1 ) );
<a name="l03441"></a>03441 }
<a name="l03442"></a>03442 
<a name="l03443"></a>03443 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03444"></a>03444 min
<a name="l03445"></a>03445 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> T&amp;Bnd2 )
<a name="l03446"></a>03446 {
<a name="l03447"></a>03447   <span class="keywordflow">if</span>( Var1._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03448"></a>03448     <span class="keywordflow">switch</span>( Var1._num.t ){
<a name="l03449"></a>03449       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( Op&lt;T&gt;::min((<span class="keywordtype">double</span>)Var1._num.n,Bnd2) );
<a name="l03450"></a>03450       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( Op&lt;T&gt;::min(Var1._num.x,Bnd2) );
<a name="l03451"></a>03451       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::min(Var1._num.I,Bnd2) );
<a name="l03452"></a>03452     }
<a name="l03453"></a>03453   }
<a name="l03454"></a>03454 
<a name="l03455"></a>03455   <span class="comment">// Append new interval Bnd2</span>
<a name="l03456"></a>03456   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03457"></a>03457   FPVar&lt;T&gt;* pBnd2 = pFP-&gt;_auxiliary_constant( Bnd2 );
<a name="l03458"></a>03458   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::MINF, Var1._Op-&gt;pres, pBnd2-&gt;_Op-&gt;pres );
<a name="l03459"></a>03459   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03460"></a>03460   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::min(Var1._num.I,Bnd2), pOp );
<a name="l03461"></a>03461   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03462"></a>03462   <span class="comment">//return( Var1 * *pBnd2 );</span>
<a name="l03463"></a>03463 }
<a name="l03464"></a>03464 
<a name="l03465"></a>03465 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03466"></a>03466 min
<a name="l03467"></a>03467 ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> nVar, <span class="keyword">const</span> FPVar&lt;T&gt;*pVar )
<a name="l03468"></a>03468 {
<a name="l03469"></a>03469   <span class="keywordflow">if</span>( nVar&lt;=0 || !pVar ) <span class="keywordflow">return</span>( 0 );
<a name="l03470"></a>03470   
<a name="l03471"></a>03471   FPVar&lt;T&gt; VarR = pVar[0];
<a name="l03472"></a>03472   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;nVar; i++ ) VarR = min( VarR, pVar[i] );
<a name="l03473"></a>03473   <span class="keywordflow">return</span>( VarR );
<a name="l03474"></a>03474 }
<a name="l03475"></a>03475 
<a name="l03476"></a>03476 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03477"></a>03477 exp
<a name="l03478"></a>03478 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03479"></a>03479 {
<a name="l03480"></a>03480   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03481"></a>03481     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03482"></a>03482       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::exp( Var._num.n ) );
<a name="l03483"></a>03483       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::exp( Var._num.x ) );
<a name="l03484"></a>03484       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::exp( Var._num.I ) );
<a name="l03485"></a>03485     }
<a name="l03486"></a>03486   }
<a name="l03487"></a>03487 
<a name="l03488"></a>03488   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03489"></a>03489   <span class="comment">// (only if necessary)</span>
<a name="l03490"></a>03490   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03491"></a>03491   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::EXP, Var._Op-&gt;pres );
<a name="l03492"></a>03492   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03493"></a>03493   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::exp(Var._num.I), pOp );
<a name="l03494"></a>03494   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03495"></a>03495 }
<a name="l03496"></a>03496 
<a name="l03497"></a>03497 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03498"></a>03498 log
<a name="l03499"></a>03499 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03500"></a>03500 {
<a name="l03501"></a>03501   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03502"></a>03502     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03503"></a>03503       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::log( Var._num.n ) );
<a name="l03504"></a>03504       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::log( Var._num.x ) );
<a name="l03505"></a>03505       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::log( Var._num.I ) );
<a name="l03506"></a>03506     }
<a name="l03507"></a>03507   }
<a name="l03508"></a>03508 
<a name="l03509"></a>03509   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03510"></a>03510   <span class="comment">// (only if necessary)</span>
<a name="l03511"></a>03511   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03512"></a>03512   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::LOG, Var._Op-&gt;pres );
<a name="l03513"></a>03513   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03514"></a>03514   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::log(Var._num.I), pOp );
<a name="l03515"></a>03515   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03516"></a>03516 }
<a name="l03517"></a>03517 
<a name="l03518"></a>03518 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03519"></a>03519 sqr
<a name="l03520"></a>03520 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03521"></a>03521 {
<a name="l03522"></a>03522   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03523"></a>03523     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03524"></a>03524       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( mc::sqr( Var._num.n ) );
<a name="l03525"></a>03525       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( mc::sqr( Var._num.x ) );
<a name="l03526"></a>03526       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::sqr( Var._num.I ) );
<a name="l03527"></a>03527     }
<a name="l03528"></a>03528   }
<a name="l03529"></a>03529 
<a name="l03530"></a>03530   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03531"></a>03531   <span class="comment">// (only if necessary)</span>
<a name="l03532"></a>03532   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03533"></a>03533   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::SQR, Var._Op-&gt;pres );
<a name="l03534"></a>03534   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03535"></a>03535   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::sqr(Var._num.I), pOp );
<a name="l03536"></a>03536   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03537"></a>03537 }
<a name="l03538"></a>03538 
<a name="l03539"></a>03539 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03540"></a>03540 sqrt
<a name="l03541"></a>03541 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03542"></a>03542 {
<a name="l03543"></a>03543   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03544"></a>03544     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03545"></a>03545       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::sqrt( Var._num.n ) );
<a name="l03546"></a>03546       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::sqrt( Var._num.x ) );
<a name="l03547"></a>03547       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::sqrt( Var._num.I ) );
<a name="l03548"></a>03548     }
<a name="l03549"></a>03549   }
<a name="l03550"></a>03550 
<a name="l03551"></a>03551   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03552"></a>03552   <span class="comment">// (only if necessary)</span>
<a name="l03553"></a>03553   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03554"></a>03554   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::SQRT, Var._Op-&gt;pres );
<a name="l03555"></a>03555   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03556"></a>03556   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::sqrt(Var._num.I), pOp );
<a name="l03557"></a>03557   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03558"></a>03558 }
<a name="l03559"></a>03559 
<a name="l03560"></a>03560 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03561"></a>03561 fabs
<a name="l03562"></a>03562 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03563"></a>03563 {
<a name="l03564"></a>03564   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03565"></a>03565     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03566"></a>03566       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::fabs( Var._num.n ) );
<a name="l03567"></a>03567       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::fabs( Var._num.x ) );
<a name="l03568"></a>03568       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::fabs( Var._num.I ) );
<a name="l03569"></a>03569     }
<a name="l03570"></a>03570   }
<a name="l03571"></a>03571 
<a name="l03572"></a>03572   <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var._num.I) &gt;= 0. ) <span class="keywordflow">return</span>( Var );
<a name="l03573"></a>03573   <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var._num.I) &lt;= 0. ) <span class="keywordflow">return</span>( -Var );
<a name="l03574"></a>03574 
<a name="l03575"></a>03575   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03576"></a>03576   <span class="comment">// (only if necessary)</span>
<a name="l03577"></a>03577   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03578"></a>03578   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::FABS, Var._Op-&gt;pres );
<a name="l03579"></a>03579   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03580"></a>03580   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::fabs(Var._num.I), pOp );
<a name="l03581"></a>03581   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03582"></a>03582 }
<a name="l03583"></a>03583 
<a name="l03584"></a>03584 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03585"></a>03585 pow
<a name="l03586"></a>03586 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var, <span class="keyword">const</span> <span class="keywordtype">int</span> iExp )
<a name="l03587"></a>03587 {
<a name="l03588"></a>03588   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03589"></a>03589     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03590"></a>03590       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::pow( Var._num.n, iExp ) );
<a name="l03591"></a>03591       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::pow( Var._num.x, iExp ) );
<a name="l03592"></a>03592       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::pow( Var._num.I, iExp ) );
<a name="l03593"></a>03593     }
<a name="l03594"></a>03594   }
<a name="l03595"></a>03595 
<a name="l03596"></a>03596   <span class="keywordflow">if</span>( iExp == 0 ) <span class="keywordflow">return</span>( 1. );
<a name="l03597"></a>03597   <span class="keywordflow">if</span>( iExp == 1 ) <span class="keywordflow">return</span> Var;
<a name="l03598"></a>03598   <span class="keywordflow">if</span>( iExp == 2 ) <span class="keywordflow">return</span> sqr(Var);
<a name="l03599"></a>03599   <span class="keywordflow">if</span>( iExp &gt;= 3 ){
<a name="l03600"></a>03600     FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03601"></a>03601     <span class="keywordflow">if</span>( !(iExp%2) || pFP-&gt;options.NEWTON_USE ){ 
<a name="l03602"></a>03602       <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03603"></a>03603       <span class="comment">// (only if necessary); Also append integer exponent iExp if not defined</span>
<a name="l03604"></a>03604       FPVar&lt;T&gt;* piExp = pFP-&gt;_auxiliary_constant( iExp );
<a name="l03605"></a>03605       FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::IPOW, Var._Op-&gt;pres, piExp-&gt;_Op-&gt;pres );
<a name="l03606"></a>03606       <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03607"></a>03607       pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::pow(Var._num.I,iExp), pOp );
<a name="l03608"></a>03608       <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03609"></a>03609     }
<a name="l03610"></a>03610     <span class="keywordflow">return</span> pow( Var, iExp-1 ) * Var;
<a name="l03611"></a>03611   }
<a name="l03612"></a>03612   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03613"></a>03613   <span class="comment">// (only if necessary); Also append integer exponent iExp if not defined</span>
<a name="l03614"></a>03614   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03615"></a>03615   FPVar&lt;T&gt;* piExp = pFP-&gt;_auxiliary_constant( iExp );
<a name="l03616"></a>03616   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::IPOW, Var._Op-&gt;pres, piExp-&gt;_Op-&gt;pres );
<a name="l03617"></a>03617   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03618"></a>03618   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::pow(Var._num.I,iExp), pOp );
<a name="l03619"></a>03619   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03620"></a>03620   <span class="comment">//return inv( pow( Var, -iExp ) );</span>
<a name="l03621"></a>03621 }
<a name="l03622"></a>03622 
<a name="l03623"></a>03623 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03624"></a>03624 pow
<a name="l03625"></a>03625 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> U&amp;Var2 )
<a name="l03626"></a>03626 {
<a name="l03627"></a>03627   <span class="keywordflow">return</span> exp( Var2 * log( Var1 ) );
<a name="l03628"></a>03628 }
<a name="l03629"></a>03629 
<a name="l03630"></a>03630 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03631"></a>03631 pow
<a name="l03632"></a>03632 ( <span class="keyword">const</span> <span class="keywordtype">double</span> Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03633"></a>03633 {
<a name="l03634"></a>03634   <span class="keywordflow">return</span> exp( Var2 * std::log( Var1 ) );
<a name="l03635"></a>03635 }
<a name="l03636"></a>03636 
<a name="l03637"></a>03637 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03638"></a>03638 cos
<a name="l03639"></a>03639 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03640"></a>03640 {
<a name="l03641"></a>03641   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03642"></a>03642     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03643"></a>03643       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::cos( Var._num.n ) );
<a name="l03644"></a>03644       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::cos( Var._num.x ) );
<a name="l03645"></a>03645       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::cos( Var._num.I ) );
<a name="l03646"></a>03646     }
<a name="l03647"></a>03647   }
<a name="l03648"></a>03648 
<a name="l03649"></a>03649   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03650"></a>03650   <span class="comment">// (only if necessary)</span>
<a name="l03651"></a>03651   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03652"></a>03652   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::COS, Var._Op-&gt;pres );
<a name="l03653"></a>03653   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03654"></a>03654   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::cos(Var._num.I), pOp );
<a name="l03655"></a>03655   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03656"></a>03656 }
<a name="l03657"></a>03657 
<a name="l03658"></a>03658 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03659"></a>03659 sin
<a name="l03660"></a>03660 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03661"></a>03661 {
<a name="l03662"></a>03662   <span class="keywordflow">return</span> cos( Var - PI/2. );
<a name="l03663"></a>03663 }
<a name="l03664"></a>03664 
<a name="l03665"></a>03665 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03666"></a>03666 tan
<a name="l03667"></a>03667 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03668"></a>03668 {
<a name="l03669"></a>03669   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03670"></a>03670     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03671"></a>03671       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::tan( Var._num.n ) );
<a name="l03672"></a>03672       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::tan( Var._num.x ) );
<a name="l03673"></a>03673       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::tan( Var._num.I ) );
<a name="l03674"></a>03674     }
<a name="l03675"></a>03675   }
<a name="l03676"></a>03676 
<a name="l03677"></a>03677   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03678"></a>03678   <span class="comment">// (only if necessary)</span>
<a name="l03679"></a>03679   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03680"></a>03680   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::TAN, Var._Op-&gt;pres );
<a name="l03681"></a>03681   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03682"></a>03682   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::tan(Var._num.I), pOp );
<a name="l03683"></a>03683   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03684"></a>03684 }
<a name="l03685"></a>03685 
<a name="l03686"></a>03686 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03687"></a>03687 asin
<a name="l03688"></a>03688 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03689"></a>03689 {
<a name="l03690"></a>03690   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03691"></a>03691     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03692"></a>03692       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::asin( Var._num.n ) );
<a name="l03693"></a>03693       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::asin( Var._num.x ) );
<a name="l03694"></a>03694       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::asin( Var._num.I ) );
<a name="l03695"></a>03695     }
<a name="l03696"></a>03696   }
<a name="l03697"></a>03697 
<a name="l03698"></a>03698   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03699"></a>03699   <span class="comment">// (only if necessary)</span>
<a name="l03700"></a>03700   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03701"></a>03701   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::ASIN, Var._Op-&gt;pres );
<a name="l03702"></a>03702   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03703"></a>03703   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::asin(Var._num.I), pOp );
<a name="l03704"></a>03704   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03705"></a>03705 }
<a name="l03706"></a>03706 
<a name="l03707"></a>03707 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03708"></a>03708 acos
<a name="l03709"></a>03709 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03710"></a>03710 {
<a name="l03711"></a>03711   <span class="keywordflow">return</span>( asin( -Var ) + PI/2. );
<a name="l03712"></a>03712 }
<a name="l03713"></a>03713 
<a name="l03714"></a>03714 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03715"></a>03715 atan
<a name="l03716"></a>03716 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03717"></a>03717 {
<a name="l03718"></a>03718   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03719"></a>03719     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03720"></a>03720       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( std::atan( Var._num.n ) );
<a name="l03721"></a>03721       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( std::atan( Var._num.x ) );
<a name="l03722"></a>03722       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::atan( Var._num.I ) );
<a name="l03723"></a>03723     }
<a name="l03724"></a>03724   }
<a name="l03725"></a>03725 
<a name="l03726"></a>03726   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03727"></a>03727   <span class="comment">// (only if necessary)</span>
<a name="l03728"></a>03728   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03729"></a>03729   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::ATAN, Var._Op-&gt;pres );
<a name="l03730"></a>03730   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03731"></a>03731   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::atan(Var._num.I), pOp );
<a name="l03732"></a>03732   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03733"></a>03733 }
<a name="l03734"></a>03734 
<a name="l03735"></a>03735 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03736"></a>03736 erf
<a name="l03737"></a>03737 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03738"></a>03738 {
<a name="l03739"></a>03739   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03740"></a>03740     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03741"></a>03741       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( ::erf( Var._num.n ) );
<a name="l03742"></a>03742       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( ::erf( Var._num.x ) );
<a name="l03743"></a>03743       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::erf( Var._num.I ) );
<a name="l03744"></a>03744     }
<a name="l03745"></a>03745   }
<a name="l03746"></a>03746 
<a name="l03747"></a>03747   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03748"></a>03748   <span class="comment">// (only if necessary)</span>
<a name="l03749"></a>03749   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03750"></a>03750   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::ERF, Var._Op-&gt;pres );
<a name="l03751"></a>03751   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03752"></a>03752   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::erf(Var._num.I), pOp );
<a name="l03753"></a>03753   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03754"></a>03754 }
<a name="l03755"></a>03755 
<a name="l03756"></a>03756 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03757"></a>03757 erfc
<a name="l03758"></a>03758 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03759"></a>03759 {
<a name="l03760"></a>03760   <span class="keywordflow">return</span> ( 1. - erf( Var ) );
<a name="l03761"></a>03761 }
<a name="l03762"></a>03762 
<a name="l03763"></a>03763 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03764"></a>03764 fstep
<a name="l03765"></a>03765 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03766"></a>03766 {
<a name="l03767"></a>03767   <span class="keywordflow">if</span>( Var._id.second == FPVar&lt;T&gt;::NOREF ){
<a name="l03768"></a>03768     <span class="keywordflow">switch</span>( Var._num.t ){
<a name="l03769"></a>03769       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::INT:   <span class="keywordflow">return</span>( mc::fstep( Var._num.n ) );
<a name="l03770"></a>03770       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::REAL:  <span class="keywordflow">return</span>( mc::fstep( Var._num.x ) );
<a name="l03771"></a>03771       <span class="keywordflow">case</span> FPVarNum&lt;T&gt;::RANGE: <span class="keywordflow">return</span>( Op&lt;T&gt;::l( Var._num.I )&gt;=0? T(1.):
<a name="l03772"></a>03772         ( Op&lt;T&gt;::u( Var._num.I )&lt;0? T(0.): Op&lt;T&gt;::zeroone() ) );
<a name="l03773"></a>03773     }
<a name="l03774"></a>03774   }
<a name="l03775"></a>03775 
<a name="l03776"></a>03776   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03777"></a>03777   <span class="comment">// (only if necessary)</span>
<a name="l03778"></a>03778   FPRelax&lt;T&gt;* pFP = Var._FP;
<a name="l03779"></a>03779   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::FSTEP, Var._Op-&gt;pres );
<a name="l03780"></a>03780   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03781"></a>03781   T Bres = Op&lt;T&gt;::l( Var._num.I )&gt;=0? T(1.): ( Op&lt;T&gt;::u( Var._num.I )&lt;0?
<a name="l03782"></a>03782     T(0.): Op&lt;T&gt;::zeroone() );
<a name="l03783"></a>03783   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Bres, pOp );
<a name="l03784"></a>03784   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03785"></a>03785 }
<a name="l03786"></a>03786 
<a name="l03787"></a>03787 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;
<a name="l03788"></a>03788 bstep
<a name="l03789"></a>03789 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var )
<a name="l03790"></a>03790 {
<a name="l03791"></a>03791   <span class="keywordflow">return</span> ( fstep( -Var ) );
<a name="l03792"></a>03792 }
<a name="l03793"></a>03793 
<a name="l03794"></a>03794 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt; bilin
<a name="l03795"></a>03795 ( <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var1, <span class="keyword">const</span> FPVar&lt;T&gt;&amp;Var2 )
<a name="l03796"></a>03796 {
<a name="l03797"></a>03797   FPRelax&lt;T&gt;* pFP = Var1._FP;
<a name="l03798"></a>03798   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv = pFP-&gt;options.BILINEAR_SUBDIV;
<a name="l03799"></a>03799   <span class="keywordflow">if</span>( Ndiv &lt;= 1 || Var1._id.first == FPVar&lt;T&gt;::AUXINT
<a name="l03800"></a>03800    || Var1._id.first == FPVar&lt;T&gt;::AUXREAL || Var2._id.first == FPVar&lt;T&gt;::AUXINT
<a name="l03801"></a>03801    || Var2._id.first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span>( Var1 * Var2 );
<a name="l03802"></a>03802 
<a name="l03803"></a>03803   <span class="comment">// Append new intermediate variable and corresponding operation</span>
<a name="l03804"></a>03804   <span class="comment">// (only if necessary)</span>
<a name="l03805"></a>03805   FPOp&lt;T&gt;* pOp = pFP-&gt;_operation( FPOp&lt;T&gt;::BILIN, Var1._Op-&gt;pres, Var2._Op-&gt;pres );
<a name="l03806"></a>03806   <span class="keywordflow">if</span>( pOp-&gt;pres ) <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03807"></a>03807   pOp-&gt;pres = pFP-&gt;_auxiliary_variable( Var1._num.I*Var2._num.I, pOp );
<a name="l03808"></a>03808   <span class="keywordflow">return</span> *pOp-&gt;pres;
<a name="l03809"></a>03809 }
<a name="l03810"></a>03810 
<a name="l03812"></a>03812 
<a name="l03813"></a>03813 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::ostream&amp;
<a name="l03814"></a>03814 <span class="keyword">operator</span> &lt;&lt;
<a name="l03815"></a>03815 ( std::ostream&amp;out, <span class="keyword">const</span> FPOp&lt;T&gt;&amp;Op)
<a name="l03816"></a>03816 {
<a name="l03817"></a>03817   <span class="keywordflow">switch</span>( Op.type ){
<a name="l03818"></a>03818   <span class="keywordflow">case</span> FPOp&lt;T&gt;::CNST:
<a name="l03819"></a>03819     out &lt;&lt; <span class="stringliteral">&quot;CONSTANT&quot;</span>;
<a name="l03820"></a>03820     <span class="keywordflow">break</span>;
<a name="l03821"></a>03821   <span class="keywordflow">case</span> FPOp&lt;T&gt;::RANGE:
<a name="l03822"></a>03822   <span class="keywordflow">case</span> FPOp&lt;T&gt;::VAR:
<a name="l03823"></a>03823     out &lt;&lt; <span class="stringliteral">&quot;VARIABLE&quot;</span>;
<a name="l03824"></a>03824     <span class="keywordflow">break</span>;
<a name="l03825"></a>03825   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MC:
<a name="l03826"></a>03826     out &lt;&lt; <span class="stringliteral">&quot;MCCORMICK&quot;</span>;
<a name="l03827"></a>03827     <span class="keywordflow">break</span>;
<a name="l03828"></a>03828   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TM:
<a name="l03829"></a>03829     out &lt;&lt; <span class="stringliteral">&quot;TAYLOR&quot;</span>;
<a name="l03830"></a>03830     <span class="keywordflow">break</span>;
<a name="l03831"></a>03831   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TMMC:
<a name="l03832"></a>03832     out &lt;&lt; <span class="stringliteral">&quot;MCCORMICK-TAYLOR&quot;</span>;
<a name="l03833"></a>03833     <span class="keywordflow">break</span>;
<a name="l03834"></a>03834   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MIN:
<a name="l03835"></a>03835     out &lt;&lt; <span class="stringliteral">&quot;MIN &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() );
<a name="l03836"></a>03836     <span class="keywordflow">break</span>;
<a name="l03837"></a>03837   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MAX:
<a name="l03838"></a>03838     out &lt;&lt; <span class="stringliteral">&quot;MAX &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() );
<a name="l03839"></a>03839     <span class="keywordflow">break</span>;
<a name="l03840"></a>03840   <span class="keywordflow">case</span> FPOp&lt;T&gt;::EQ:
<a name="l03841"></a>03841     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; == &quot;</span>
<a name="l03842"></a>03842         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03843"></a>03843     <span class="keywordflow">break</span>;
<a name="l03844"></a>03844   <span class="keywordflow">case</span> FPOp&lt;T&gt;::LE:
<a name="l03845"></a>03845     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; &lt;= &quot;</span>
<a name="l03846"></a>03846         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03847"></a>03847     <span class="keywordflow">break</span>;
<a name="l03848"></a>03848   <span class="keywordflow">case</span> FPOp&lt;T&gt;::PLUS:
<a name="l03849"></a>03849     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; + &quot;</span>
<a name="l03850"></a>03850         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03851"></a>03851     <span class="keywordflow">break</span>;
<a name="l03852"></a>03852   <span class="keywordflow">case</span> FPOp&lt;T&gt;::NEG:
<a name="l03853"></a>03853     out &lt;&lt; <span class="stringliteral">&quot;- &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() );
<a name="l03854"></a>03854     <span class="keywordflow">break</span>;
<a name="l03855"></a>03855   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MINUS:
<a name="l03856"></a>03856     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; - &quot;</span>
<a name="l03857"></a>03857         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03858"></a>03858     <span class="keywordflow">break</span>;
<a name="l03859"></a>03859   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TIMES: <span class="keywordflow">case</span> FPOp&lt;T&gt;::SCALE:
<a name="l03860"></a>03860     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; * &quot;</span>
<a name="l03861"></a>03861         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03862"></a>03862     <span class="keywordflow">break</span>;
<a name="l03863"></a>03863   <span class="keywordflow">case</span> FPOp&lt;T&gt;::DIV:
<a name="l03864"></a>03864     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; / &quot;</span>
<a name="l03865"></a>03865         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03866"></a>03866     <span class="keywordflow">break</span>;
<a name="l03867"></a>03867   <span class="keywordflow">case</span> FPOp&lt;T&gt;::INTER:
<a name="l03868"></a>03868     out &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; ^ &quot;</span>
<a name="l03869"></a>03869         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() );
<a name="l03870"></a>03870     <span class="keywordflow">break</span>;
<a name="l03871"></a>03871   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MINF:
<a name="l03872"></a>03872     out &lt;&lt; <span class="stringliteral">&quot;MIN( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l03873"></a>03873         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03874"></a>03874     <span class="keywordflow">break</span>;
<a name="l03875"></a>03875   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MAXF:
<a name="l03876"></a>03876     out &lt;&lt; <span class="stringliteral">&quot;MIN( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l03877"></a>03877         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03878"></a>03878     <span class="keywordflow">break</span>;
<a name="l03879"></a>03879   <span class="keywordflow">case</span> FPOp&lt;T&gt;::BILIN:
<a name="l03880"></a>03880     out &lt;&lt; <span class="stringliteral">&quot;BILIN( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l03881"></a>03881         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03882"></a>03882     <span class="keywordflow">break</span>;
<a name="l03883"></a>03883   <span class="keywordflow">case</span> FPOp&lt;T&gt;::EXP:
<a name="l03884"></a>03884     out &lt;&lt; <span class="stringliteral">&quot;EXP( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03885"></a>03885     <span class="keywordflow">break</span>;
<a name="l03886"></a>03886   <span class="keywordflow">case</span> FPOp&lt;T&gt;::LOG:
<a name="l03887"></a>03887     out &lt;&lt; <span class="stringliteral">&quot;LOG( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03888"></a>03888     <span class="keywordflow">break</span>;
<a name="l03889"></a>03889   <span class="keywordflow">case</span> FPOp&lt;T&gt;::SQR:
<a name="l03890"></a>03890     out &lt;&lt; <span class="stringliteral">&quot;SQR( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03891"></a>03891     <span class="keywordflow">break</span>;
<a name="l03892"></a>03892   <span class="keywordflow">case</span> FPOp&lt;T&gt;::SQRT:
<a name="l03893"></a>03893     out &lt;&lt; <span class="stringliteral">&quot;SQRT( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03894"></a>03894     <span class="keywordflow">break</span>;
<a name="l03895"></a>03895   <span class="keywordflow">case</span> FPOp&lt;T&gt;::FABS:
<a name="l03896"></a>03896     out &lt;&lt; <span class="stringliteral">&quot;FABS( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03897"></a>03897     <span class="keywordflow">break</span>;
<a name="l03898"></a>03898   <span class="keywordflow">case</span> FPOp&lt;T&gt;::IPOW:
<a name="l03899"></a>03899     out &lt;&lt; <span class="stringliteral">&quot;POW( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l03900"></a>03900         &lt;&lt; FPVar&lt;T&gt;::_name( Op.prop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03901"></a>03901     <span class="keywordflow">break</span>;
<a name="l03902"></a>03902   <span class="keywordflow">case</span> FPOp&lt;T&gt;::COS:
<a name="l03903"></a>03903     out &lt;&lt; <span class="stringliteral">&quot;COS( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03904"></a>03904     <span class="keywordflow">break</span>;
<a name="l03905"></a>03905   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TAN:
<a name="l03906"></a>03906     out &lt;&lt; <span class="stringliteral">&quot;TAN( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03907"></a>03907     <span class="keywordflow">break</span>;
<a name="l03908"></a>03908   <span class="keywordflow">case</span> FPOp&lt;T&gt;::ASIN:
<a name="l03909"></a>03909     out &lt;&lt; <span class="stringliteral">&quot;ASIN( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03910"></a>03910     <span class="keywordflow">break</span>;
<a name="l03911"></a>03911   <span class="keywordflow">case</span> FPOp&lt;T&gt;::ATAN:
<a name="l03912"></a>03912     out &lt;&lt; <span class="stringliteral">&quot;ATAN( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03913"></a>03913     <span class="keywordflow">break</span>;
<a name="l03914"></a>03914   <span class="keywordflow">case</span> FPOp&lt;T&gt;::ERF:
<a name="l03915"></a>03915     out &lt;&lt; <span class="stringliteral">&quot;ERF( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03916"></a>03916     <span class="keywordflow">break</span>;
<a name="l03917"></a>03917   <span class="keywordflow">case</span> FPOp&lt;T&gt;::FSTEP:
<a name="l03918"></a>03918     out &lt;&lt; <span class="stringliteral">&quot;FSTEP( &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( Op.plop-&gt;id() ) &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>;
<a name="l03919"></a>03919     <span class="keywordflow">break</span>;
<a name="l03920"></a>03920   <span class="keywordflow">default</span>:;
<a name="l03921"></a>03921   } 
<a name="l03922"></a>03922   <span class="keywordflow">return</span> out;
<a name="l03923"></a>03923 }
<a name="l03924"></a>03924 
<a name="l03925"></a>03925 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l03926"></a>03926 <a class="code" href="group__FP.html#gac2debf37675cff7ace49921505250f1e" title="Propagate bounds for all operations in the factorable program pFP">FPOp&lt;T&gt;::propagate_bounds</a>
<a name="l03927"></a><a class="code" href="group__FP.html#gac2debf37675cff7ace49921505250f1e">03927</a> ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP )
<a name="l03928"></a>03928 {
<a name="l03929"></a>03929   <span class="keywordflow">if</span>( !tighten_bounds( pFP ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03930"></a>03930   <span class="keywordflow">if</span>( plop &amp;&amp; plop-&gt;Oper() &amp;&amp; !plop-&gt;Oper()-&gt;propagate_bounds( pFP ) )
<a name="l03931"></a>03931     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03932"></a>03932   <span class="keywordflow">if</span>( prop &amp;&amp; prop-&gt;Oper() &amp;&amp; !prop-&gt;Oper()-&gt;propagate_bounds( pFP ) )
<a name="l03933"></a>03933     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03934"></a>03934   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03935"></a>03935 }
<a name="l03936"></a>03936 
<a name="l03937"></a>03937 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l03938"></a>03938 <a class="code" href="group__FP.html#ga820f6b68a854cb7f026918da3c384f1e" title="Tighten variable bounds for the current operation in the factorable program pFP via constraint propag...">FPOp&lt;T&gt;::tighten_bounds</a>
<a name="l03939"></a><a class="code" href="group__FP.html#ga820f6b68a854cb7f026918da3c384f1e">03939</a> ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP )
<a name="l03940"></a>03940 {
<a name="l03941"></a>03941   <span class="keywordflow">switch</span>( type ){
<a name="l03942"></a>03942     
<a name="l03943"></a>03943   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>:
<a name="l03944"></a>03944   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a>:   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03945"></a>03945   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>:    <span class="keywordflow">return</span> _EQ_bounds( pFP, plop, prop );
<a name="l03946"></a>03946   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>:    <span class="keywordflow">return</span> _LE_bounds( pFP, plop, prop );
<a name="l03947"></a>03947 
<a name="l03948"></a>03948   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::PLUS</a>:  <span class="keywordflow">return</span> _PLUS_bounds( pFP, pres, plop, prop );
<a name="l03949"></a>03949   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::NEG</a>:   <span class="keywordflow">return</span> _NEG_bounds( pFP, pres, plop );
<a name="l03950"></a>03950   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MINUS</a>: <span class="keywordflow">return</span> _MINUS_bounds( pFP, pres, plop, prop );
<a name="l03951"></a>03951   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TIMES</a>:
<a name="l03952"></a>03952   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SCALE</a>:
<a name="l03953"></a>03953   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::BILIN</a>: <span class="keywordflow">return</span> _TIMES_bounds( pFP, pres, plop, prop );
<a name="l03954"></a>03954   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::DIV</a>:   <span class="keywordflow">return</span> _DIV_bounds( pFP, pres, plop, prop );
<a name="l03955"></a>03955   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MINF</a>: 
<a name="l03956"></a>03956   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAXF</a>: 
<a name="l03957"></a>03957   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::INTER</a>: <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03958"></a>03958 
<a name="l03959"></a>03959   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EXP</a>:   <span class="keywordflow">return</span> _EXP_bounds( pFP, pres, plop );
<a name="l03960"></a>03960   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LOG</a>:   <span class="keywordflow">return</span> _LOG_bounds( pFP, pres, plop );
<a name="l03961"></a>03961   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SQR</a>:   <span class="keywordflow">return</span> _SQR_bounds( pFP, pres, plop );
<a name="l03962"></a>03962   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SQRT</a>:  <span class="keywordflow">return</span> _SQRT_bounds( pFP, pres, plop );
<a name="l03963"></a>03963   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::FABS</a>:  <span class="keywordflow">return</span> _FABS_bounds( pFP, pres, plop );
<a name="l03964"></a>03964   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::IPOW</a>:  <span class="keywordflow">return</span> _IPOW_bounds( pFP, pres, plop, prop );
<a name="l03965"></a>03965 
<a name="l03966"></a>03966   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::CNST</a>:
<a name="l03967"></a>03967   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::RANGE</a>:
<a name="l03968"></a>03968   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::VAR</a>:
<a name="l03969"></a>03969   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MC:
<a name="l03970"></a>03970   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TM:
<a name="l03971"></a>03971   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TMMC:  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03972"></a>03972 
<a name="l03973"></a>03973   <span class="keywordflow">default</span>:
<a name="l03974"></a>03974     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">//throw typename FPRelax&lt;T&gt;::Exceptions( FPRelax&lt;T&gt;::Exceptions::UNDEF );</span>
<a name="l03975"></a>03975   }
<a name="l03976"></a>03976 }
<a name="l03977"></a>03977 
<a name="l03978"></a>03978 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l03979"></a>03979 <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::_EQ_bounds</a>
<a name="l03980"></a>03980 ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 )
<a name="l03981"></a>03981 {
<a name="l03982"></a>03982   T IV1V2;
<a name="l03983"></a>03983 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l03984"></a>03984 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: EQ&quot;</span> &lt;&lt; std::endl
<a name="l03985"></a>03985             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var1-&gt;<a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90" title="Get variable name.">name</a>() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l03986"></a>03986                           &lt;&lt; Var2-&gt;<a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90" title="Get variable name.">name</a>() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() &lt;&lt; std::endl;
<a name="l03987"></a>03987 <span class="preprocessor">#endif</span>
<a name="l03988"></a>03988 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( IV1V2, Var1-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>(), Var2-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03989"></a>03989   pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a57f5a651122a5e0bb7f1094564766fbd" title="Update the bounds of the variable Var as Bnd">_update_var</a>( Var1, IV1V2 );
<a name="l03990"></a>03990   pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a57f5a651122a5e0bb7f1094564766fbd" title="Update the bounds of the variable Var as Bnd">_update_var</a>( Var2, IV1V2 );
<a name="l03991"></a>03991 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l03992"></a>03992 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var1-&gt;<a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90" title="Get variable name.">name</a>() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l03993"></a>03993                           &lt;&lt; Var2-&gt;<a class="code" href="group__FP.html#ga21b20aefe27f61d28084600c9a3dcb90" title="Get variable name.">name</a>() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() &lt;&lt; std::endl;
<a name="l03994"></a>03994 <span class="preprocessor">#endif</span>
<a name="l03995"></a>03995 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03996"></a>03996 }
<a name="l03997"></a>03997 
<a name="l03998"></a>03998 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l03999"></a>03999 FPOp&lt;T&gt;::_LE_bounds
<a name="l04000"></a>04000 ( FPRelax&lt;T&gt;*pFP, FPVar&lt;T&gt;*Var1, FPVar&lt;T&gt;*Var2 )
<a name="l04001"></a>04001 {
<a name="l04002"></a>04002 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04003"></a>04003 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: LE&quot;</span> &lt;&lt; std::endl
<a name="l04004"></a>04004             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04005"></a>04005                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04006"></a>04006 <span class="preprocessor">#endif</span>
<a name="l04007"></a>04007 <span class="preprocessor"></span>  <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var2-&gt;I()) &lt; Op&lt;T&gt;::l(Var1-&gt;I()) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04008"></a>04008   <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var1-&gt;I()) &gt; Op&lt;T&gt;::u(Var2-&gt;I()) )
<a name="l04009"></a>04009     pFP-&gt;_update_var( Var1, T( Op&lt;T&gt;::l(Var1-&gt;I()), Op&lt;T&gt;::u(Var2-&gt;I()) ) );
<a name="l04010"></a>04010   <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var2-&gt;I()) &lt; Op&lt;T&gt;::l(Var1-&gt;I()) )
<a name="l04011"></a>04011     pFP-&gt;_update_var( Var2, T( Op&lt;T&gt;::l(Var1-&gt;I()), Op&lt;T&gt;::u(Var2-&gt;I()) ) );
<a name="l04012"></a>04012 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04013"></a>04013 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04014"></a>04014                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04015"></a>04015 <span class="preprocessor">#endif</span>
<a name="l04016"></a>04016 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04017"></a>04017 }
<a name="l04018"></a>04018 
<a name="l04019"></a>04019 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04020"></a>04020 FPOp&lt;T&gt;::_NEG_bounds
<a name="l04021"></a>04021 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var )
<a name="l04022"></a>04022 {
<a name="l04023"></a>04023 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04024"></a>04024 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: NEG&quot;</span> &lt;&lt; std::endl
<a name="l04025"></a>04025             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var-&gt;I() &lt;&lt; std::endl;
<a name="l04026"></a>04026 <span class="preprocessor">#endif</span>
<a name="l04027"></a>04027 <span class="preprocessor"></span>  T VarRef;
<a name="l04028"></a>04028   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), -VarR-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04029"></a>04029   pFP-&gt;_update_var( Var, VarRef );
<a name="l04030"></a>04030 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04031"></a>04031 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var-&gt;I() &lt;&lt; std::endl;
<a name="l04032"></a>04032 <span class="preprocessor">#endif</span>
<a name="l04033"></a>04033 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04034"></a>04034 }
<a name="l04035"></a>04035 
<a name="l04036"></a>04036 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04037"></a>04037 FPOp&lt;T&gt;::_PLUS_bounds
<a name="l04038"></a>04038 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var1, FPVar&lt;T&gt;*Var2 )
<a name="l04039"></a>04039 {
<a name="l04040"></a>04040 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04041"></a>04041 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: PLUS&quot;</span> &lt;&lt; std::endl
<a name="l04042"></a>04042             &lt;&lt; <span class="stringliteral">&quot;  RES.  &quot;</span> &lt;&lt; VarR-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; VarR-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04043"></a>04043             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04044"></a>04044                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04045"></a>04045 <span class="preprocessor">#endif</span>
<a name="l04046"></a>04046 <span class="preprocessor"></span>  T VarRef;
<a name="l04047"></a>04047   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var1-&gt;I(), VarR-&gt;I()-Var2-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04048"></a>04048   pFP-&gt;_update_var( Var1, VarRef );
<a name="l04049"></a>04049   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var2-&gt;I(), VarR-&gt;I()-Var1-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04050"></a>04050   pFP-&gt;_update_var( Var2, VarRef );
<a name="l04051"></a>04051 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04052"></a>04052 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04053"></a>04053                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04054"></a>04054 <span class="preprocessor">#endif</span>
<a name="l04055"></a>04055 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04056"></a>04056 }
<a name="l04057"></a>04057 
<a name="l04058"></a>04058 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04059"></a>04059 FPOp&lt;T&gt;::_MINUS_bounds
<a name="l04060"></a>04060 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var1, FPVar&lt;T&gt;*Var2 )
<a name="l04061"></a>04061 {
<a name="l04062"></a>04062 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04063"></a>04063 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: MINUS&quot;</span> &lt;&lt; std::endl
<a name="l04064"></a>04064             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04065"></a>04065                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04066"></a>04066 <span class="preprocessor">#endif</span>
<a name="l04067"></a>04067 <span class="preprocessor"></span>  T VarRef;
<a name="l04068"></a>04068   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var1-&gt;I(), VarR-&gt;I()+Var2-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04069"></a>04069   pFP-&gt;_update_var( Var1, VarRef );
<a name="l04070"></a>04070   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var2-&gt;I(), Var1-&gt;I()-VarR-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04071"></a>04071   pFP-&gt;_update_var( Var2, VarRef );
<a name="l04072"></a>04072 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04073"></a>04073 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04074"></a>04074                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04075"></a>04075 <span class="preprocessor">#endif</span>
<a name="l04076"></a>04076 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04077"></a>04077 }
<a name="l04078"></a>04078 
<a name="l04079"></a>04079 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04080"></a>04080 FPOp&lt;T&gt;::_TIMES_bounds
<a name="l04081"></a>04081 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var1, FPVar&lt;T&gt;*Var2 )
<a name="l04082"></a>04082 {
<a name="l04083"></a>04083 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04084"></a>04084 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: TIMES&quot;</span> &lt;&lt; std::endl
<a name="l04085"></a>04085             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04086"></a>04086                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04087"></a>04087 <span class="preprocessor">#endif</span>
<a name="l04088"></a>04088 <span class="preprocessor"></span>  T VarRef;
<a name="l04089"></a>04089   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var2-&gt;I(), 0. ) ){
<a name="l04090"></a>04090     <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var1-&gt;I(), VarR-&gt;I()/Var2-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04091"></a>04091     pFP-&gt;_update_var( Var1, VarRef );
<a name="l04092"></a>04092   }
<a name="l04093"></a>04093   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var1-&gt;I(), 0. ) ){
<a name="l04094"></a>04094     <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var2-&gt;I(), VarR-&gt;I()/Var1-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04095"></a>04095   pFP-&gt;_update_var( Var2, VarRef );
<a name="l04096"></a>04096   }
<a name="l04097"></a>04097 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04098"></a>04098 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04099"></a>04099                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04100"></a>04100 <span class="preprocessor">#endif</span>
<a name="l04101"></a>04101 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04102"></a>04102 }
<a name="l04103"></a>04103 
<a name="l04104"></a>04104 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04105"></a>04105 FPOp&lt;T&gt;::_DIV_bounds
<a name="l04106"></a>04106 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var1, FPVar&lt;T&gt;*Var2 )
<a name="l04107"></a>04107 {
<a name="l04108"></a>04108 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04109"></a>04109 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nCONSTRAINT PROPAGATION: DIV&quot;</span> &lt;&lt; std::endl
<a name="l04110"></a>04110             &lt;&lt; <span class="stringliteral">&quot;  BEF.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04111"></a>04111                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04112"></a>04112 <span class="preprocessor">#endif</span>
<a name="l04113"></a>04113 <span class="preprocessor"></span>  T VarRef;
<a name="l04114"></a>04114   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var1-&gt;I(), VarR-&gt;I()*Var2-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04115"></a>04115   pFP-&gt;_update_var( Var1, VarRef );
<a name="l04116"></a>04116   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, VarR-&gt;I(), 0. ) ){
<a name="l04117"></a>04117     <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var2-&gt;I(), Var1-&gt;I()/VarR-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04118"></a>04118   pFP-&gt;_update_var( Var2, VarRef );
<a name="l04119"></a>04119   }
<a name="l04120"></a>04120 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l04121"></a>04121 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;  AFT.  &quot;</span> &lt;&lt; Var1-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var1-&gt;I() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>
<a name="l04122"></a>04122                           &lt;&lt; Var2-&gt;name() &lt;&lt; <span class="stringliteral">&quot;=&quot;</span> &lt;&lt; Var2-&gt;I() &lt;&lt; std::endl;
<a name="l04123"></a>04123 <span class="preprocessor">#endif</span>
<a name="l04124"></a>04124 <span class="preprocessor"></span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04125"></a>04125 }
<a name="l04126"></a>04126 
<a name="l04127"></a>04127 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04128"></a>04128 FPOp&lt;T&gt;::_EXP_bounds
<a name="l04129"></a>04129 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var )
<a name="l04130"></a>04130 {
<a name="l04131"></a>04131   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT
<a name="l04132"></a>04132    || Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04133"></a>04133 
<a name="l04134"></a>04134   T VarRef;
<a name="l04135"></a>04135   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), Op&lt;T&gt;::log(VarR-&gt;I()) ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04136"></a>04136   pFP-&gt;_update_var( Var, VarRef );
<a name="l04137"></a>04137   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04138"></a>04138 }
<a name="l04139"></a>04139 
<a name="l04140"></a>04140 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04141"></a>04141 FPOp&lt;T&gt;::_LOG_bounds
<a name="l04142"></a>04142 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var )
<a name="l04143"></a>04143 {
<a name="l04144"></a>04144   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT
<a name="l04145"></a>04145    || Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04146"></a>04146 
<a name="l04147"></a>04147   T VarRef;
<a name="l04148"></a>04148   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), Op&lt;T&gt;::exp(VarR-&gt;I()) ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04149"></a>04149   pFP-&gt;_update_var( Var, VarRef );
<a name="l04150"></a>04150   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04151"></a>04151 }
<a name="l04152"></a>04152 
<a name="l04153"></a>04153 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04154"></a>04154 FPOp&lt;T&gt;::_SQR_bounds
<a name="l04155"></a>04155 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var )
<a name="l04156"></a>04156 {
<a name="l04157"></a>04157   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT
<a name="l04158"></a>04158    || Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04159"></a>04159 
<a name="l04160"></a>04160   T VarRef;
<a name="l04161"></a>04161   <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var-&gt;I()) &gt;= 0
<a name="l04162"></a>04162    &amp;&amp; !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), Op&lt;T&gt;::sqrt(VarR-&gt;I()) ) )
<a name="l04163"></a>04163       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04164"></a>04164   <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var-&gt;I()) &lt;= 0
<a name="l04165"></a>04165    &amp;&amp; !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), -Op&lt;T&gt;::sqrt(VarR-&gt;I()) ) )
<a name="l04166"></a>04166     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04167"></a>04167   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), Op&lt;T&gt;::sqrt(VarR-&gt;I())
<a name="l04168"></a>04168    *(2.*Op&lt;T&gt;::zeroone()-1.) ) )
<a name="l04169"></a>04169     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04170"></a>04170   pFP-&gt;_update_var( Var, VarRef );
<a name="l04171"></a>04171   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04172"></a>04172 }
<a name="l04173"></a>04173 
<a name="l04174"></a>04174 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04175"></a>04175 FPOp&lt;T&gt;::_SQRT_bounds
<a name="l04176"></a>04176 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var )
<a name="l04177"></a>04177 {
<a name="l04178"></a>04178   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT
<a name="l04179"></a>04179    || Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04180"></a>04180 
<a name="l04181"></a>04181   T VarRef;
<a name="l04182"></a>04182   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), Op&lt;T&gt;::sqr(VarR-&gt;I()) ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04183"></a>04183   pFP-&gt;_update_var( Var, VarRef );
<a name="l04184"></a>04184   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04185"></a>04185 }
<a name="l04186"></a>04186 
<a name="l04187"></a>04187 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04188"></a>04188 FPOp&lt;T&gt;::_FABS_bounds
<a name="l04189"></a>04189 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var )
<a name="l04190"></a>04190 {
<a name="l04191"></a>04191   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT
<a name="l04192"></a>04192    || Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04193"></a>04193 
<a name="l04194"></a>04194   T VarRef;
<a name="l04195"></a>04195   <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), VarR-&gt;I() ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04196"></a>04196   <span class="keywordflow">if</span>( Op&lt;T&gt;::u(VarR-&gt;I()) &lt; Op&lt;T&gt;::u(Var-&gt;I()) )
<a name="l04197"></a>04197     pFP-&gt;_update_var( Var, T( Op&lt;T&gt;::l(Var-&gt;I()), Op&lt;T&gt;::u(VarR-&gt;I()) ) );
<a name="l04198"></a>04198   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04199"></a>04199 }
<a name="l04200"></a>04200 
<a name="l04201"></a>04201 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l04202"></a>04202 FPOp&lt;T&gt;::_IPOW_bounds
<a name="l04203"></a>04203 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, FPVar&lt;T&gt;*Var,
<a name="l04204"></a>04204   <span class="keyword">const</span> FPVar&lt;T&gt;*Exp )
<a name="l04205"></a>04205 {
<a name="l04206"></a>04206   <span class="keyword">const</span> <span class="keywordtype">int</span> iExp = Exp-&gt;num().n;
<a name="l04207"></a>04207   <span class="keywordflow">if</span>( iExp == 0 || iExp == 1 || iExp == 2 )
<a name="l04208"></a>04208     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a16924b8a3445bf87649086a3e17eaa06" title="Internal error.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l04209"></a>04209   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT
<a name="l04210"></a>04210    || Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04211"></a>04211 
<a name="l04212"></a>04212   T VarRef;
<a name="l04213"></a>04213   <span class="keywordflow">if</span>( iExp&gt;0 &amp;&amp; !(iExp%2) ){
<a name="l04214"></a>04214     <span class="keywordflow">if</span>( Op&lt;T&gt;::inter( VarRef, VarR-&gt;I(), 0. ) ){
<a name="l04215"></a>04215       <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var-&gt;I()) &gt; 0 ){
<a name="l04216"></a>04216         <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(),
<a name="l04217"></a>04217           Op&lt;T&gt;::pow(VarR-&gt;I(),1./(T)iExp) ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04218"></a>04218         pFP-&gt;_update_var( Var, VarRef );
<a name="l04219"></a>04219         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04220"></a>04220       }
<a name="l04221"></a>04221       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var-&gt;I()) &lt; 0 ){
<a name="l04222"></a>04222         <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(),
<a name="l04223"></a>04223           -Op&lt;T&gt;::pow(VarR-&gt;I(),1./(T)iExp) ) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04224"></a>04224         pFP-&gt;_update_var( Var, VarRef );
<a name="l04225"></a>04225         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04226"></a>04226       }
<a name="l04227"></a>04227     }
<a name="l04228"></a>04228     <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), (2.*Op&lt;T&gt;::zeroone()-1.)
<a name="l04229"></a>04229       *std::pow(Op&lt;T&gt;::u(VarR-&gt;I()),1./(<span class="keywordtype">double</span>)iExp) ) ) return false;
<a name="l04230"></a>04230     pFP-&gt;_update_var( Var, VarRef );
<a name="l04231"></a>04231     return true;
<a name="l04232"></a>04232   }
<a name="l04233"></a>04233 
<a name="l04234"></a>04234   else if( iExp &gt; 0 ){
<a name="l04235"></a>04235     <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter( VarRef, Var-&gt;I(), T(mc::sign(Op&lt;T&gt;::l(VarR-&gt;I()))
<a name="l04236"></a>04236       *std::pow(std::fabs(Op&lt;T&gt;::l(VarR-&gt;I())),1./(double)iExp),
<a name="l04237"></a>04237       mc::sign(Op&lt;T&gt;::u(VarR-&gt;I()))
<a name="l04238"></a>04238       *std::pow(std::fabs(Op&lt;T&gt;::u(VarR-&gt;I())),1./(double)iExp)) ) )
<a name="l04239"></a>04239       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04240"></a>04240     pFP-&gt;_update_var( Var, VarRef );
<a name="l04241"></a>04241   }
<a name="l04242"></a>04242 
<a name="l04243"></a>04243   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04244"></a>04244 }
<a name="l04245"></a>04245 
<a name="l04246"></a>04246 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04247"></a>04247 <a class="code" href="group__FP.html#ga7ec730514eb7a24c327760859963d516" title="Generate polyhedral cuts for all operations in the factorable program pFP">FPOp&lt;T&gt;::generate_cuts</a>
<a name="l04248"></a><a class="code" href="group__FP.html#ga7ec730514eb7a24c327760859963d516">04248</a> ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP )
<a name="l04249"></a>04249 {
<a name="l04250"></a>04250   <span class="keywordflow">if</span>( _visited ) <span class="keywordflow">return</span>;
<a name="l04251"></a>04251   _visited = <span class="keyword">true</span>;
<a name="l04252"></a>04252   
<a name="l04253"></a>04253   append_cuts( pFP );
<a name="l04254"></a>04254   <span class="keywordflow">if</span>( plop &amp;&amp; plop-&gt;Oper() ) plop-&gt;Oper()-&gt;generate_cuts( pFP );
<a name="l04255"></a>04255   <span class="keywordflow">if</span>( prop &amp;&amp; prop-&gt;Oper() ) prop-&gt;Oper()-&gt;generate_cuts( pFP );
<a name="l04256"></a>04256   <span class="keywordflow">return</span>;
<a name="l04257"></a>04257 }
<a name="l04258"></a>04258 
<a name="l04259"></a>04259 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04260"></a>04260 <a class="code" href="group__FP.html#ga5e662e9cc5e0d49cb088966e43dab89c" title="Append polyhedral cuts for the current operation in the factorable program pFP">FPOp&lt;T&gt;::append_cuts</a>
<a name="l04261"></a><a class="code" href="group__FP.html#ga5e662e9cc5e0d49cb088966e43dab89c">04261</a> ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP )
<a name="l04262"></a>04262 {
<a name="l04263"></a>04263   <span class="keywordflow">switch</span>( type ){
<a name="l04264"></a>04264     
<a name="l04265"></a>04265   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>:
<a name="l04266"></a>04266   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a>:   <span class="keywordflow">break</span>;
<a name="l04267"></a>04267   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>:    _EQ_cuts( pFP, plop, prop );          <span class="keywordflow">break</span>;
<a name="l04268"></a>04268   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>:    _LE_cuts( pFP, plop, prop );          <span class="keywordflow">break</span>;
<a name="l04269"></a>04269 
<a name="l04270"></a>04270   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::PLUS</a>:  _PLUS_cuts( pFP, pres, plop, prop );  <span class="keywordflow">break</span>;
<a name="l04271"></a>04271   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::NEG</a>:   _NEG_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04272"></a>04272   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MINUS</a>: _MINUS_cuts( pFP, pres, plop, prop ); <span class="keywordflow">break</span>;
<a name="l04273"></a>04273   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TIMES</a>:
<a name="l04274"></a>04274   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SCALE</a>: _TIMES_cuts( pFP, pres, plop, prop ); <span class="keywordflow">break</span>;
<a name="l04275"></a>04275   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::DIV</a>:   _DIV_cuts( pFP, pres, plop, prop );   <span class="keywordflow">break</span>;
<a name="l04276"></a>04276   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::INTER</a>: _INTER_cuts( pFP, pres, plop, prop ); <span class="keywordflow">break</span>;
<a name="l04277"></a>04277   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MINF</a>:  _MINF_cuts( pFP, pres, plop, prop );  <span class="keywordflow">break</span>;
<a name="l04278"></a>04278   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAXF</a>:  _MAXF_cuts( pFP, pres, plop, prop );  <span class="keywordflow">break</span>;
<a name="l04279"></a>04279   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::BILIN</a>: _BILIN_cuts( pFP, pres, plop, prop ); <span class="keywordflow">break</span>;
<a name="l04280"></a>04280 
<a name="l04281"></a>04281   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EXP</a>:   _EXP_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04282"></a>04282   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LOG</a>:   _LOG_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04283"></a>04283   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SQR</a>:   _SQR_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04284"></a>04284   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SQRT</a>:  _SQRT_cuts( pFP, pres, plop );        <span class="keywordflow">break</span>;
<a name="l04285"></a>04285   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::FABS</a>:  _FABS_cuts( pFP, pres, plop );        <span class="keywordflow">break</span>;
<a name="l04286"></a>04286   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::IPOW</a>:  _IPOW_cuts( pFP, pres, plop, prop );  <span class="keywordflow">break</span>;
<a name="l04287"></a>04287   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::ASIN</a>:  _ASIN_cuts( pFP, pres, plop );        <span class="keywordflow">break</span>;
<a name="l04288"></a>04288   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::COS</a>:   _COS_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04289"></a>04289   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::ATAN</a>:  _ATAN_cuts( pFP, pres, plop );        <span class="keywordflow">break</span>;
<a name="l04290"></a>04290   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TAN</a>:   _TAN_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04291"></a>04291   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::ERF</a>:   _ERF_cuts( pFP, pres, plop );         <span class="keywordflow">break</span>;
<a name="l04292"></a>04292   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::FSTEP</a>: _FSTEP_cuts( pFP, pres, plop );       <span class="keywordflow">break</span>;
<a name="l04293"></a>04293 
<a name="l04294"></a>04294   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::CNST</a>:
<a name="l04295"></a>04295   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::RANGE</a>:
<a name="l04296"></a>04296   <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::VAR</a>:
<a name="l04297"></a>04297   <span class="keywordflow">case</span> FPOp&lt;T&gt;::MC:
<a name="l04298"></a>04298   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TM:
<a name="l04299"></a>04299   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TMMC:  <span class="keywordflow">break</span>;
<a name="l04300"></a>04300 
<a name="l04301"></a>04301   <span class="keywordflow">default</span>:
<a name="l04302"></a>04302     <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::UNDEF</a> );
<a name="l04303"></a>04303   }
<a name="l04304"></a>04304 }
<a name="l04305"></a>04305 
<a name="l04306"></a>04306 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04307"></a>04307 <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::_EQ_cuts</a>
<a name="l04308"></a>04308 ( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;</a>*pFP, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var1, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var2 )
<a name="l04309"></a>04309 {
<a name="l04310"></a>04310   <span class="keywordflow">if</span>( Var1-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> )
<a name="l04311"></a>04311     pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>( <span class="keyword">this</span>, <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::EQ</a>, Var1-&gt;<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().n, Var2-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1. );
<a name="l04312"></a>04312   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l04313"></a>04313     pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>( <span class="keyword">this</span>, <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::EQ</a>, Var1-&gt;<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().x, Var2-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1. );
<a name="l04314"></a>04314   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> )
<a name="l04315"></a>04315     pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>( <span class="keyword">this</span>, <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::EQ</a>, Var2-&gt;<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().n, Var1-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1. );
<a name="l04316"></a>04316   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l04317"></a>04317     pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>( <span class="keyword">this</span>, <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::EQ</a>, Var2-&gt;<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().x, Var1-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1. );
<a name="l04318"></a>04318   <span class="keywordflow">else</span> 
<a name="l04319"></a>04319     pFP-&gt;<a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">_append_cut</a>( <span class="keyword">this</span>, <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::EQ</a>, 0., Var1-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1., Var2-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), -1. );
<a name="l04320"></a>04320 }
<a name="l04321"></a>04321 
<a name="l04322"></a>04322 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04323"></a>04323 FPOp&lt;T&gt;::_LE_cuts
<a name="l04324"></a>04324 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1, <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04325"></a>04325 {
<a name="l04326"></a>04326   <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04327"></a>04327     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Var1-&gt;num().n, Var2-&gt;id(), 1. );
<a name="l04328"></a>04328   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04329"></a>04329     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Var1-&gt;num().x, Var2-&gt;id(), 1. );
<a name="l04330"></a>04330   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04331"></a>04331     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Var2-&gt;num().n, Var1-&gt;id(), 1. );
<a name="l04332"></a>04332   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04333"></a>04333     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Var2-&gt;num().x, Var1-&gt;id(), 1. );
<a name="l04334"></a>04334   <span class="keywordflow">else</span> 
<a name="l04335"></a>04335     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, 0., Var1-&gt;id(), 1., Var2-&gt;id(), -1. );
<a name="l04336"></a>04336 }
<a name="l04337"></a>04337 
<a name="l04338"></a>04338 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04339"></a>04339 FPOp&lt;T&gt;::_PLUS_cuts
<a name="l04340"></a>04340 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04341"></a>04341   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04342"></a>04342 {
<a name="l04343"></a>04343   <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04344"></a>04344     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var2-&gt;num().n, VarR-&gt;id(), 1.,
<a name="l04345"></a>04345       Var1-&gt;id(), -1. );
<a name="l04346"></a>04346   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04347"></a>04347     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var2-&gt;num().x, VarR-&gt;id(), 1.,
<a name="l04348"></a>04348       Var1-&gt;id(), -1. );
<a name="l04349"></a>04349   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04350"></a>04350     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var1-&gt;num().n, VarR-&gt;id(), 1.,
<a name="l04351"></a>04351       Var2-&gt;id(), -1. );
<a name="l04352"></a>04352   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04353"></a>04353     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var1-&gt;num().x, VarR-&gt;id(), 1.,
<a name="l04354"></a>04354       Var2-&gt;id(), -1. );
<a name="l04355"></a>04355   <span class="keywordflow">else</span>{
<a name="l04356"></a>04356     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var1-&gt;id(), -1.,
<a name="l04357"></a>04357       Var2-&gt;id(), -1. );
<a name="l04358"></a>04358   }
<a name="l04359"></a>04359 }
<a name="l04360"></a>04360 
<a name="l04361"></a>04361 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04362"></a>04362 FPOp&lt;T&gt;::_NEG_cuts
<a name="l04363"></a>04363 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1 )
<a name="l04364"></a>04364 {
<a name="l04365"></a>04365   <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04366"></a>04366     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, -Var1-&gt;num().n, VarR-&gt;id(), 1. );
<a name="l04367"></a>04367   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04368"></a>04368     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, -Var1-&gt;num().x, VarR-&gt;id(), 1. );
<a name="l04369"></a>04369   <span class="keywordflow">else</span>{
<a name="l04370"></a>04370     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var1-&gt;id(), 1. );
<a name="l04371"></a>04371   }
<a name="l04372"></a>04372 }
<a name="l04373"></a>04373 
<a name="l04374"></a>04374 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04375"></a>04375 FPOp&lt;T&gt;::_MINUS_cuts
<a name="l04376"></a>04376 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04377"></a>04377   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04378"></a>04378 {
<a name="l04379"></a>04379   <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04380"></a>04380     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, -Var2-&gt;num().n, VarR-&gt;id(), 1.,
<a name="l04381"></a>04381       Var1-&gt;id(), -1. );
<a name="l04382"></a>04382   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04383"></a>04383     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, -Var2-&gt;num().x, VarR-&gt;id(), 1.,
<a name="l04384"></a>04384       Var1-&gt;id(), -1. );
<a name="l04385"></a>04385   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04386"></a>04386     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var1-&gt;num().n, VarR-&gt;id(), 1.,
<a name="l04387"></a>04387       Var2-&gt;id(), 1. );
<a name="l04388"></a>04388   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04389"></a>04389     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var1-&gt;num().x, VarR-&gt;id(), 1.,
<a name="l04390"></a>04390       Var2-&gt;id(), 1. );
<a name="l04391"></a>04391   <span class="keywordflow">else</span>{
<a name="l04392"></a>04392     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var1-&gt;id(), -1.,
<a name="l04393"></a>04393       Var2-&gt;id(), 1. );
<a name="l04394"></a>04394   }
<a name="l04395"></a>04395 }
<a name="l04396"></a>04396 
<a name="l04397"></a>04397 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04398"></a>04398 FPOp&lt;T&gt;::_TIMES_cuts
<a name="l04399"></a>04399 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04400"></a>04400   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04401"></a>04401 {
<a name="l04402"></a>04402   <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04403"></a>04403     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var1-&gt;id(),
<a name="l04404"></a>04404       -Var2-&gt;num().n );
<a name="l04405"></a>04405   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04406"></a>04406     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var1-&gt;id(),
<a name="l04407"></a>04407       -Var2-&gt;num().x );
<a name="l04408"></a>04408   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04409"></a>04409     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var2-&gt;id(),
<a name="l04410"></a>04410       -Var1-&gt;num().n );
<a name="l04411"></a>04411   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04412"></a>04412     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var2-&gt;id(),
<a name="l04413"></a>04413       -Var1-&gt;num().x );
<a name="l04414"></a>04414   <span class="keywordflow">else</span>{
<a name="l04415"></a>04415     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04416"></a>04416       -Op&lt;T&gt;::u(Var1-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04417"></a>04417       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04418"></a>04418       Var2-&gt;id(), -Op&lt;T&gt;::u(Var1-&gt;num().I) );
<a name="l04419"></a>04419     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04420"></a>04420       -Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04421"></a>04421       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04422"></a>04422       Var2-&gt;id(), -Op&lt;T&gt;::l(Var1-&gt;num().I) );
<a name="l04423"></a>04423     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04424"></a>04424       -Op&lt;T&gt;::u(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04425"></a>04425       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04426"></a>04426       Var2-&gt;id(), -Op&lt;T&gt;::u(Var1-&gt;num().I) );
<a name="l04427"></a>04427     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04428"></a>04428       -Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04429"></a>04429       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04430"></a>04430       Var2-&gt;id(), -Op&lt;T&gt;::l(Var1-&gt;num().I) );
<a name="l04431"></a>04431   }
<a name="l04432"></a>04432 }
<a name="l04433"></a>04433 
<a name="l04434"></a>04434 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04435"></a>04435 FPOp&lt;T&gt;::_DIV_cuts
<a name="l04436"></a>04436 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04437"></a>04437   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04438"></a>04438 {
<a name="l04439"></a>04439   <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04440"></a>04440     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., VarR-&gt;id(),
<a name="l04441"></a>04441       -Var2-&gt;num().n );
<a name="l04442"></a>04442   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04443"></a>04443     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., VarR-&gt;id(),
<a name="l04444"></a>04444       -Var2-&gt;num().x );
<a name="l04445"></a>04445   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT ){
<a name="l04446"></a>04446     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Var1-&gt;num().n+Op&lt;T&gt;::u(VarR-&gt;num().I)
<a name="l04447"></a>04447       *Op&lt;T&gt;::u(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04448"></a>04448       Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l04449"></a>04449     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Var1-&gt;num().n+Op&lt;T&gt;::l(VarR-&gt;num().I)
<a name="l04450"></a>04450       *Op&lt;T&gt;::l(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04451"></a>04451       Op&lt;T&gt;::l(VarR-&gt;num().I) );
<a name="l04452"></a>04452     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Var1-&gt;num().n+Op&lt;T&gt;::u(VarR-&gt;num().I)
<a name="l04453"></a>04453       *Op&lt;T&gt;::l(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04454"></a>04454       Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l04455"></a>04455     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Var1-&gt;num().n+Op&lt;T&gt;::l(VarR-&gt;num().I)
<a name="l04456"></a>04456       *Op&lt;T&gt;::u(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04457"></a>04457       Op&lt;T&gt;::l(VarR-&gt;num().I) );
<a name="l04458"></a>04458   }
<a name="l04459"></a>04459   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ){
<a name="l04460"></a>04460     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Var1-&gt;num().x+Op&lt;T&gt;::u(VarR-&gt;num().I)
<a name="l04461"></a>04461       *Op&lt;T&gt;::u(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04462"></a>04462       Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l04463"></a>04463     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Var1-&gt;num().x+Op&lt;T&gt;::l(VarR-&gt;num().I)
<a name="l04464"></a>04464       *Op&lt;T&gt;::l(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04465"></a>04465       Op&lt;T&gt;::l(VarR-&gt;num().I) );
<a name="l04466"></a>04466     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Var1-&gt;num().x+Op&lt;T&gt;::u(VarR-&gt;num().I)
<a name="l04467"></a>04467       *Op&lt;T&gt;::l(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04468"></a>04468       Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l04469"></a>04469     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Var1-&gt;num().x+Op&lt;T&gt;::l(VarR-&gt;num().I)
<a name="l04470"></a>04470       *Op&lt;T&gt;::u(Var2-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04471"></a>04471       Op&lt;T&gt;::l(VarR-&gt;num().I) );
<a name="l04472"></a>04472   }
<a name="l04473"></a>04473   <span class="keywordflow">else</span>{
<a name="l04474"></a>04474     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04475"></a>04475       -Op&lt;T&gt;::u(VarR-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I), Var1-&gt;id(), 1.,
<a name="l04476"></a>04476       VarR-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(), -Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l04477"></a>04477     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04478"></a>04478       -Op&lt;T&gt;::l(VarR-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I), Var1-&gt;id(), 1.,
<a name="l04479"></a>04479       VarR-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(), -Op&lt;T&gt;::l(VarR-&gt;num().I) );
<a name="l04480"></a>04480     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04481"></a>04481       -Op&lt;T&gt;::u(VarR-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I), Var1-&gt;id(), 1.,
<a name="l04482"></a>04482       VarR-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(), -Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l04483"></a>04483     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04484"></a>04484       -Op&lt;T&gt;::l(VarR-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I), Var1-&gt;id(), 1.,
<a name="l04485"></a>04485       VarR-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(), -Op&lt;T&gt;::l(VarR-&gt;num().I) );
<a name="l04486"></a>04486   }
<a name="l04487"></a>04487 }
<a name="l04488"></a>04488 
<a name="l04489"></a>04489 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04490"></a>04490 FPOp&lt;T&gt;::_MINF_cuts
<a name="l04491"></a>04491 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04492"></a>04492   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04493"></a>04493 {
<a name="l04494"></a>04494   <span class="comment">// Introduce auxiliary variables Var3, as the difference Var2-Var1</span>
<a name="l04495"></a>04495   FPVar&lt;T&gt;*Var3 = pFP-&gt;_auxiliary_variable( Var2-&gt;num().I-Var1-&gt;num().I, this );
<a name="l04496"></a>04496   _MINUS_cuts( pFP, Var3, Var2, Var1 );
<a name="l04497"></a>04497   <span class="comment">//pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), -1., Var2-&gt;id(), 1.,    </span>
<a name="l04498"></a>04498   <span class="comment">//  Var3-&gt;id(), -1. );</span>
<a name="l04499"></a>04499 
<a name="l04500"></a>04500   <span class="comment">// Introduce auxiliary variables Var4, as the absolute value of Var3</span>
<a name="l04501"></a>04501   FPVar&lt;T&gt;*Var4 = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::fabs(Var3-&gt;num().I), <span class="keyword">this</span> );
<a name="l04502"></a>04502   _FABS_cuts( pFP, Var4, Var3 );
<a name="l04503"></a>04503 
<a name="l04504"></a>04504   <span class="comment">// Introduce auxiliary variables Var5, as the sum Var1+Var2</span>
<a name="l04505"></a>04505   FPVar&lt;T&gt;*Var5 = pFP-&gt;_auxiliary_variable( Var1-&gt;num().I+Var2-&gt;num().I, this );
<a name="l04506"></a>04506   _PLUS_cuts( pFP, Var5, Var1, Var2 );
<a name="l04507"></a>04507 
<a name="l04508"></a>04508   <span class="comment">// Cuts</span>
<a name="l04509"></a>04509   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 2., Var4-&gt;id(), 1.,
<a name="l04510"></a>04510     Var5-&gt;id(), -1. );
<a name="l04511"></a>04511 <span class="comment">//   pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, 0., VarR-&gt;id(), 1., Var1-&gt;id(), -1. );</span>
<a name="l04512"></a>04512 <span class="comment">//   pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, 0., VarR-&gt;id(), 1., Var2-&gt;id(), -1. );</span>
<a name="l04513"></a>04513 }
<a name="l04514"></a>04514 
<a name="l04515"></a>04515 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04516"></a>04516 FPOp&lt;T&gt;::_MAXF_cuts
<a name="l04517"></a>04517 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04518"></a>04518   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04519"></a>04519 {
<a name="l04520"></a>04520   <span class="comment">// Introduce auxiliary variables Var3, as the difference Var1-Var2</span>
<a name="l04521"></a>04521   FPVar&lt;T&gt;*Var3 = pFP-&gt;_auxiliary_variable( Var1-&gt;num().I-Var2-&gt;num().I, this );
<a name="l04522"></a>04522   _MINUS_cuts( pFP, Var3, Var1, Var2 );
<a name="l04523"></a>04523   <span class="comment">//pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., Var2-&gt;id(), -1.,    </span>
<a name="l04524"></a>04524   <span class="comment">//  Var3-&gt;id(), -1. );</span>
<a name="l04525"></a>04525 
<a name="l04526"></a>04526   <span class="comment">// Introduce auxiliary variables Var4, as the absolute value of Var3</span>
<a name="l04527"></a>04527   FPVar&lt;T&gt;*Var4 = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::fabs(Var3-&gt;num().I), <span class="keyword">this</span> );
<a name="l04528"></a>04528   _FABS_cuts( pFP, Var4, Var3 );
<a name="l04529"></a>04529 
<a name="l04530"></a>04530   <span class="comment">// Introduce auxiliary variables Var5, as the sum Var1+Var2</span>
<a name="l04531"></a>04531   FPVar&lt;T&gt;*Var5 = pFP-&gt;_auxiliary_variable( Var1-&gt;num().I+Var2-&gt;num().I, this );
<a name="l04532"></a>04532   _PLUS_cuts( pFP, Var5, Var1, Var2 );
<a name="l04533"></a>04533 
<a name="l04534"></a>04534   <span class="comment">// Cuts</span>
<a name="l04535"></a>04535   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 2., Var4-&gt;id(), -1.,
<a name="l04536"></a>04536     Var5-&gt;id(), -1. );
<a name="l04537"></a>04537 <span class="comment">//   pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::GE, 0., VarR-&gt;id(), 1., Var1-&gt;id(), -1. );</span>
<a name="l04538"></a>04538 <span class="comment">//   pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::GE, 0., VarR-&gt;id(), 1., Var2-&gt;id(), -1. );</span>
<a name="l04539"></a>04539 }
<a name="l04540"></a>04540 
<a name="l04541"></a>04541 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04542"></a>04542 FPOp&lt;T&gt;::_INTER_cuts
<a name="l04543"></a>04543 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04544"></a>04544   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04545"></a>04545 {
<a name="l04546"></a>04546   <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04547"></a>04547     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var1-&gt;num().n, VarR-&gt;id(), 1. );
<a name="l04548"></a>04548   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var1-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04549"></a>04549     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var1-&gt;num().x, VarR-&gt;id(), 1. );
<a name="l04550"></a>04550   <span class="keywordflow">else</span> 
<a name="l04551"></a>04551     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var1-&gt;id(), -1. );
<a name="l04552"></a>04552 
<a name="l04553"></a>04553   <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l04554"></a>04554     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var2-&gt;num().n, VarR-&gt;id(), 1. );
<a name="l04555"></a>04555   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var2-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l04556"></a>04556     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, Var2-&gt;num().x, VarR-&gt;id(), 1. );
<a name="l04557"></a>04557   <span class="keywordflow">else</span> 
<a name="l04558"></a>04558     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1., Var2-&gt;id(), -1. );
<a name="l04559"></a>04559 }
<a name="l04560"></a>04560 
<a name="l04561"></a>04561 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04562"></a>04562 FPOp&lt;T&gt;::_BILIN_cuts
<a name="l04563"></a>04563 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var1,
<a name="l04564"></a>04564   <span class="keyword">const</span> FPVar&lt;T&gt;*Var2 )
<a name="l04565"></a>04565 {
<a name="l04566"></a>04566   <span class="keywordflow">if</span>( mc::isequal( Op&lt;T&gt;::diam(Var1-&gt;num().I), 0. )
<a name="l04567"></a>04567    || mc::isequal( Op&lt;T&gt;::diam(Var2-&gt;num().I), 0. ) )
<a name="l04568"></a>04568     <span class="keywordflow">return</span> _TIMES_cuts( pFP, VarR, Var1, Var2 );
<a name="l04569"></a>04569 
<a name="l04570"></a>04570   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv = pFP-&gt;options.BILINEAR_SUBDIV;
<a name="l04571"></a>04571 
<a name="l04572"></a>04572   <span class="comment">// Append more intermediate variables and corresponding semi-linear cuts</span>
<a name="l04573"></a>04573   <span class="keywordtype">double</span>*a = <span class="keyword">new</span> <span class="keywordtype">double</span>[Ndiv+3];
<a name="l04574"></a>04574   <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar*<span class="keywordtype">id</span> = <span class="keyword">new</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar[Ndiv+3];
<a name="l04575"></a>04575 
<a name="l04576"></a>04576   <span class="keywordflow">switch</span>( pFP-&gt;options.BILINEAR_RULE ){
<a name="l04577"></a>04577    <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76a54a2202f690db21dce49a3b14712bf03" title="Bisection along the first variable in bilinear term.">FPRelax&lt;T&gt;::Options::UNIVARIATE</a>:{
<a name="l04578"></a>04578 
<a name="l04579"></a>04579     FPVar&lt;T&gt;**dVar1 = _subdivide( pFP, Var1, Ndiv, a, <span class="keywordtype">id</span> );
<a name="l04580"></a>04580     FPVar&lt;T&gt;**dVarR = <span class="keyword">new</span> FPVar&lt;T&gt;*[Ndiv];
<a name="l04581"></a>04581     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv; idiv++ ){
<a name="l04582"></a>04582       dVarR[idiv] = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::zeroone()
<a name="l04583"></a>04583         *Op&lt;T&gt;::diam(Var2-&gt;num().I), <span class="keyword">this</span> );
<a name="l04584"></a>04584       a[idiv]  = Op&lt;T&gt;::diam(Var1-&gt;num().I)/(<span class="keywordtype">double</span>)Ndiv;
<a name="l04585"></a>04585       <span class="keywordtype">id</span>[idiv] = dVarR[idiv]-&gt;<span class="keywordtype">id</span>();
<a name="l04586"></a>04586       pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::GE, -Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04587"></a>04587         dVarR[idiv]-&gt;<span class="keywordtype">id</span>(), 1., dVar1[idiv]-&gt;<span class="keywordtype">id</span>(), -Op&lt;T&gt;::diam(Var2-&gt;num().I),
<a name="l04588"></a>04588         Var2-&gt;<span class="keywordtype">id</span>(), -1. );
<a name="l04589"></a>04589       pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, 0., dVarR[idiv]-&gt;<span class="keywordtype">id</span>(), 1.,
<a name="l04590"></a>04590         dVar1[idiv]-&gt;<span class="keywordtype">id</span>(), -Op&lt;T&gt;::diam(Var2-&gt;num().I) );
<a name="l04591"></a>04591       if( !idiv )
<a name="l04592"></a>04592         pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, -Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04593"></a>04593           dVarR[idiv]-&gt;<span class="keywordtype">id</span>(), 1., Var2-&gt;<span class="keywordtype">id</span>(), -1. );
<a name="l04594"></a>04594       else
<a name="l04595"></a>04595         pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, 0., dVarR[idiv]-&gt;<span class="keywordtype">id</span>(), 1.,
<a name="l04596"></a>04596           dVarR[idiv-1]-&gt;<span class="keywordtype">id</span>(), -1. );
<a name="l04597"></a>04597     }
<a name="l04598"></a>04598     a[Ndiv]  = -1.;
<a name="l04599"></a>04599     <span class="keywordtype">id</span>[Ndiv] = VarR-&gt;<span class="keywordtype">id</span>();
<a name="l04600"></a>04600     a[Ndiv+1]  = Op&lt;T&gt;::l(Var2-&gt;num().I);
<a name="l04601"></a>04601     <span class="keywordtype">id</span>[Ndiv+1] = Var1-&gt;<span class="keywordtype">id</span>();
<a name="l04602"></a>04602     a[Ndiv+2]  = Op&lt;T&gt;::l(Var1-&gt;num().I);
<a name="l04603"></a>04603     <span class="keywordtype">id</span>[Ndiv+2] = Var2-&gt;<span class="keywordtype">id</span>();
<a name="l04604"></a>04604     pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::EQ,
<a name="l04605"></a>04605       Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I), Ndiv+3, <span class="keywordtype">id</span>, a );
<a name="l04606"></a>04606 
<a name="l04607"></a>04607     delete [] dVar1;
<a name="l04608"></a>04608     delete [] dVarR;
<a name="l04609"></a>04609     break;
<a name="l04610"></a>04610    }
<a name="l04611"></a>04611 
<a name="l04612"></a>04612    case FPRelax&lt;T&gt;::Options::SEPARABLE:{
<a name="l04613"></a>04613 
<a name="l04614"></a>04614     <span class="comment">// Introduce auxiliary variables Var3 and Var4, and subdivide them</span>
<a name="l04615"></a>04615 <span class="preprocessor">#ifdef MC__FPRELAX_SCALE_SEPARABLE</span>
<a name="l04616"></a>04616 <span class="preprocessor"></span>    FPVar&lt;T&gt;*Var3 = pFP-&gt;_auxiliary_variable(
<a name="l04617"></a>04617       0.5*(Var1-&gt;num().I/Op&lt;T&gt;::diam(Var1-&gt;num().I)
<a name="l04618"></a>04618       +Var2-&gt;num().I/Op&lt;T&gt;::diam(Var2-&gt;num().I)), this );
<a name="l04619"></a>04619     FPVar&lt;T&gt;*Var4 = pFP-&gt;_auxiliary_variable(
<a name="l04620"></a>04620       0.5*(Var1-&gt;num().I/Op&lt;T&gt;::diam(Var1-&gt;num().I)
<a name="l04621"></a>04621       -Var2-&gt;num().I/Op&lt;T&gt;::diam(Var2-&gt;num().I)), this );
<a name="l04622"></a>04622     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(),
<a name="l04623"></a>04623       1./Op&lt;T&gt;::diam(Var1-&gt;num().I), Var2-&gt;id(), 1./Op&lt;T&gt;::diam(Var2-&gt;num().I),
<a name="l04624"></a>04624       Var3-&gt;id(), -2. );
<a name="l04625"></a>04625     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(),
<a name="l04626"></a>04626       1./Op&lt;T&gt;::diam(Var1-&gt;num().I), Var2-&gt;id(), -1./Op&lt;T&gt;::diam(Var2-&gt;num().I),
<a name="l04627"></a>04627       Var4-&gt;id(), -2. );
<a name="l04628"></a>04628 <span class="preprocessor">#else</span>
<a name="l04629"></a>04629 <span class="preprocessor"></span>    FPVar&lt;T&gt;*Var3 = pFP-&gt;_auxiliary_variable( 0.5*(Var1-&gt;num().I+Var2-&gt;num().I), <span class="keyword">this</span> );
<a name="l04630"></a>04630     FPVar&lt;T&gt;*Var4 = pFP-&gt;_auxiliary_variable( 0.5*(Var1-&gt;num().I-Var2-&gt;num().I), <span class="keyword">this</span> );
<a name="l04631"></a>04631     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., Var2-&gt;id(), 1.,
<a name="l04632"></a>04632       Var3-&gt;id(), -2. );
<a name="l04633"></a>04633     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., Var2-&gt;id(), -1.,
<a name="l04634"></a>04634       Var4-&gt;id(), -2. );    
<a name="l04635"></a>04635 <span class="preprocessor">#endif</span>
<a name="l04636"></a>04636 <span class="preprocessor"></span>    FPVar&lt;T&gt;**dVar3 = _subdivide( pFP, Var3, Ndiv, a, <span class="keywordtype">id</span> );
<a name="l04637"></a>04637     FPVar&lt;T&gt;**dVar4 = _subdivide( pFP, Var4, Ndiv, a, <span class="keywordtype">id</span> );
<a name="l04638"></a>04638 
<a name="l04639"></a>04639     <span class="comment">// Introduce auxiliary variables Var5 and Var6, as the squares of Var3</span>
<a name="l04640"></a>04640     <span class="comment">// and Var4, and append corresponding cuts</span>
<a name="l04641"></a>04641     FPVar&lt;T&gt;*Var5 = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::sqr(Var3-&gt;num().I), <span class="keyword">this</span> );
<a name="l04642"></a>04642     FPVar&lt;T&gt;*Var6 = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::sqr(Var4-&gt;num().I), <span class="keyword">this</span> );
<a name="l04643"></a>04643 <span class="preprocessor">#ifdef MC__FPRELAX_SCALE_SEPARABLE</span>
<a name="l04644"></a>04644 <span class="preprocessor"></span>    pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var5-&gt;id(), 1., Var6-&gt;id(), -1.,
<a name="l04645"></a>04645       VarR-&gt;id(), -1./Op&lt;T&gt;::diam(Var1-&gt;num().I)/Op&lt;T&gt;::diam(Var2-&gt;num().I) );
<a name="l04646"></a>04646 <span class="preprocessor">#else</span>
<a name="l04647"></a>04647 <span class="preprocessor"></span>    pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var5-&gt;id(), 1., Var6-&gt;id(), -1.,
<a name="l04648"></a>04648       VarR-&gt;id(), -1. );
<a name="l04649"></a>04649 <span class="preprocessor">#endif</span>
<a name="l04650"></a>04650 <span class="preprocessor"></span>
<a name="l04651"></a>04651     <span class="comment">// Append original McCormick cuts</span>
<a name="l04652"></a>04652     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04653"></a>04653       -Op&lt;T&gt;::u(Var1-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04654"></a>04654       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04655"></a>04655       -Op&lt;T&gt;::u(Var1-&gt;num().I) );
<a name="l04656"></a>04656     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04657"></a>04657       -Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04658"></a>04658       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04659"></a>04659       -Op&lt;T&gt;::l(Var1-&gt;num().I) );
<a name="l04660"></a>04660     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04661"></a>04661       -Op&lt;T&gt;::u(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04662"></a>04662       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04663"></a>04663       -Op&lt;T&gt;::u(Var1-&gt;num().I) );
<a name="l04664"></a>04664     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04665"></a>04665       -Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04666"></a>04666       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04667"></a>04667       -Op&lt;T&gt;::l(Var1-&gt;num().I) );
<a name="l04668"></a>04668 
<a name="l04669"></a>04669     <span class="comment">// Append outer-approximation cuts for Var5 and Var6</span>
<a name="l04670"></a>04670     <span class="keyword">struct </span>dloc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; sqr
<a name="l04671"></a>04671       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l04672"></a>04672       { <span class="keywordflow">return</span> std::make_pair( mc::sqr(x), 2.*x ); }
<a name="l04673"></a>04673     };
<a name="l04674"></a>04674     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l04675"></a>04675     void (FPOp&lt;T&gt;::*paddcut_sqrcv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l04676"></a>04676       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l04677"></a>04677       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_sqrcv;
<a name="l04678"></a>04678     _sandwich_cuts( pFP, Var3-&gt;id(), Op&lt;T&gt;::l(Var3-&gt;num().I),
<a name="l04679"></a>04679       Op&lt;T&gt;::u(Var3-&gt;num().I), Var5-&gt;id(), Op&lt;T&gt;::l(Var5-&gt;num().I),
<a name="l04680"></a>04680       Op&lt;T&gt;::u(Var5-&gt;num().I), paddcut_sqrcv, dloc::sqr );
<a name="l04681"></a>04681     _sandwich_cuts( pFP, Var4-&gt;id(), Op&lt;T&gt;::l(Var4-&gt;num().I),
<a name="l04682"></a>04682       Op&lt;T&gt;::u(Var4-&gt;num().I), Var6-&gt;id(), Op&lt;T&gt;::l(Var6-&gt;num().I),
<a name="l04683"></a>04683       Op&lt;T&gt;::u(Var6-&gt;num().I), paddcut_sqrcv, dloc::sqr );
<a name="l04684"></a>04684 
<a name="l04685"></a>04685     <span class="comment">// Append piecewise-affine cuts for Var5 and Var6</span>
<a name="l04686"></a>04686     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> <span class="keywordtype">double</span> sqr
<a name="l04687"></a>04687       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l04688"></a>04688       { <span class="keywordflow">return</span> mc::sqr(x); }
<a name="l04689"></a>04689     };
<a name="l04690"></a>04690     _semilinear_cut( pFP, Ndiv, Op&lt;T&gt;::l(Var3-&gt;num().I),
<a name="l04691"></a>04691       Op&lt;T&gt;::u(Var3-&gt;num().I), dVar3, Var5-&gt;id(), Op&lt;T&gt;::l(Var5-&gt;num().I),
<a name="l04692"></a>04692       Op&lt;T&gt;::u(Var5-&gt;num().I), loc::sqr );
<a name="l04693"></a>04693     _semilinear_cut( pFP, Ndiv, Op&lt;T&gt;::l(Var4-&gt;num().I),
<a name="l04694"></a>04694       Op&lt;T&gt;::u(Var4-&gt;num().I), dVar4, Var6-&gt;id(), Op&lt;T&gt;::l(Var6-&gt;num().I),
<a name="l04695"></a>04695       Op&lt;T&gt;::u(Var6-&gt;num().I), loc::sqr );
<a name="l04696"></a>04696 
<a name="l04697"></a>04697     <span class="keyword">delete</span> [] dVar3;
<a name="l04698"></a>04698     <span class="keyword">delete</span> [] dVar4;
<a name="l04699"></a>04699     <span class="keywordflow">break</span>;
<a name="l04700"></a>04700    }
<a name="l04701"></a>04701 
<a name="l04702"></a>04702    <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#a1bb3818779947edb46959342564b1e76aa124bbb8337e47858ded7db99484db23" title="Reformulation as separable terms before relaxation w/ SOS.">FPRelax&lt;T&gt;::Options::SEPARSOS</a>:{
<a name="l04703"></a>04703 
<a name="l04704"></a>04704     <span class="comment">// Introduce auxiliary variables Var3 and Var4, and subdivide them</span>
<a name="l04705"></a>04705 <span class="preprocessor">#ifdef MC__FPRELAX_SCALE_SEPARABLE</span>
<a name="l04706"></a>04706 <span class="preprocessor"></span>    FPVar&lt;T&gt;*Var3 = pFP-&gt;_auxiliary_variable(
<a name="l04707"></a>04707       0.5*(Var1-&gt;num().I/Op&lt;T&gt;::diam(Var1-&gt;num().I)
<a name="l04708"></a>04708       +Var2-&gt;num().I/Op&lt;T&gt;::diam(Var2-&gt;num().I)), this );
<a name="l04709"></a>04709     FPVar&lt;T&gt;*Var4 = pFP-&gt;_auxiliary_variable(
<a name="l04710"></a>04710       0.5*(Var1-&gt;num().I/Op&lt;T&gt;::diam(Var1-&gt;num().I)
<a name="l04711"></a>04711       -Var2-&gt;num().I/Op&lt;T&gt;::diam(Var2-&gt;num().I)), this );
<a name="l04712"></a>04712     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(),
<a name="l04713"></a>04713       1./Op&lt;T&gt;::diam(Var1-&gt;num().I), Var2-&gt;id(), 1./Op&lt;T&gt;::diam(Var2-&gt;num().I),
<a name="l04714"></a>04714       Var3-&gt;id(), -2. );
<a name="l04715"></a>04715     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(),
<a name="l04716"></a>04716       1./Op&lt;T&gt;::diam(Var1-&gt;num().I), Var2-&gt;id(), -1./Op&lt;T&gt;::diam(Var2-&gt;num().I),
<a name="l04717"></a>04717       Var4-&gt;id(), -2. );
<a name="l04718"></a>04718 <span class="preprocessor">#else</span>
<a name="l04719"></a>04719 <span class="preprocessor"></span>    FPVar&lt;T&gt;*Var3 = pFP-&gt;_auxiliary_variable(
<a name="l04720"></a>04720       0.5*(Var1-&gt;num().I+Var2-&gt;num().I), <span class="keyword">this</span> );
<a name="l04721"></a>04721     FPVar&lt;T&gt;*Var4 = pFP-&gt;_auxiliary_variable(
<a name="l04722"></a>04722       0.5*(Var1-&gt;num().I-Var2-&gt;num().I), <span class="keyword">this</span> );
<a name="l04723"></a>04723     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., Var2-&gt;id(), 1.,
<a name="l04724"></a>04724       Var3-&gt;id(), -2. );
<a name="l04725"></a>04725     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var1-&gt;id(), 1., Var2-&gt;id(), -1.,
<a name="l04726"></a>04726       Var4-&gt;id(), -2. );    
<a name="l04727"></a>04727 <span class="preprocessor">#endif</span>
<a name="l04728"></a>04728 <span class="preprocessor"></span>    FPVar&lt;T&gt;**dVar3 = _subdivide_SOS( pFP, Var3, Ndiv, a, <span class="keywordtype">id</span> );
<a name="l04729"></a>04729     FPVar&lt;T&gt;**dVar4 = _subdivide_SOS( pFP, Var4, Ndiv, a, <span class="keywordtype">id</span> );
<a name="l04730"></a>04730 
<a name="l04731"></a>04731     <span class="comment">// Introduce auxiliary variables Var5 and Var6, as the squares of Var3</span>
<a name="l04732"></a>04732     <span class="comment">// and Var4, and append corresponding cuts</span>
<a name="l04733"></a>04733     FPVar&lt;T&gt;*Var5 = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::sqr(Var3-&gt;num().I), <span class="keyword">this</span> );
<a name="l04734"></a>04734     FPVar&lt;T&gt;*Var6 = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::sqr(Var4-&gt;num().I), <span class="keyword">this</span> );
<a name="l04735"></a>04735 <span class="preprocessor">#ifdef MC__FPRELAX_SCALE_SEPARABLE</span>
<a name="l04736"></a>04736 <span class="preprocessor"></span>    pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var5-&gt;id(), 1., Var6-&gt;id(), -1.,
<a name="l04737"></a>04737       VarR-&gt;id(), -1./Op&lt;T&gt;::diam(Var1-&gt;num().I)/Op&lt;T&gt;::diam(Var2-&gt;num().I) );
<a name="l04738"></a>04738 <span class="preprocessor">#else</span>
<a name="l04739"></a>04739 <span class="preprocessor"></span>    pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Var5-&gt;id(), 1., Var6-&gt;id(), -1.,
<a name="l04740"></a>04740       VarR-&gt;id(), -1. );
<a name="l04741"></a>04741 <span class="preprocessor">#endif</span>
<a name="l04742"></a>04742 <span class="preprocessor"></span>
<a name="l04743"></a>04743     <span class="comment">// Append original McCormick cuts</span>
<a name="l04744"></a>04744     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04745"></a>04745       -Op&lt;T&gt;::u(Var1-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04746"></a>04746       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04747"></a>04747       -Op&lt;T&gt;::u(Var1-&gt;num().I) );
<a name="l04748"></a>04748     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE,
<a name="l04749"></a>04749       -Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04750"></a>04750       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04751"></a>04751       -Op&lt;T&gt;::l(Var1-&gt;num().I) );
<a name="l04752"></a>04752     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04753"></a>04753       -Op&lt;T&gt;::u(Var1-&gt;num().I)*Op&lt;T&gt;::l(Var2-&gt;num().I),
<a name="l04754"></a>04754       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::l(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04755"></a>04755       -Op&lt;T&gt;::u(Var1-&gt;num().I) );
<a name="l04756"></a>04756     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE,
<a name="l04757"></a>04757       -Op&lt;T&gt;::l(Var1-&gt;num().I)*Op&lt;T&gt;::u(Var2-&gt;num().I),
<a name="l04758"></a>04758       VarR-&gt;id(), 1., Var1-&gt;id(), -Op&lt;T&gt;::u(Var2-&gt;num().I), Var2-&gt;id(),
<a name="l04759"></a>04759       -Op&lt;T&gt;::l(Var1-&gt;num().I) );
<a name="l04760"></a>04760 
<a name="l04761"></a>04761     <span class="comment">// Append outer-approximation cuts for Var5 and Var6</span>
<a name="l04762"></a>04762     <span class="keyword">struct </span>dloc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; sqr
<a name="l04763"></a>04763       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l04764"></a>04764       { <span class="keywordflow">return</span> std::make_pair( mc::sqr(x), 2.*x ); }
<a name="l04765"></a>04765     };
<a name="l04766"></a>04766     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l04767"></a>04767     void (FPOp&lt;T&gt;::*paddcut_sqrcv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l04768"></a>04768       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l04769"></a>04769       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_sqrcv;
<a name="l04770"></a>04770     _sandwich_cuts( pFP, Var3-&gt;id(), Op&lt;T&gt;::l(Var3-&gt;num().I),
<a name="l04771"></a>04771       Op&lt;T&gt;::u(Var3-&gt;num().I), Var5-&gt;id(), Op&lt;T&gt;::l(Var5-&gt;num().I),
<a name="l04772"></a>04772       Op&lt;T&gt;::u(Var5-&gt;num().I), paddcut_sqrcv, dloc::sqr );
<a name="l04773"></a>04773     _sandwich_cuts( pFP, Var4-&gt;id(), Op&lt;T&gt;::l(Var4-&gt;num().I),
<a name="l04774"></a>04774       Op&lt;T&gt;::u(Var4-&gt;num().I), Var6-&gt;id(), Op&lt;T&gt;::l(Var6-&gt;num().I),
<a name="l04775"></a>04775       Op&lt;T&gt;::u(Var6-&gt;num().I), paddcut_sqrcv, dloc::sqr );
<a name="l04776"></a>04776 
<a name="l04777"></a>04777     <span class="comment">// Append piecewise-affine SOS cuts for Var5 and Var6</span>
<a name="l04778"></a>04778     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> <span class="keywordtype">double</span> sqr
<a name="l04779"></a>04779       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l04780"></a>04780       { <span class="keywordflow">return</span> mc::sqr(x); }
<a name="l04781"></a>04781     };
<a name="l04782"></a>04782     _semilinear_SOS( pFP, Ndiv, Op&lt;T&gt;::l(Var3-&gt;num().I),
<a name="l04783"></a>04783       Op&lt;T&gt;::u(Var3-&gt;num().I), dVar3, Var5-&gt;id(), Op&lt;T&gt;::l(Var5-&gt;num().I),
<a name="l04784"></a>04784       Op&lt;T&gt;::u(Var5-&gt;num().I), loc::sqr );
<a name="l04785"></a>04785     _semilinear_SOS( pFP, Ndiv, Op&lt;T&gt;::l(Var4-&gt;num().I),
<a name="l04786"></a>04786       Op&lt;T&gt;::u(Var4-&gt;num().I), dVar4, Var6-&gt;id(), Op&lt;T&gt;::l(Var6-&gt;num().I),
<a name="l04787"></a>04787       Op&lt;T&gt;::u(Var6-&gt;num().I), loc::sqr );
<a name="l04788"></a>04788 
<a name="l04789"></a>04789     <span class="keyword">delete</span> [] dVar3;
<a name="l04790"></a>04790     <span class="keyword">delete</span> [] dVar4;
<a name="l04791"></a>04791     <span class="keywordflow">break</span>;
<a name="l04792"></a>04792    }
<a name="l04793"></a>04793   }
<a name="l04794"></a>04794 
<a name="l04795"></a>04795   <span class="keyword">delete</span> [] a;
<a name="l04796"></a>04796   <span class="keyword">delete</span> [] id;
<a name="l04797"></a>04797 }
<a name="l04798"></a>04798 
<a name="l04799"></a>04799 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> FPVar&lt;T&gt;**
<a name="l04800"></a>04800 FPOp&lt;T&gt;::_subdivide
<a name="l04801"></a>04801 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*Var, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv, <span class="keywordtype">double</span>*a,
<a name="l04802"></a>04802   <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar*<span class="keywordtype">id</span> )
<a name="l04803"></a>04803 {
<a name="l04804"></a>04804   <span class="keyword">const</span> <span class="keywordtype">double</span> divVar = Op&lt;T&gt;::diam(Var-&gt;num().I)/(<span class="keywordtype">double</span>)Ndiv;
<a name="l04805"></a>04805   FPVar&lt;T&gt;**dVar = new FPVar&lt;T&gt;*[Ndiv];
<a name="l04806"></a>04806   for( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv; idiv++ ){
<a name="l04807"></a>04807     dVar[idiv] = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::zeroone(), <span class="keyword">this</span> );
<a name="l04808"></a>04808     a[idiv]  = divVar;
<a name="l04809"></a>04809     <span class="keywordtype">id</span>[idiv] = dVar[idiv]-&gt;id();
<a name="l04810"></a>04810   }
<a name="l04811"></a>04811   a[Ndiv]  = -1.;
<a name="l04812"></a>04812   <span class="keywordtype">id</span>[Ndiv] = Var-&gt;id();
<a name="l04813"></a>04813   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, -Op&lt;T&gt;::l(Var-&gt;num().I), Ndiv+1,
<a name="l04814"></a>04814     <span class="keywordtype">id</span>, a );
<a name="l04815"></a>04815 
<a name="l04816"></a>04816   FPVar&lt;T&gt;**bVar = <span class="keyword">new</span> FPVar&lt;T&gt;*[Ndiv-1];
<a name="l04817"></a>04817   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv-1; idiv++ ){
<a name="l04818"></a>04818     bVar[idiv] = pFP-&gt;_auxiliary_variable( <span class="keyword">this</span> );
<a name="l04819"></a>04819     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, 0., dVar[idiv]-&gt;<span class="keywordtype">id</span>(), 1.,
<a name="l04820"></a>04820                  bVar[idiv]-&gt;<span class="keywordtype">id</span>(), -1. );
<a name="l04821"></a>04821     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, 0., dVar[idiv+1]-&gt;<span class="keywordtype">id</span>(), 1.,
<a name="l04822"></a>04822                  bVar[idiv]-&gt;<span class="keywordtype">id</span>(), -1. );
<a name="l04823"></a>04823   }
<a name="l04824"></a>04824 
<a name="l04825"></a>04825   <span class="keyword">delete</span>[] bVar;
<a name="l04826"></a>04826   <span class="keywordflow">return</span> dVar;
<a name="l04827"></a>04827 }
<a name="l04828"></a>04828 
<a name="l04829"></a>04829 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04830"></a>04830 FPOp&lt;T&gt;::_semilinear_cut
<a name="l04831"></a>04831 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv, <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU,
<a name="l04832"></a>04832   FPVar&lt;T&gt;**dVarX, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l04833"></a>04833   <span class="keyword">const</span> <span class="keywordtype">double</span> YU, p_Univ f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l04834"></a>04834 {
<a name="l04835"></a>04835   <span class="keywordtype">double</span> a[Ndiv+1];
<a name="l04836"></a>04836   <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar <span class="keywordtype">id</span>[Ndiv+1];
<a name="l04837"></a>04837 
<a name="l04838"></a>04838   <span class="keyword">const</span> <span class="keywordtype">double</span> fL = f(XL,rpar,ipar);
<a name="l04839"></a>04839   <span class="keywordtype">double</span> Xi1 = XL, Fi1 = fL, Xi2, Fi2;
<a name="l04840"></a>04840   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv; idiv++ ){
<a name="l04841"></a>04841     Xi2 = ( idiv&lt;Ndiv-1? Xi1+(XU-XL)/(<span class="keywordtype">double</span>)Ndiv: XU );
<a name="l04842"></a>04842     Fi2 = f(Xi2,rpar,ipar);
<a name="l04843"></a>04843     a[idiv]  = Fi1-Fi2;
<a name="l04844"></a>04844     <span class="keywordtype">id</span>[idiv] = dVarX[idiv]-&gt;<span class="keywordtype">id</span>();
<a name="l04845"></a>04845     Xi1 = Xi2;
<a name="l04846"></a>04846     Fi1 = Fi2;
<a name="l04847"></a>04847   }
<a name="l04848"></a>04848   a[Ndiv]  = 1.;
<a name="l04849"></a>04849   <span class="keywordtype">id</span>[Ndiv] = iY;
<a name="l04850"></a>04850   pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, fL, Ndiv+1, <span class="keywordtype">id</span>, a );
<a name="l04851"></a>04851 }
<a name="l04852"></a>04852 
<a name="l04853"></a>04853 template &lt;typename T&gt; inline FPVar&lt;T&gt;**
<a name="l04854"></a>04854 FPOp&lt;T&gt;::_subdivide_SOS
<a name="l04855"></a>04855 ( FPRelax&lt;T&gt;*pFP, const FPVar&lt;T&gt;*Var, const <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv, <span class="keywordtype">double</span>*a,
<a name="l04856"></a>04856   typename FPVar&lt;T&gt;::pt_idVar*<span class="keywordtype">id</span> )
<a name="l04857"></a>04857 {
<a name="l04858"></a>04858   <span class="keyword">const</span> <span class="keywordtype">double</span> divVar = Op&lt;T&gt;::diam(Var-&gt;num().I)/(<span class="keywordtype">double</span>)Ndiv;
<a name="l04859"></a>04859   FPVar&lt;T&gt;**dVar = new FPVar&lt;T&gt;*[Ndiv+1];
<a name="l04860"></a>04860   for( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv+1; idiv++ ){
<a name="l04861"></a>04861     dVar[idiv] = pFP-&gt;_auxiliary_variable( Op&lt;T&gt;::zeroone(), <span class="keyword">this</span> );
<a name="l04862"></a>04862     a[idiv]  = 1.;
<a name="l04863"></a>04863     <span class="keywordtype">id</span>[idiv] = dVar[idiv]-&gt;id();
<a name="l04864"></a>04864   }
<a name="l04865"></a>04865   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::SOS2, 1., Ndiv+1, <span class="keywordtype">id</span>, a );
<a name="l04866"></a>04866 
<a name="l04867"></a>04867   <span class="keywordtype">double</span> Xi = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l04868"></a>04868   a[0]  = -Xi;
<a name="l04869"></a>04869   <span class="keywordtype">id</span>[0] = dVar[0]-&gt;id();
<a name="l04870"></a>04870   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv; idiv++ ){
<a name="l04871"></a>04871     Xi = ( idiv&lt;Ndiv-1? Xi+divVar: Op&lt;T&gt;::u(Var-&gt;num().I) );
<a name="l04872"></a>04872     a[idiv+1]  = -Xi;
<a name="l04873"></a>04873     <span class="keywordtype">id</span>[idiv+1] = dVar[idiv+1]-&gt;id();
<a name="l04874"></a>04874   }
<a name="l04875"></a>04875   a[Ndiv+1]  = 1.;
<a name="l04876"></a>04876   <span class="keywordtype">id</span>[Ndiv+1] = Var-&gt;id();
<a name="l04877"></a>04877   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., Ndiv+2, <span class="keywordtype">id</span>, a );
<a name="l04878"></a>04878 
<a name="l04879"></a>04879   <span class="keywordflow">return</span> dVar;
<a name="l04880"></a>04880 }
<a name="l04881"></a>04881 
<a name="l04882"></a>04882 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04883"></a>04883 FPOp&lt;T&gt;::_semilinear_SOS
<a name="l04884"></a>04884 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ndiv, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l04885"></a>04885   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, FPVar&lt;T&gt;**dVarX, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l04886"></a>04886   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, p_Univ f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l04887"></a>04887 {
<a name="l04888"></a>04888   <span class="keywordtype">double</span>*a = <span class="keyword">new</span> <span class="keywordtype">double</span>[Ndiv+2];
<a name="l04889"></a>04889   <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar*<span class="keywordtype">id</span> = <span class="keyword">new</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar[Ndiv+2];
<a name="l04890"></a>04890 
<a name="l04891"></a>04891   <span class="keywordtype">double</span> Xi = XL, Fi = f(XL,rpar,ipar);
<a name="l04892"></a>04892   a[0]  = -Fi;
<a name="l04893"></a>04893   <span class="keywordtype">id</span>[0] = dVarX[0]-&gt;id();
<a name="l04894"></a>04894   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idiv=0; idiv&lt;Ndiv; idiv++ ){
<a name="l04895"></a>04895     Xi = ( idiv&lt;Ndiv-1? Xi+(XU-XL)/(<span class="keywordtype">double</span>)Ndiv: XU );
<a name="l04896"></a>04896     Fi = f(Xi,rpar,ipar);
<a name="l04897"></a>04897     a[idiv+1]  = -Fi;
<a name="l04898"></a>04898     <span class="keywordtype">id</span>[idiv+1] = dVarX[idiv+1]-&gt;<span class="keywordtype">id</span>();
<a name="l04899"></a>04899   }
<a name="l04900"></a>04900   a[Ndiv+1]  = 1.;
<a name="l04901"></a>04901   <span class="keywordtype">id</span>[Ndiv+1] = iY;
<a name="l04902"></a>04902   pFP-&gt;_append_cut( this, FPCut&lt;T&gt;::LE, 0., Ndiv+2, <span class="keywordtype">id</span>, a );
<a name="l04903"></a>04903 
<a name="l04904"></a>04904   delete [] a;
<a name="l04905"></a>04905   delete [] <span class="keywordtype">id</span>;
<a name="l04906"></a>04906 }
<a name="l04907"></a>04907 
<a name="l04908"></a>04908 template &lt;typename T&gt; inline std::pair&lt; <span class="keywordtype">double</span>, <span class="keywordtype">double</span> &gt;
<a name="l04909"></a>04909 FPOp&lt;T&gt;::_distmax
<a name="l04910"></a>04910 ( const FPRelax&lt;T&gt;*pFP, p_dUniv f, const <span class="keywordtype">double</span> xL, const <span class="keywordtype">double</span> xU,
<a name="l04911"></a>04911   const <span class="keywordtype">double</span>*rpar, const <span class="keywordtype">int</span>*ipar )<span class="keyword"> const</span>
<a name="l04912"></a>04912 <span class="keyword"></span>{
<a name="l04913"></a>04913   std::pair&lt;double,double&gt; fL = f(xL,rpar,ipar), fU = f(xU,rpar,ipar);
<a name="l04914"></a>04914   <span class="keywordtype">double</span> Ddf = fU.second-fL.second,
<a name="l04915"></a>04915          Adf = std::max(std::fabs(fL.second),std::fabs(fU.second));
<a name="l04916"></a>04916 
<a name="l04917"></a>04917   <span class="keywordtype">double</span> xmid = 0.5 * ( xL + xU );
<a name="l04918"></a>04918   <span class="keywordtype">double</span> xmax = ( std::fabs(Ddf) - Adf*pFP-&gt;options.FRACTIONAL_RTOL
<a name="l04919"></a>04919     &gt; pFP-&gt;options.FRACTIONAL_ATOL?
<a name="l04920"></a>04920     ( fU.second * xU - fL.second * xL - fU.first + fL.first ) / Ddf: xmid );
<a name="l04921"></a>04921 <span class="comment">//   double xmax = ( std::fabs(Ddf) &lt; Adf*pFP-&gt;options.FRACTIONAL_RTOL</span>
<a name="l04922"></a>04922 <span class="comment">//     + pFP-&gt;options.FRACTIONAL_ATOL? xmid:</span>
<a name="l04923"></a>04923 <span class="comment">//     ( fU.second * xU - fL.second * xL - fU.first + fL.first ) / Ddf );</span>
<a name="l04924"></a>04924   std::pair&lt;double,double&gt; fmax = f(xmax,rpar,ipar);
<a name="l04925"></a>04925   <span class="keywordtype">double</span> dmax = std::fabs( fmax.first - fL.second * ( xmax - xL ) - fL.first );
<a name="l04926"></a>04926 
<a name="l04927"></a>04927   <span class="keywordflow">switch</span>( pFP-&gt;options.SANDWICH_RULE ){
<a name="l04928"></a>04928   <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a7df2113bf9806331b80e4ef543153332" title="Interval bisection.">FPRelax&lt;T&gt;::Options::BISECT</a>:
<a name="l04929"></a>04929     <span class="keywordflow">return</span> std::make_pair( xmid, dmax );
<a name="l04930"></a>04930   <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#ab7e547bf37585d5af072cc106292d846a78f6caf2e35acd8fc7333f69d12fef62" title="Maximum error rule.">FPRelax&lt;T&gt;::Options::MAXERR</a>: <span class="keywordflow">default</span>:
<a name="l04931"></a>04931     <span class="keywordflow">return</span> std::make_pair( xmax, dmax );
<a name="l04932"></a>04932   }
<a name="l04933"></a>04933 }
<a name="l04934"></a>04934 
<a name="l04935"></a>04935 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04936"></a>04936 FPOp&lt;T&gt;::_sandwich_cuts
<a name="l04937"></a>04937 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l04938"></a>04938   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l04939"></a>04939   <span class="keyword">const</span> <span class="keywordtype">double</span> YU, p_Cutpar Cut, p_dUniv f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l04940"></a>04940 {
<a name="l04941"></a>04941   <span class="comment">// Convex cuts @xL,xU</span>
<a name="l04942"></a>04942   (this-&gt;*Cut)( pFP, XL, iX, XL, XU, iY, YL, YU, rpar, ipar );
<a name="l04943"></a>04943   (this-&gt;*Cut)( pFP, XU, iX, XL, XU, iY, YL, YU, rpar, ipar );
<a name="l04944"></a>04944   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> NBCUTS = 2;
<a name="l04945"></a>04945   <span class="keyword">typename</span> FPOp&lt;T&gt;::t_Outer OA;
<a name="l04946"></a>04946   std::pair&lt;double,double&gt; worst = _distmax( pFP, f, XL, XU, rpar, ipar );
<a name="l04947"></a>04947   OA.push( FPOuter( XL, XU, worst.first, worst.second ) );
<a name="l04948"></a>04948   <span class="keyword">const</span> <span class="keywordtype">double</span> dtol = pFP-&gt;options.SANDWICH_ATOL
<a name="l04949"></a>04949     + pFP-&gt;options.SANDWICH_RTOL*std::max(std::fabs(YL),std::fabs(YU));
<a name="l04950"></a>04950 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_SANDWICH</span>
<a name="l04951"></a>04951 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">&quot;DTOL: &quot;</span> &lt;&lt; dtol &lt;&lt; std::endl;
<a name="l04952"></a>04952   std::cerr &lt;&lt; OA.top() &lt;&lt; std::endl;
<a name="l04953"></a>04953 <span class="preprocessor">#endif</span>
<a name="l04954"></a>04954 <span class="preprocessor"></span>
<a name="l04955"></a>04955   <span class="comment">// OA @xM</span>
<a name="l04956"></a>04956   <span class="keywordflow">while</span>( OA.top().gap() &gt; dtol &amp;&amp; NBCUTS &lt; pFP-&gt;options.SANDWICH_MAXCUT ){
<a name="l04957"></a>04957     <span class="comment">// x - y/exp(xref) &lt;= xref - 1, @xref=xmax</span>
<a name="l04958"></a>04958     (this-&gt;*Cut)( pFP, OA.top().xM(), iX, OA.top().xL(), OA.top().xU(),
<a name="l04959"></a>04959       iY, YL, YU, rpar, ipar );
<a name="l04960"></a>04960     NBCUTS++;
<a name="l04961"></a>04961     worst = _distmax( pFP, f, OA.top().xL(), OA.top().xM(), rpar, ipar );
<a name="l04962"></a>04962     OA.push( FPOuter( OA.top().xL(), OA.top().xM(), worst.first, worst.second ) );
<a name="l04963"></a>04963 <span class="preprocessor">#ifdef MC__FPOP_DEBUG_SANDWICH</span>
<a name="l04964"></a>04964 <span class="preprocessor"></span>    std::cerr &lt;&lt; <span class="stringliteral">&quot;  Pushed: &quot;</span>  &lt;&lt; FPOuter( OA.top().xL(), OA.top().xM(),
<a name="l04965"></a>04965       worst.first, worst.second ) &lt;&lt; std::endl;
<a name="l04966"></a>04966 <span class="preprocessor">#endif</span>
<a name="l04967"></a>04967 <span class="preprocessor"></span>    worst = _distmax( pFP, f, OA.top().xM(), OA.top().xU(), rpar, ipar );
<a name="l04968"></a>04968     OA.push( FPOuter( OA.top().xM(), OA.top().xU(), worst.first, worst.second ) );
<a name="l04969"></a>04969 <span class="preprocessor">#ifdef MC__FPOP_DEBUG_SANDWICH</span>
<a name="l04970"></a>04970 <span class="preprocessor"></span>    std::cerr &lt;&lt; <span class="stringliteral">&quot;  Pushed: &quot;</span> &lt;&lt; FPOuter( OA.top().xM(), OA.top().xU(),
<a name="l04971"></a>04971       worst.first, worst.second ) &lt;&lt; std::endl;
<a name="l04972"></a>04972 <span class="preprocessor">#endif</span>
<a name="l04973"></a>04973 <span class="preprocessor"></span>    OA.pop();
<a name="l04974"></a>04974 <span class="preprocessor">#ifdef MC__FPOP_DEBUG_SANDWICH</span>
<a name="l04975"></a>04975 <span class="preprocessor"></span>    std::cerr &lt;&lt; OA.top() &lt;&lt; std::endl;
<a name="l04976"></a>04976 <span class="preprocessor">#endif</span>
<a name="l04977"></a>04977 <span class="preprocessor"></span>  }
<a name="l04978"></a>04978 <span class="preprocessor">#ifdef MC__FPOP_DEBUG_SANDWICH</span>
<a name="l04979"></a>04979 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">&quot;NBCUTS: &quot;</span> &lt;&lt; NBCUTS &lt;&lt; std::endl;
<a name="l04980"></a>04980 <span class="preprocessor">#endif</span>
<a name="l04981"></a>04981 <span class="preprocessor"></span>}
<a name="l04982"></a>04982 
<a name="l04983"></a>04983 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">double</span>
<a name="l04984"></a>04984 FPOp&lt;T&gt;::_newton
<a name="l04985"></a>04985 ( <span class="keyword">const</span> FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> x0, <span class="keyword">const</span> <span class="keywordtype">double</span> xL,
<a name="l04986"></a>04986   <span class="keyword">const</span> <span class="keywordtype">double</span> xU, p_dUniv f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )<span class="keyword"> const </span>
<a name="l04987"></a>04987 <span class="keyword"></span>{
<a name="l04988"></a>04988   <span class="keywordtype">double</span> xk = std::max(xL,std::min(xU,x0)), dk;
<a name="l04989"></a>04989   std::pair&lt;double,double&gt; fk = f(xk,rusr,iusr);
<a name="l04990"></a>04990   
<a name="l04991"></a>04991   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> it=0; it&lt;pFP-&gt;options.NEWTON_MAXIT; it++ ){
<a name="l04992"></a>04992     <span class="keywordflow">if</span>( std::fabs(fk.first) &lt; pFP-&gt;options.NEWTON_TOL ) <span class="keywordflow">return</span> xk;
<a name="l04993"></a>04993     <span class="keywordflow">if</span>( fk.second == 0 )
<a name="l04994"></a>04994       <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284afbac358e613caff128304d4be781e620" title="Failure of Newton&#39;s method during the calculation of the convex or concave envelope of a univariate t...">FPRelax&lt;T&gt;::Exceptions::NEWTON</a> );
<a name="l04995"></a>04995     dk = fk.first/fk.second;
<a name="l04996"></a>04996     <span class="keywordflow">if</span>( mc::isequal(xk,xL) &amp;&amp; dk&gt;0 ) <span class="keywordflow">return</span> xk;
<a name="l04997"></a>04997     <span class="keywordflow">if</span>( mc::isequal(xk,xU) &amp;&amp; dk&lt;0 ) <span class="keywordflow">return</span> xk;
<a name="l04998"></a>04998     xk = std::max(xL,std::min(xU,xk-dk));
<a name="l04999"></a>04999     fk = f(xk,rusr,iusr);
<a name="l05000"></a>05000   }
<a name="l05001"></a>05001 
<a name="l05002"></a>05002   <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284afbac358e613caff128304d4be781e620" title="Failure of Newton&#39;s method during the calculation of the convex or concave envelope of a univariate t...">FPRelax&lt;T&gt;::Exceptions::NEWTON</a> );
<a name="l05003"></a>05003 }
<a name="l05004"></a>05004 
<a name="l05005"></a>05005 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">double</span>
<a name="l05006"></a>05006 FPOp&lt;T&gt;::_secant
<a name="l05007"></a>05007 ( <span class="keyword">const</span> FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> x0, <span class="keyword">const</span> <span class="keywordtype">double</span> x1, <span class="keyword">const</span> <span class="keywordtype">double</span> xL,
<a name="l05008"></a>05008   <span class="keyword">const</span> <span class="keywordtype">double</span> xU, p_Univ f, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )<span class="keyword"> const</span>
<a name="l05009"></a>05009 <span class="keyword"></span>{
<a name="l05010"></a>05010   <span class="keywordtype">double</span> xkm = std::max(xL,std::min(xU,x0));
<a name="l05011"></a>05011   <span class="keywordtype">double</span> fkm = f(xkm,rusr,iusr);
<a name="l05012"></a>05012   <span class="keywordtype">double</span> xk = std::max(xL,std::min(xU,x1));
<a name="l05013"></a>05013   
<a name="l05014"></a>05014   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> it=0; it&lt;pFP-&gt;options.NEWTON_MAXIT; it++ ){
<a name="l05015"></a>05015     <span class="keywordtype">double</span> fk = f(xk,rusr,iusr);
<a name="l05016"></a>05016     <span class="keywordflow">if</span>( std::fabs(fk) &lt; pFP-&gt;options.NEWTON_TOL ) <span class="keywordflow">return</span> xk;
<a name="l05017"></a>05017     <span class="keywordtype">double</span> Bk = (fk-fkm)/(xk-xkm);
<a name="l05018"></a>05018     <span class="keywordflow">if</span>( Bk == 0 )
<a name="l05019"></a>05019       <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284afbac358e613caff128304d4be781e620" title="Failure of Newton&#39;s method during the calculation of the convex or concave envelope of a univariate t...">FPRelax&lt;T&gt;::Exceptions::NEWTON</a> );
<a name="l05020"></a>05020     <span class="keywordflow">if</span>( isequal(xk,xL) &amp;&amp; fk/Bk&gt;0 ) <span class="keywordflow">return</span> xk;
<a name="l05021"></a>05021     <span class="keywordflow">if</span>( isequal(xk,xU) &amp;&amp; fk/Bk&lt;0 ) <span class="keywordflow">return</span> xk;
<a name="l05022"></a>05022     xkm = xk;
<a name="l05023"></a>05023     fkm = fk;
<a name="l05024"></a>05024     xk = std::max(xL,std::min(xU,xk-fk/Bk));
<a name="l05025"></a>05025   }
<a name="l05026"></a>05026 
<a name="l05027"></a>05027   <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284afbac358e613caff128304d4be781e620" title="Failure of Newton&#39;s method during the calculation of the convex or concave envelope of a univariate t...">FPRelax&lt;T&gt;::Exceptions::NEWTON</a> );
<a name="l05028"></a>05028 }
<a name="l05029"></a>05029 
<a name="l05030"></a>05030 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05031"></a>05031 FPOp&lt;T&gt;::_EXP_cuts
<a name="l05032"></a>05032 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05033"></a>05033 {
<a name="l05034"></a>05034   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05035"></a>05035     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::exp(Var-&gt;num().n),
<a name="l05036"></a>05036       VarR-&gt;id(), 1. );
<a name="l05037"></a>05037   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05038"></a>05038     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::exp(Var-&gt;num().x),
<a name="l05039"></a>05039       VarR-&gt;id(), 1. );
<a name="l05040"></a>05040   <span class="keywordflow">else</span>{
<a name="l05041"></a>05041     _addcut_expcc( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05042"></a>05042       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05043"></a>05043       Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l05044"></a>05044     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; exp
<a name="l05045"></a>05045       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05046"></a>05046       { <span class="keywordflow">return</span> std::make_pair( std::exp(x), std::exp(x) ); }
<a name="l05047"></a>05047     };
<a name="l05048"></a>05048     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05049"></a>05049     void (FPOp&lt;T&gt;::*paddcut_expcv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05050"></a>05050       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05051"></a>05051       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_expcv;
<a name="l05052"></a>05052     _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05053"></a>05053       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05054"></a>05054       Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_expcv, loc::exp );
<a name="l05055"></a>05055   }
<a name="l05056"></a>05056 }
<a name="l05057"></a>05057 
<a name="l05058"></a>05058 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05059"></a>05059 FPOp&lt;T&gt;::_LOG_cuts
<a name="l05060"></a>05060 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05061"></a>05061 {
<a name="l05062"></a>05062   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05063"></a>05063     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::log(Var-&gt;num().n),
<a name="l05064"></a>05064     VarR-&gt;id(), 1. );
<a name="l05065"></a>05065   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05066"></a>05066     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::log(Var-&gt;num().x),
<a name="l05067"></a>05067     VarR-&gt;id(), 1. );
<a name="l05068"></a>05068   <span class="keywordflow">else</span>{
<a name="l05069"></a>05069     _addcut_expcc( pFP, Var-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05070"></a>05070       Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05071"></a>05071       Op&lt;T&gt;::u(Var-&gt;num().I) );
<a name="l05072"></a>05072     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; exp
<a name="l05073"></a>05073       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05074"></a>05074       { <span class="keywordflow">return</span> std::make_pair( std::exp(x), std::exp(x) ); }
<a name="l05075"></a>05075     };
<a name="l05076"></a>05076     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05077"></a>05077     void (FPOp&lt;T&gt;::*paddcut_expcv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05078"></a>05078       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05079"></a>05079       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_expcv;
<a name="l05080"></a>05080     _sandwich_cuts( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05081"></a>05081       Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05082"></a>05082       Op&lt;T&gt;::u(Var-&gt;num().I), paddcut_expcv, loc::exp );
<a name="l05083"></a>05083   }
<a name="l05084"></a>05084 }
<a name="l05085"></a>05085 
<a name="l05086"></a>05086 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05087"></a>05087 FPOp&lt;T&gt;::_addcut_expcv
<a name="l05088"></a>05088 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05089"></a>05089   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05090"></a>05090   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05091"></a>05091 {
<a name="l05092"></a>05092   <span class="comment">// x - y*exp(-xref) &lt;= xref - 1</span>
<a name="l05093"></a>05093   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Xref-1., iY, -std::exp(-Xref),
<a name="l05094"></a>05094     iX, 1. );
<a name="l05095"></a>05095 }
<a name="l05096"></a>05096 
<a name="l05097"></a>05097 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05098"></a>05098 FPOp&lt;T&gt;::_addcut_expcc
<a name="l05099"></a>05099 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05100"></a>05100   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l05101"></a>05101   <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05102"></a>05102 {
<a name="l05103"></a>05103   <span class="comment">// dy*x - dx*y &gt;= dy*xL - dx*exp(xL)</span>
<a name="l05104"></a>05104   <span class="keywordtype">double</span> dX = XU - XL, dY = YU - YL;
<a name="l05105"></a>05105   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*std::exp(XL), iY, -dX,
<a name="l05106"></a>05106     iX, dY );
<a name="l05107"></a>05107 }
<a name="l05108"></a>05108 
<a name="l05109"></a>05109 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05110"></a>05110 FPOp&lt;T&gt;::_SQR_cuts
<a name="l05111"></a>05111 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05112"></a>05112 {
<a name="l05113"></a>05113   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05114"></a>05114     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, mc::sqr(Var-&gt;num().n),
<a name="l05115"></a>05115       VarR-&gt;id(), 1. );
<a name="l05116"></a>05116   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05117"></a>05117     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, mc::sqr(Var-&gt;num().x),
<a name="l05118"></a>05118       VarR-&gt;id(), 1. );
<a name="l05119"></a>05119   <span class="keywordflow">else</span>{
<a name="l05120"></a>05120     _addcut_sqrcc( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05121"></a>05121       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05122"></a>05122       Op&lt;T&gt;::u(VarR-&gt;num().I) );
<a name="l05123"></a>05123     <span class="keyword">struct </span>dloc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; sqr
<a name="l05124"></a>05124       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05125"></a>05125       { <span class="keywordflow">return</span> std::make_pair( mc::sqr(x), 2.*x ); }
<a name="l05126"></a>05126     };
<a name="l05127"></a>05127     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05128"></a>05128     void (FPOp&lt;T&gt;::*paddcut_sqrcv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05129"></a>05129       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05130"></a>05130       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_sqrcv;
<a name="l05131"></a>05131     _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05132"></a>05132       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05133"></a>05133       Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_sqrcv, dloc::sqr );
<a name="l05134"></a>05134   }
<a name="l05135"></a>05135 }
<a name="l05136"></a>05136 
<a name="l05137"></a>05137 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05138"></a>05138 FPOp&lt;T&gt;::_SQRT_cuts
<a name="l05139"></a>05139 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05140"></a>05140 {
<a name="l05141"></a>05141   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05142"></a>05142     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::sqrt(Var-&gt;num().n),
<a name="l05143"></a>05143       VarR-&gt;id(), 1. );
<a name="l05144"></a>05144   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05145"></a>05145     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::sqrt(Var-&gt;num().x),
<a name="l05146"></a>05146       VarR-&gt;id(), 1. );
<a name="l05147"></a>05147   <span class="keywordflow">else</span>{
<a name="l05148"></a>05148     _addcut_sqrcc( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05149"></a>05149       Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05150"></a>05150       Op&lt;T&gt;::u(Var-&gt;num().I) );
<a name="l05151"></a>05151     <span class="keyword">struct </span>dloc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; sqr
<a name="l05152"></a>05152       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05153"></a>05153       { <span class="keywordflow">return</span> std::make_pair( mc::sqr(x), 2.*x ); }
<a name="l05154"></a>05154     };
<a name="l05155"></a>05155     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05156"></a>05156     void (FPOp&lt;T&gt;::*paddcut_sqrcv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05157"></a>05157       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05158"></a>05158       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_sqrcv;
<a name="l05159"></a>05159     _sandwich_cuts( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05160"></a>05160       Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05161"></a>05161       Op&lt;T&gt;::u(Var-&gt;num().I), paddcut_sqrcv, dloc::sqr );
<a name="l05162"></a>05162   }
<a name="l05163"></a>05163 }
<a name="l05164"></a>05164 
<a name="l05165"></a>05165 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05166"></a>05166 FPOp&lt;T&gt;::_addcut_sqrcv
<a name="l05167"></a>05167 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05168"></a>05168   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05169"></a>05169   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05170"></a>05170 {
<a name="l05171"></a>05171   <span class="comment">// 2*xref*x - y &lt;= xref^2</span>
<a name="l05172"></a>05172   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, mc::sqr(Xref), iY, -1., iX, 2.*Xref );
<a name="l05173"></a>05173 }
<a name="l05174"></a>05174 
<a name="l05175"></a>05175 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05176"></a>05176 FPOp&lt;T&gt;::_addcut_sqrcc
<a name="l05177"></a>05177 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05178"></a>05178   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l05179"></a>05179   <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05180"></a>05180 {
<a name="l05181"></a>05181   <span class="comment">// (xL+xU)*x - y &gt;= xL*xU</span>
<a name="l05182"></a>05182   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, XL*XU, iY, -1., iX, XL+XU );
<a name="l05183"></a>05183 }
<a name="l05184"></a>05184 
<a name="l05185"></a>05185 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05186"></a>05186 FPOp&lt;T&gt;::_FABS_cuts
<a name="l05187"></a>05187 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05188"></a>05188 {
<a name="l05189"></a>05189   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05190"></a>05190     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::fabs(Var-&gt;num().n),
<a name="l05191"></a>05191       VarR-&gt;id(), 1. );
<a name="l05192"></a>05192   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05193"></a>05193     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::fabs(Var-&gt;num().x),
<a name="l05194"></a>05194       VarR-&gt;id(), 1. );
<a name="l05195"></a>05195   <span class="keywordflow">else</span>{
<a name="l05196"></a>05196     <span class="keywordtype">double</span> XL = Op&lt;T&gt;::l(Var-&gt;num().I), dX = Op&lt;T&gt;::u(Var-&gt;num().I)-XL,
<a name="l05197"></a>05197       YL = std::fabs(Op&lt;T&gt;::l(Var-&gt;num().I)),
<a name="l05198"></a>05198       dY = std::fabs(Op&lt;T&gt;::u(Var-&gt;num().I))-YL;
<a name="l05199"></a>05199     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*YL, VarR-&gt;id(), -dX,
<a name="l05200"></a>05200       Var-&gt;id(), dY );
<a name="l05201"></a>05201     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, 0., VarR-&gt;id(), 1., Var-&gt;id(), -1. );
<a name="l05202"></a>05202     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, 0., VarR-&gt;id(), 1., Var-&gt;id(), 1. );
<a name="l05203"></a>05203   }
<a name="l05204"></a>05204 }
<a name="l05205"></a>05205 
<a name="l05206"></a>05206 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05207"></a>05207 FPOp&lt;T&gt;::_FSTEP_cuts
<a name="l05208"></a>05208 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05209"></a>05209 {
<a name="l05210"></a>05210   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05211"></a>05211     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, mc::fstep(Var-&gt;num().n),
<a name="l05212"></a>05212       VarR-&gt;id(), 1. );
<a name="l05213"></a>05213   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05214"></a>05214     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, mc::fstep(Var-&gt;num().x),
<a name="l05215"></a>05215       VarR-&gt;id(), 1. );
<a name="l05216"></a>05216   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var-&gt;num().I) &gt;= 0. )
<a name="l05217"></a>05217     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 1., VarR-&gt;id(), 1. );    
<a name="l05218"></a>05218   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var-&gt;num().I) &lt; 0. )
<a name="l05219"></a>05219     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, 0., VarR-&gt;id(), 1. );    
<a name="l05220"></a>05220   <span class="keywordflow">else</span>{
<a name="l05221"></a>05221     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, 1., VarR-&gt;id(), 1. );    
<a name="l05222"></a>05222     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, 0., VarR-&gt;id(), 1. );    
<a name="l05223"></a>05223     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, 0., Var-&gt;id(), -1.,
<a name="l05224"></a>05224       VarR-&gt;id(), Op&lt;T&gt;::u(Var-&gt;num().I) );
<a name="l05225"></a>05225     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05226"></a>05226       Var-&gt;id(), 1., VarR-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I) );
<a name="l05227"></a>05227   }
<a name="l05228"></a>05228 }
<a name="l05229"></a>05229 
<a name="l05230"></a>05230 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05231"></a>05231 FPOp&lt;T&gt;::_IPOW_cuts
<a name="l05232"></a>05232 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var,
<a name="l05233"></a>05233   <span class="keyword">const</span> FPVar&lt;T&gt;*Exp )
<a name="l05234"></a>05234 {
<a name="l05235"></a>05235   <span class="keyword">const</span> <span class="keywordtype">int</span> iExp = Exp-&gt;num().n;
<a name="l05236"></a>05236   <span class="keywordflow">if</span>( iExp == 0 || iExp == 1 || iExp == 2 )
<a name="l05237"></a>05237     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a16924b8a3445bf87649086a3e17eaa06" title="Internal error.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l05238"></a>05238   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05239"></a>05239     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::pow(Var-&gt;num().n,iExp),
<a name="l05240"></a>05240       VarR-&gt;id(), 1. );
<a name="l05241"></a>05241   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05242"></a>05242     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::pow(Var-&gt;num().x,iExp),
<a name="l05243"></a>05243       VarR-&gt;id(), 1. );
<a name="l05244"></a>05244   <span class="keywordflow">else</span>{
<a name="l05245"></a>05245     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05246"></a>05246     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; pow
<a name="l05247"></a>05247       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05248"></a>05248       { <span class="keywordflow">return</span> std::make_pair( std::pow(x,*iusr), *iusr*std::pow(x,*iusr-1) ); }
<a name="l05249"></a>05249     };
<a name="l05250"></a>05250 
<a name="l05251"></a>05251     <span class="keywordflow">if</span>( iExp &gt; 0 &amp;&amp; !(iExp%2) ){
<a name="l05252"></a>05252       <span class="comment">// Append new linear cuts for power term w/ even exponent</span>
<a name="l05253"></a>05253       _addcut_powcc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05254"></a>05254         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05255"></a>05255       void (FPOp&lt;T&gt;::*paddcut_powcv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05256"></a>05256         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05257"></a>05257         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcv_lin;
<a name="l05258"></a>05258       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05259"></a>05259         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05260"></a>05260         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcv_lin, loc::pow, 0, &amp;iExp );
<a name="l05261"></a>05261     }
<a name="l05262"></a>05262 
<a name="l05263"></a>05263     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( iExp &gt; 0 &amp;&amp; pFP-&gt;options.NEWTON_USE ){
<a name="l05264"></a>05264       <span class="comment">// Append new linear cuts for power term w/ even exponent</span>
<a name="l05265"></a>05265       <span class="comment">// -- Convex Portion</span>
<a name="l05266"></a>05266       <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var-&gt;num().I) &gt;= 0. ){
<a name="l05267"></a>05267         _addcut_powcc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05268"></a>05268           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05269"></a>05269         void (FPOp&lt;T&gt;::*paddcut_powcv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05270"></a>05270           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05271"></a>05271           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcv_lin;
<a name="l05272"></a>05272         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05273"></a>05273           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05274"></a>05274           Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcv_lin, loc::pow, 0, &amp;iExp );
<a name="l05275"></a>05275       }
<a name="l05276"></a>05276 
<a name="l05277"></a>05277       <span class="comment">// -- Concave Portion</span>
<a name="l05278"></a>05278       <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var-&gt;num().I) &lt;= 0. ){
<a name="l05279"></a>05279         void (FPOp&lt;T&gt;::*paddcut_powcc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05280"></a>05280           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05281"></a>05281           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcc_lin;
<a name="l05282"></a>05282         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05283"></a>05283           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05284"></a>05284           Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcc_lin, loc::pow, 0, &amp;iExp );
<a name="l05285"></a>05285         _addcut_powcv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05286"></a>05286           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05287"></a>05287       }
<a name="l05288"></a>05288 
<a name="l05289"></a>05289       <span class="comment">// -- Nonconvex/Nonconcave Portion</span>
<a name="l05290"></a>05290       <span class="keywordflow">else</span>{
<a name="l05291"></a>05291         <span class="keyword">struct </span>fct{ <span class="keyword">static</span> std::pair&lt;double,double&gt; powoddfunc
<a name="l05292"></a>05292           ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05293"></a>05293           { <span class="keywordflow">return</span> std::make_pair(
<a name="l05294"></a>05294               ((*iusr-1)*x-(*iusr)*(*rusr))*std::pow(x,*iusr-1) + std::pow(*rusr,*iusr),
<a name="l05295"></a>05295               (*iusr)*(*iusr-1)*(x-(*rusr))*std::pow(x,*iusr-2) ); }
<a name="l05296"></a>05296         };
<a name="l05297"></a>05297         <span class="keywordtype">double</span> xJcc = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05298"></a>05298         xJcc = _newton( pFP, Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::l(Var-&gt;num().I), 0.,
<a name="l05299"></a>05299           fct::powoddfunc, &amp;xJcc, &amp;iExp );
<a name="l05300"></a>05300         <span class="keywordflow">if</span>( mc::isequal(xJcc,Op&lt;T&gt;::l(Var-&gt;num().I)) ){
<a name="l05301"></a>05301           _addcut_powcc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05302"></a>05302             Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05303"></a>05303         }
<a name="l05304"></a>05304         <span class="keywordflow">else</span>{
<a name="l05305"></a>05305           void (FPOp&lt;T&gt;::*paddcut_powcc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05306"></a>05306             <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05307"></a>05307             <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcc_lin;
<a name="l05308"></a>05308           _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), xJcc,
<a name="l05309"></a>05309             VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05310"></a>05310             Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcc_lin, loc::pow, &amp;xJcc, &amp;iExp );
<a name="l05311"></a>05311         }
<a name="l05312"></a>05312         <span class="keywordtype">double</span> xJcv = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05313"></a>05313         xJcv = _newton( pFP, Op&lt;T&gt;::u(Var-&gt;num().I), 0., Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05314"></a>05314           fct::powoddfunc, &amp;xJcv, &amp;iExp );
<a name="l05315"></a>05315         <span class="keywordflow">if</span>( mc::isequal(xJcv,Op&lt;T&gt;::u(Var-&gt;num().I)) ){
<a name="l05316"></a>05316           _addcut_powcv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05317"></a>05317           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05318"></a>05318         }
<a name="l05319"></a>05319         <span class="keywordflow">else</span>{
<a name="l05320"></a>05320           void (FPOp&lt;T&gt;::*paddcut_powcv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05321"></a>05321             <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05322"></a>05322             <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcv_lin;
<a name="l05323"></a>05323           _sandwich_cuts( pFP, Var-&gt;id(), xJcv, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05324"></a>05324             VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05325"></a>05325             Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcv_lin, loc::pow, &amp;xJcv, &amp;iExp );
<a name="l05326"></a>05326         }
<a name="l05327"></a>05327       }
<a name="l05328"></a>05328     }
<a name="l05329"></a>05329 
<a name="l05330"></a>05330     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( iExp &lt; 0 ){
<a name="l05331"></a>05331       <span class="comment">// Append new linear cuts for power term w/ negative exponent</span>
<a name="l05332"></a>05332       <span class="comment">// -- Convex Case</span>
<a name="l05333"></a>05333       <span class="keywordflow">if</span>( !(iExp%2) || Op&lt;T&gt;::l(Var-&gt;num().I) &gt; 0. ){
<a name="l05334"></a>05334         _addcut_powcc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05335"></a>05335           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05336"></a>05336         void (FPOp&lt;T&gt;::*paddcut_powcv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05337"></a>05337           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05338"></a>05338           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcv_lin;
<a name="l05339"></a>05339         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05340"></a>05340           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05341"></a>05341           Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcv_lin, loc::pow, 0, &amp;iExp );
<a name="l05342"></a>05342       }
<a name="l05343"></a>05343       <span class="comment">// -- Concave Case</span>
<a name="l05344"></a>05344       <span class="keywordflow">else</span>{
<a name="l05345"></a>05345         void (FPOp&lt;T&gt;::*paddcut_powcc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05346"></a>05346           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05347"></a>05347           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_powcc_lin;
<a name="l05348"></a>05348         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05349"></a>05349           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05350"></a>05350           Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_powcc_lin, loc::pow, 0, &amp;iExp );
<a name="l05351"></a>05351         _addcut_powcv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05352"></a>05352           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, &amp;iExp );
<a name="l05353"></a>05353       }
<a name="l05354"></a>05354     }
<a name="l05355"></a>05355 
<a name="l05356"></a>05356     <span class="keywordflow">else</span> <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a16924b8a3445bf87649086a3e17eaa06" title="Internal error.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l05357"></a>05357   }
<a name="l05358"></a>05358 }
<a name="l05359"></a>05359 
<a name="l05360"></a>05360 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05361"></a>05361 FPOp&lt;T&gt;::_addcut_powcv_lin
<a name="l05362"></a>05362 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05363"></a>05363   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05364"></a>05364   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp )
<a name="l05365"></a>05365 {
<a name="l05366"></a>05366   <span class="comment">// n*xref^(n-1)*x - y &lt;= (n-1)*xref^n</span>
<a name="l05367"></a>05367   <span class="keyword">const</span> <span class="keywordtype">double</span> a = std::pow(Xref,(*iExp)-1);
<a name="l05368"></a>05368   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, ((*iExp)-1)*a*Xref, iY, -1., iX,
<a name="l05369"></a>05369     (*iExp)*a );
<a name="l05370"></a>05370 }
<a name="l05371"></a>05371 
<a name="l05372"></a>05372 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05373"></a>05373 FPOp&lt;T&gt;::_addcut_powcc_lin
<a name="l05374"></a>05374 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05375"></a>05375   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05376"></a>05376   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp )
<a name="l05377"></a>05377 {
<a name="l05378"></a>05378   <span class="comment">// n*xref^(n-1)*x - y &gt;= (n-1)*xref^n</span>
<a name="l05379"></a>05379   <span class="keyword">const</span> <span class="keywordtype">double</span> a = std::pow(Xref,(*iExp)-1);
<a name="l05380"></a>05380   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, ((*iExp)-1)*a*Xref, iY, -1., iX,
<a name="l05381"></a>05381     (*iExp)*a );
<a name="l05382"></a>05382 }
<a name="l05383"></a>05383 
<a name="l05384"></a>05384 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05385"></a>05385 FPOp&lt;T&gt;::_addcut_powcv_sec
<a name="l05386"></a>05386 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05387"></a>05387   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l05388"></a>05388   <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp )
<a name="l05389"></a>05389 {
<a name="l05390"></a>05390   <span class="comment">// dy*x - dx*y &lt;= dy*xL - dx*yL</span>
<a name="l05391"></a>05391   <span class="keywordtype">double</span> dX = XU - XL, YL = std::pow(XL,*iExp), dY = std::pow(XU,*iExp) - YL;
<a name="l05392"></a>05392   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l05393"></a>05393 }
<a name="l05394"></a>05394 
<a name="l05395"></a>05395 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05396"></a>05396 FPOp&lt;T&gt;::_addcut_powcc_sec
<a name="l05397"></a>05397 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05398"></a>05398   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l05399"></a>05399   <span class="keyword">const</span> <span class="keywordtype">int</span>*iExp )
<a name="l05400"></a>05400 {
<a name="l05401"></a>05401   <span class="comment">// dy*x - dx*y &gt;= dy*xL - dx*yL</span>
<a name="l05402"></a>05402   <span class="keywordtype">double</span> dX = XU - XL, YL = std::pow(XL,*iExp), dY = std::pow(XU,*iExp) - YL;
<a name="l05403"></a>05403   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l05404"></a>05404 }
<a name="l05405"></a>05405 
<a name="l05406"></a>05406 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05407"></a>05407 FPOp&lt;T&gt;::_ASIN_cuts
<a name="l05408"></a>05408 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05409"></a>05409 {
<a name="l05410"></a>05410   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05411"></a>05411     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::asin(Var-&gt;num().n),
<a name="l05412"></a>05412       VarR-&gt;id(), 1. );
<a name="l05413"></a>05413   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05414"></a>05414     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::asin(Var-&gt;num().x),
<a name="l05415"></a>05415       VarR-&gt;id(), 1. );
<a name="l05416"></a>05416   <span class="keywordflow">else</span>{
<a name="l05417"></a>05417     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05418"></a>05418     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; asin
<a name="l05419"></a>05419       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05420"></a>05420       { <span class="keywordflow">return</span> std::make_pair( std::asin(x), 1./std::sqrt(1-mc::sqr(x)) ); }
<a name="l05421"></a>05421     };
<a name="l05422"></a>05422 
<a name="l05423"></a>05423     <span class="comment">// Append new linear cuts for asin univariate term</span>
<a name="l05424"></a>05424     <span class="comment">// -- Convex Portion</span>
<a name="l05425"></a>05425     <span class="keywordflow">if</span>(Op&lt;T&gt;::l(Var-&gt;num().I) &gt;= 0. ){
<a name="l05426"></a>05426       _addcut_asin1cc( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05427"></a>05427         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05428"></a>05428         Op&lt;T&gt;::u(VarR-&gt;num().I), 0, 0 );
<a name="l05429"></a>05429       void (FPOp&lt;T&gt;::*paddcut_asin1cv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05430"></a>05430         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05431"></a>05431         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_asin1cv;
<a name="l05432"></a>05432       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05433"></a>05433         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05434"></a>05434         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_asin1cv, loc::asin, 0, 0 );
<a name="l05435"></a>05435     }
<a name="l05436"></a>05436 
<a name="l05437"></a>05437     <span class="comment">// -- Concave Portion</span>
<a name="l05438"></a>05438     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(Op&lt;T&gt;::u(Var-&gt;num().I) &lt;= 0. ){
<a name="l05439"></a>05439       void (FPOp&lt;T&gt;::*paddcut_asin2cc)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05440"></a>05440         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05441"></a>05441         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_asin2cc;
<a name="l05442"></a>05442       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05443"></a>05443         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05444"></a>05444         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_asin2cc, loc::asin, 0, 0 );
<a name="l05445"></a>05445       _addcut_asin2cv( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05446"></a>05446         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05447"></a>05447         Op&lt;T&gt;::u(VarR-&gt;num().I), 0, 0 );
<a name="l05448"></a>05448     }
<a name="l05449"></a>05449 
<a name="l05450"></a>05450     <span class="comment">// -- Nonconvex/Nonconcave Portion (convex/cocnave envelopes)</span>
<a name="l05451"></a>05451     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( pFP-&gt;options.NEWTON_USE ){
<a name="l05452"></a>05452       <span class="keyword">struct </span>fct{ <span class="keyword">static</span> <span class="keywordtype">double</span> asinfunc
<a name="l05453"></a>05453         ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05454"></a>05454         { <span class="keywordflow">return</span> x-(*rusr)-std::sqrt(1.-x*x)*(std::asin(x)-std::asin(*rusr)); }
<a name="l05455"></a>05455       };
<a name="l05456"></a>05456       <span class="keywordtype">double</span> xJcc = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05457"></a>05457       xJcc = _secant( pFP, 0., Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05458"></a>05458         0., fct::asinfunc, &amp;xJcc, 0 );
<a name="l05459"></a>05459       <span class="keywordflow">if</span>( mc::isequal(xJcc,Op&lt;T&gt;::l(Var-&gt;num().I)) ){
<a name="l05460"></a>05460         _addcut_asin1cc( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05461"></a>05461           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05462"></a>05462           Op&lt;T&gt;::u(VarR-&gt;num().I), 0, 0 );
<a name="l05463"></a>05463       }
<a name="l05464"></a>05464       <span class="keywordflow">else</span>{
<a name="l05465"></a>05465         void (FPOp&lt;T&gt;::*paddcut_asin2cc)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05466"></a>05466           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05467"></a>05467           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_asin2cc;
<a name="l05468"></a>05468         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), xJcc,
<a name="l05469"></a>05469           VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05470"></a>05470           Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_asin2cc, loc::asin, &amp;xJcc, 0 );
<a name="l05471"></a>05471       }
<a name="l05472"></a>05472       <span class="keywordtype">double</span> xJcv = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05473"></a>05473       xJcv = _secant( pFP, 0., Op&lt;T&gt;::u(Var-&gt;num().I), 0., Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05474"></a>05474         fct::asinfunc, &amp;xJcv, 0 );
<a name="l05475"></a>05475       <span class="keywordflow">if</span>( mc::isequal(xJcv,Op&lt;T&gt;::u(Var-&gt;num().I)) ){
<a name="l05476"></a>05476         _addcut_asin2cv( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05477"></a>05477           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05478"></a>05478           Op&lt;T&gt;::u(VarR-&gt;num().I), 0, 0 );
<a name="l05479"></a>05479       }
<a name="l05480"></a>05480       <span class="keywordflow">else</span>{
<a name="l05481"></a>05481         void (FPOp&lt;T&gt;::*paddcut_asin1cv)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05482"></a>05482           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05483"></a>05483           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_asin1cv;
<a name="l05484"></a>05484         _sandwich_cuts( pFP, Var-&gt;id(), xJcv, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05485"></a>05485           VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05486"></a>05486           Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_asin1cv, loc::asin, &amp;xJcv, 0 );
<a name="l05487"></a>05487       }
<a name="l05488"></a>05488     }
<a name="l05489"></a>05489 
<a name="l05490"></a>05490     <span class="comment">// -- Nonconvex/Nonconcave Portion (cheap convex/concave relaxations)</span>
<a name="l05491"></a>05491     <span class="keywordflow">else</span>{
<a name="l05492"></a>05492       _addcut_asin3cc( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05493"></a>05493         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05494"></a>05494         Op&lt;T&gt;::u(VarR-&gt;num().I), 0, 0 );
<a name="l05495"></a>05495       _addcut_asin3cv( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05496"></a>05496         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05497"></a>05497         Op&lt;T&gt;::u(VarR-&gt;num().I), 0, 0 ); 
<a name="l05498"></a>05498     }
<a name="l05499"></a>05499   }
<a name="l05500"></a>05500 }
<a name="l05501"></a>05501 
<a name="l05502"></a>05502 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05503"></a>05503 FPOp&lt;T&gt;::_addcut_asin1cv
<a name="l05504"></a>05504 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05505"></a>05505   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05506"></a>05506   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05507"></a>05507 {
<a name="l05508"></a>05508   <span class="comment">// x - y*sqrt(1-xref^2) &lt;= xref - asin(xref)*sqrt(1-xref^2)</span>
<a name="l05509"></a>05509   <span class="keyword">const</span> <span class="keywordtype">double</span> a = -std::sqrt(1-mc::sqr(Xref));
<a name="l05510"></a>05510   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, Xref+std::asin(Xref)*a, iY, a, iX, 1. );
<a name="l05511"></a>05511 }
<a name="l05512"></a>05512 
<a name="l05513"></a>05513 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05514"></a>05514 FPOp&lt;T&gt;::_addcut_asin1cc
<a name="l05515"></a>05515 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05516"></a>05516   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l05517"></a>05517   <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05518"></a>05518 {
<a name="l05519"></a>05519   <span class="comment">// dy*x - dx*y &gt;= dy*xL - dx*asin(xL)</span>
<a name="l05520"></a>05520   <span class="keywordtype">double</span> dX = XU - XL, dY = YU - YL;
<a name="l05521"></a>05521   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*std::asin(XL), iY, -dX,
<a name="l05522"></a>05522     iX, dY );
<a name="l05523"></a>05523 }
<a name="l05524"></a>05524 
<a name="l05525"></a>05525 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05526"></a>05526 FPOp&lt;T&gt;::_addcut_asin2cc
<a name="l05527"></a>05527 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05528"></a>05528   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05529"></a>05529   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05530"></a>05530 {
<a name="l05531"></a>05531   <span class="comment">// x - y*sqrt(1-xref^2) &gt;= xref - asin(xref)*sqrt(1-xref^2)</span>
<a name="l05532"></a>05532   <span class="keyword">const</span> <span class="keywordtype">double</span> a = -std::sqrt(1-mc::sqr(Xref));
<a name="l05533"></a>05533   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, Xref+std::asin(Xref)*a, iY, a, iX, 1. );
<a name="l05534"></a>05534 }
<a name="l05535"></a>05535 
<a name="l05536"></a>05536 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05537"></a>05537 FPOp&lt;T&gt;::_addcut_asin2cv
<a name="l05538"></a>05538 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05539"></a>05539   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span> YL,
<a name="l05540"></a>05540   <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05541"></a>05541 {
<a name="l05542"></a>05542   <span class="comment">// dy*x - dx*y &lt;= dy*xL - dx*asin(xL)</span>
<a name="l05543"></a>05543   <span class="keywordtype">double</span> dX = XU - XL, dY = YU - YL;
<a name="l05544"></a>05544   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, dY*XL-dX*std::asin(XL), iY, -dX,
<a name="l05545"></a>05545     iX, dY );
<a name="l05546"></a>05546 }
<a name="l05547"></a>05547 
<a name="l05548"></a>05548 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05549"></a>05549 FPOp&lt;T&gt;::_addcut_asin3cc
<a name="l05550"></a>05550 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05551"></a>05551   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05552"></a>05552   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05553"></a>05553 {
<a name="l05554"></a>05554   <span class="comment">// x - y &gt;= xU - asin(xU)</span>
<a name="l05555"></a>05555   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, XU-std::asin(XU), iY, -1., iX, 1. );
<a name="l05556"></a>05556 }
<a name="l05557"></a>05557 
<a name="l05558"></a>05558 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05559"></a>05559 FPOp&lt;T&gt;::_addcut_asin3cv
<a name="l05560"></a>05560 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05561"></a>05561   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05562"></a>05562   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05563"></a>05563 {
<a name="l05564"></a>05564   <span class="comment">// x - y &lt;= xL - asin(xL)</span>
<a name="l05565"></a>05565   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, XL-std::asin(XL), iY, -1., iX, 1. );
<a name="l05566"></a>05566 }
<a name="l05567"></a>05567 
<a name="l05568"></a>05568 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05569"></a>05569 FPOp&lt;T&gt;::_COS_cuts
<a name="l05570"></a>05570 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05571"></a>05571 {
<a name="l05572"></a>05572   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT ){
<a name="l05573"></a>05573     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::sin(Var-&gt;num().n),
<a name="l05574"></a>05574       VarR-&gt;id(), 1. );
<a name="l05575"></a>05575     <span class="keywordflow">return</span>;
<a name="l05576"></a>05576   }
<a name="l05577"></a>05577   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL ){
<a name="l05578"></a>05578     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::sin(Var-&gt;num().x),
<a name="l05579"></a>05579       VarR-&gt;id(), 1. );
<a name="l05580"></a>05580     <span class="keywordflow">return</span>;
<a name="l05581"></a>05581   }
<a name="l05582"></a>05582 
<a name="l05583"></a>05583   <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05584"></a>05584   <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; cos
<a name="l05585"></a>05585     ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05586"></a>05586     { <span class="keywordflow">return</span> std::make_pair( std::cos(x), -std::sin(x) ); }
<a name="l05587"></a>05587   };
<a name="l05588"></a>05588   <span class="keyword">struct </span>fct{ <span class="keyword">static</span> std::pair&lt;double,double&gt; cosfunc
<a name="l05589"></a>05589     ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05590"></a>05590     { <span class="keywordflow">return</span> std::make_pair(
<a name="l05591"></a>05591         (x-*rusr)*std::sin(x)+std::cos(x)-std::cos(*rusr),
<a name="l05592"></a>05592         (x-*rusr)*std::cos(x) ); }
<a name="l05593"></a>05593   };
<a name="l05594"></a>05594   
<a name="l05595"></a>05595   <span class="comment">// Convex relaxation</span>
<a name="l05596"></a>05596   <span class="keywordtype">int</span> kL = std::ceil( -0.5*(1.+Op&lt;T&gt;::l(Var-&gt;num().I)/PI) );
<a name="l05597"></a>05597   <span class="keywordtype">double</span> dxL = 2.*PI*kL; 
<a name="l05598"></a>05598   <span class="keywordtype">double</span> xL1 = Op&lt;T&gt;::l(Var-&gt;num().I)+dxL, xU1 = Op&lt;T&gt;::u(Var-&gt;num().I)+dxL;
<a name="l05599"></a>05599   assert( xL1 &gt;= -PI &amp;&amp; xL1 &lt;= PI );
<a name="l05600"></a>05600  
<a name="l05601"></a>05601   <span class="keywordflow">if</span>( xU1 &gt;= PI ){
<a name="l05602"></a>05602     <span class="keyword">const</span> <span class="keywordtype">int</span> kU = std::ceil( -0.5*(1.+Op&lt;T&gt;::u(Var-&gt;num().I)/PI) );
<a name="l05603"></a>05603     <span class="keyword">const</span> <span class="keywordtype">double</span> dxU = 2.*PI*kU; 
<a name="l05604"></a>05604     <span class="keyword">const</span> <span class="keywordtype">double</span> xU2 = Op&lt;T&gt;::u(Var-&gt;num().I)+dxU;
<a name="l05605"></a>05605     assert( xU2 &gt;= -PI &amp;&amp; xU2 &lt;= PI );
<a name="l05606"></a>05606 
<a name="l05607"></a>05607     <span class="keywordtype">double</span> xJcv1 = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05608"></a>05608     <span class="keywordflow">if</span>( xL1 &lt;= PI/2. ) xJcv1 = _newton( pFP, PI-dxL,
<a name="l05609"></a>05609       Op&lt;T&gt;::l(Var-&gt;num().I), PI-dxL, fct::cosfunc, &amp;xJcv1, 0 );
<a name="l05610"></a>05610     <span class="keywordtype">double</span> xJcv2 = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05611"></a>05611     <span class="keywordflow">if</span>( xU2 &gt;= -PI/2. ) xJcv2 = _newton( pFP, -PI-dxU,
<a name="l05612"></a>05612       -PI-dxU, Op&lt;T&gt;::u(Var-&gt;num().I), fct::cosfunc, &amp;xJcv2, 0 ) ;
<a name="l05613"></a>05613 
<a name="l05614"></a>05614     void (FPOp&lt;T&gt;::*paddcut_coscv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05615"></a>05615       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05616"></a>05616       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscv_lin;
<a name="l05617"></a>05617     _sandwich_cuts( pFP, Var-&gt;id(), xJcv1, PI-dxL,
<a name="l05618"></a>05618       VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05619"></a>05619       paddcut_coscv_lin, loc::cos, 0, 0 );
<a name="l05620"></a>05620     _sandwich_cuts( pFP, Var-&gt;id(), -PI-dxU, xJcv2, 
<a name="l05621"></a>05621       VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05622"></a>05622       paddcut_coscv_lin, loc::cos, 0, 0 );        
<a name="l05623"></a>05623   }
<a name="l05624"></a>05624   
<a name="l05625"></a>05625   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( xL1 &gt;= PI/2. ){
<a name="l05626"></a>05626     void (FPOp&lt;T&gt;::*paddcut_coscv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05627"></a>05627       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05628"></a>05628       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscv_lin;
<a name="l05629"></a>05629     _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05630"></a>05630       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05631"></a>05631       Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_coscv_lin, loc::cos, 0, 0 );
<a name="l05632"></a>05632   }
<a name="l05633"></a>05633   
<a name="l05634"></a>05634   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( xL1 &gt;= -PI/2. &amp;&amp; xU1 &lt;= PI/2. ){
<a name="l05635"></a>05635     _addcut_coscv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05636"></a>05636       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05637"></a>05637   }
<a name="l05638"></a>05638   
<a name="l05639"></a>05639   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( xL1 &gt;= -PI/2. ){
<a name="l05640"></a>05640     <span class="keywordtype">double</span> xJcv1 = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05641"></a>05641     xJcv1 = _newton( pFP, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05642"></a>05642       Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::u(Var-&gt;num().I), fct::cosfunc, &amp;xJcv1, 0 );
<a name="l05643"></a>05643     <span class="keywordflow">if</span>( mc::isequal( xJcv1, Op&lt;T&gt;::u(Var-&gt;num().I) ) ){
<a name="l05644"></a>05644       _addcut_coscv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05645"></a>05645         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05646"></a>05646     }
<a name="l05647"></a>05647     <span class="keywordflow">else</span>{
<a name="l05648"></a>05648       void (FPOp&lt;T&gt;::*paddcut_coscv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05649"></a>05649         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05650"></a>05650         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscv_lin;
<a name="l05651"></a>05651       _sandwich_cuts( pFP, Var-&gt;id(), xJcv1, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05652"></a>05652         VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05653"></a>05653         paddcut_coscv_lin, loc::cos, 0, 0 );
<a name="l05654"></a>05654     }
<a name="l05655"></a>05655   }
<a name="l05656"></a>05656    
<a name="l05657"></a>05657   <span class="keywordflow">else</span>{
<a name="l05658"></a>05658     <span class="keywordtype">double</span> xJcv1 = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05659"></a>05659     xJcv1 = _newton( pFP, Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05660"></a>05660       Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::u(Var-&gt;num().I), fct::cosfunc, &amp;xJcv1, 0 );
<a name="l05661"></a>05661     <span class="keywordflow">if</span>( mc::isequal( xJcv1, Op&lt;T&gt;::l(Var-&gt;num().I) ) ){
<a name="l05662"></a>05662       _addcut_coscv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05663"></a>05663         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05664"></a>05664     }
<a name="l05665"></a>05665     <span class="keywordflow">else</span>{
<a name="l05666"></a>05666       void (FPOp&lt;T&gt;::*paddcut_coscv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05667"></a>05667         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05668"></a>05668         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscv_lin;
<a name="l05669"></a>05669       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), xJcv1,
<a name="l05670"></a>05670         VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05671"></a>05671         paddcut_coscv_lin, loc::cos, 0, 0 );
<a name="l05672"></a>05672     }
<a name="l05673"></a>05673   }
<a name="l05674"></a>05674   
<a name="l05675"></a>05675   <span class="comment">// Concave relaxation</span>
<a name="l05676"></a>05676   kL = std::ceil( -0.5*(2.+Op&lt;T&gt;::l(Var-&gt;num().I)/PI) );
<a name="l05677"></a>05677   dxL = 2.*PI*kL;
<a name="l05678"></a>05678   xL1 = Op&lt;T&gt;::l(Var-&gt;num().I)+dxL, xU1 = Op&lt;T&gt;::u(Var-&gt;num().I)+dxL;
<a name="l05679"></a>05679   assert( xL1 &gt;= -2.*PI &amp;&amp; xL1 &lt;= 0. );
<a name="l05680"></a>05680 
<a name="l05681"></a>05681   <span class="keywordflow">if</span>( xU1 &gt;= 0. ){
<a name="l05682"></a>05682     <span class="keyword">const</span> <span class="keywordtype">int</span> kU = std::ceil( -0.5*(2.+Op&lt;T&gt;::u(Var-&gt;num().I)/PI) );
<a name="l05683"></a>05683     <span class="keyword">const</span> <span class="keywordtype">double</span> dxU = 2.*PI*kU; 
<a name="l05684"></a>05684     <span class="keyword">const</span> <span class="keywordtype">double</span> xU2 = Op&lt;T&gt;::u(Var-&gt;num().I)+dxU;
<a name="l05685"></a>05685     assert( xU2 &gt;= -2.*PI &amp;&amp; xU2 &lt;= 0. );
<a name="l05686"></a>05686 
<a name="l05687"></a>05687     <span class="keywordtype">double</span> xJcc1 = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05688"></a>05688     <span class="keywordflow">if</span>( xL1 &lt;= -PI/2. ) xJcc1 = _newton( pFP, -dxL,
<a name="l05689"></a>05689       Op&lt;T&gt;::l(Var-&gt;num().I), -dxL, fct::cosfunc, &amp;xJcc1, 0 );
<a name="l05690"></a>05690     <span class="keywordtype">double</span> xJcc2 = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05691"></a>05691     <span class="keywordflow">if</span>( xU2 &gt;= -3.*PI/2. ) xJcc2 = _newton( pFP, -2.*PI-dxU,
<a name="l05692"></a>05692       -2.*PI-dxU, Op&lt;T&gt;::u(Var-&gt;num().I), fct::cosfunc, &amp;xJcc2, 0 );
<a name="l05693"></a>05693 
<a name="l05694"></a>05694     void (FPOp&lt;T&gt;::*paddcut_coscc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05695"></a>05695       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05696"></a>05696       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscc_lin;
<a name="l05697"></a>05697     _sandwich_cuts( pFP, Var-&gt;id(), xJcc1, -dxL,
<a name="l05698"></a>05698       VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05699"></a>05699       paddcut_coscc_lin, loc::cos, 0, 0 );
<a name="l05700"></a>05700     _sandwich_cuts( pFP, Var-&gt;id(), -2.*PI-dxU, xJcc2, 
<a name="l05701"></a>05701       VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05702"></a>05702       paddcut_coscc_lin, loc::cos, 0, 0 );   
<a name="l05703"></a>05703   }
<a name="l05704"></a>05704 
<a name="l05705"></a>05705   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( xL1 &gt;= -PI/2. ){
<a name="l05706"></a>05706     void (FPOp&lt;T&gt;::*paddcut_coscc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05707"></a>05707       <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05708"></a>05708       <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscc_lin;
<a name="l05709"></a>05709     _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05710"></a>05710       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05711"></a>05711       Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_coscc_lin, loc::cos, 0, 0 );
<a name="l05712"></a>05712   }
<a name="l05713"></a>05713   
<a name="l05714"></a>05714   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( xL1 &gt;= -3.*PI/2. &amp;&amp; xU1 &lt;= -PI/2. ){
<a name="l05715"></a>05715     _addcut_coscc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05716"></a>05716       Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05717"></a>05717   }
<a name="l05718"></a>05718   
<a name="l05719"></a>05719   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( xL1 &gt;= -3.*PI/2. ){
<a name="l05720"></a>05720     <span class="keywordtype">double</span> xJcc1 = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05721"></a>05721     xJcc1 = _newton( pFP, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05722"></a>05722       Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::u(Var-&gt;num().I), fct::cosfunc, &amp;xJcc1, 0 );
<a name="l05723"></a>05723     <span class="keywordflow">if</span>( mc::isequal( xJcc1, Op&lt;T&gt;::u(Var-&gt;num().I) ) ){
<a name="l05724"></a>05724       _addcut_coscc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05725"></a>05725         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05726"></a>05726     }
<a name="l05727"></a>05727     <span class="keywordflow">else</span>{
<a name="l05728"></a>05728       void (FPOp&lt;T&gt;::*paddcut_coscc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05729"></a>05729         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05730"></a>05730         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscc_lin;
<a name="l05731"></a>05731       _sandwich_cuts( pFP, Var-&gt;id(), xJcc1, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05732"></a>05732         VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05733"></a>05733         paddcut_coscc_lin, loc::cos, 0, 0 );
<a name="l05734"></a>05734     }
<a name="l05735"></a>05735   }
<a name="l05736"></a>05736    
<a name="l05737"></a>05737   <span class="keywordflow">else</span>{
<a name="l05738"></a>05738     <span class="keywordtype">double</span> xJcc1 = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05739"></a>05739     xJcc1 = _newton( pFP, Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05740"></a>05740       Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::u(Var-&gt;num().I), fct::cosfunc, &amp;xJcc1, 0 );
<a name="l05741"></a>05741     <span class="keywordflow">if</span>( mc::isequal( xJcc1, Op&lt;T&gt;::l(Var-&gt;num().I) ) ){
<a name="l05742"></a>05742       _addcut_coscc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05743"></a>05743         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05744"></a>05744     }
<a name="l05745"></a>05745     <span class="keywordflow">else</span>{
<a name="l05746"></a>05746       void (FPOp&lt;T&gt;::*paddcut_coscc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar,
<a name="l05747"></a>05747         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05748"></a>05748         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_coscc_lin;
<a name="l05749"></a>05749       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), xJcc1,
<a name="l05750"></a>05750         VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05751"></a>05751         paddcut_coscc_lin, loc::cos, 0, 0 );
<a name="l05752"></a>05752     }
<a name="l05753"></a>05753   }
<a name="l05754"></a>05754 }
<a name="l05755"></a>05755   
<a name="l05756"></a>05756 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05757"></a>05757 FPOp&lt;T&gt;::_addcut_coscv_lin
<a name="l05758"></a>05758 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05759"></a>05759   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05760"></a>05760   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05761"></a>05761 {
<a name="l05762"></a>05762   <span class="comment">// x*sin(xref) + y &gt;= cos(xref) + xref*sin(xref)</span>
<a name="l05763"></a>05763   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, std::cos(Xref)+Xref*std::sin(Xref),
<a name="l05764"></a>05764     iY, 1., iX, std::sin(Xref) );
<a name="l05765"></a>05765 }
<a name="l05766"></a>05766 
<a name="l05767"></a>05767 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05768"></a>05768 FPOp&lt;T&gt;::_addcut_coscc_lin
<a name="l05769"></a>05769 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05770"></a>05770   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05771"></a>05771   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05772"></a>05772 {
<a name="l05773"></a>05773   <span class="comment">// x*sin(xref) + y &lt;= cos(xref) + xref*sin(xref)</span>
<a name="l05774"></a>05774   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, std::cos(Xref)+Xref*std::sin(Xref),
<a name="l05775"></a>05775     iY, 1., iX, std::sin(Xref) );
<a name="l05776"></a>05776 }
<a name="l05777"></a>05777 
<a name="l05778"></a>05778 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05779"></a>05779 FPOp&lt;T&gt;::_addcut_coscv_sec
<a name="l05780"></a>05780 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05781"></a>05781   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l05782"></a>05782   <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05783"></a>05783 {
<a name="l05784"></a>05784   <span class="comment">// dy*x - dx*y &lt;= dy*xL - dx*yL</span>
<a name="l05785"></a>05785   <span class="keywordtype">double</span> dX = XU - XL, YL = std::cos(XL), dY = std::cos(XU) - YL;
<a name="l05786"></a>05786   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l05787"></a>05787 }
<a name="l05788"></a>05788 
<a name="l05789"></a>05789 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05790"></a>05790 FPOp&lt;T&gt;::_addcut_coscc_sec
<a name="l05791"></a>05791 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05792"></a>05792   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l05793"></a>05793   <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05794"></a>05794 {
<a name="l05795"></a>05795   <span class="comment">// dy*x - dx*y &gt;= dy*xL - dx*yL</span>
<a name="l05796"></a>05796   <span class="keywordtype">double</span> dX = XU - XL, YL = std::cos(XL), dY = std::cos(XU) - YL;
<a name="l05797"></a>05797   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l05798"></a>05798 }
<a name="l05799"></a>05799 
<a name="l05800"></a>05800 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05801"></a>05801 FPOp&lt;T&gt;::_ATAN_cuts
<a name="l05802"></a>05802 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05803"></a>05803 {
<a name="l05804"></a>05804   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05805"></a>05805     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::atan(Var-&gt;num().n),
<a name="l05806"></a>05806       VarR-&gt;id(), 1. );
<a name="l05807"></a>05807   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05808"></a>05808     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::atan(Var-&gt;num().x),
<a name="l05809"></a>05809       VarR-&gt;id(), 1. );
<a name="l05810"></a>05810   <span class="keywordflow">else</span>{
<a name="l05811"></a>05811     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05812"></a>05812     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; atan
<a name="l05813"></a>05813       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05814"></a>05814       { <span class="keywordflow">return</span> std::make_pair( std::atan(x), 1./(1.+x*x) ); }
<a name="l05815"></a>05815     };
<a name="l05816"></a>05816 
<a name="l05817"></a>05817     <span class="comment">// Append new linear cuts for univariate atan term</span>
<a name="l05818"></a>05818     <span class="comment">// -- Convex Portion</span>
<a name="l05819"></a>05819     <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var-&gt;num().I) &lt;= 0. ){
<a name="l05820"></a>05820       _addcut_atancc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05821"></a>05821         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05822"></a>05822       void (FPOp&lt;T&gt;::*paddcut_atancv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05823"></a>05823         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05824"></a>05824         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancv_lin;
<a name="l05825"></a>05825       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05826"></a>05826         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05827"></a>05827         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_atancv_lin, loc::atan, 0, 0 );
<a name="l05828"></a>05828     }
<a name="l05829"></a>05829 
<a name="l05830"></a>05830     <span class="comment">// -- Concave Portion</span>
<a name="l05831"></a>05831     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var-&gt;num().I) &gt;= 0. ){
<a name="l05832"></a>05832       void (FPOp&lt;T&gt;::*paddcut_atancc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05833"></a>05833         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05834"></a>05834         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancc_lin;
<a name="l05835"></a>05835       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05836"></a>05836         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05837"></a>05837         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_atancc_lin, loc::atan, 0, 0 );
<a name="l05838"></a>05838       _addcut_atancv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05839"></a>05839         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05840"></a>05840     }
<a name="l05841"></a>05841 
<a name="l05842"></a>05842     <span class="comment">// -- Concavo-convex Portion</span>
<a name="l05843"></a>05843     <span class="keywordflow">else</span>{
<a name="l05844"></a>05844       <span class="keyword">struct </span>fct{ <span class="keyword">static</span> std::pair&lt;double,double&gt; atanfunc
<a name="l05845"></a>05845         ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05846"></a>05846         { <span class="keywordflow">return</span> std::make_pair(
<a name="l05847"></a>05847             x-(*rusr)+(1+x*x)*(std::atan(*rusr)-std::atan(x)),
<a name="l05848"></a>05848             2*x*(std::atan(*rusr)-std::atan(x)) ); }
<a name="l05849"></a>05849       };
<a name="l05850"></a>05850 
<a name="l05851"></a>05851       <span class="keywordtype">double</span> xJcc = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l05852"></a>05852       xJcc = _newton( pFP, Op&lt;T&gt;::u(Var-&gt;num().I), 0., Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05853"></a>05853         fct::atanfunc, &amp;xJcc, 0 );
<a name="l05854"></a>05854       <span class="keywordflow">if</span>( mc::isequal( xJcc, Op&lt;T&gt;::u(Var-&gt;num().I) ) ){
<a name="l05855"></a>05855         _addcut_atancc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05856"></a>05856           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05857"></a>05857       }
<a name="l05858"></a>05858       <span class="keywordflow">else</span>{
<a name="l05859"></a>05859         void (FPOp&lt;T&gt;::*paddcut_atancc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05860"></a>05860           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05861"></a>05861           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancc_lin;
<a name="l05862"></a>05862         _sandwich_cuts( pFP, Var-&gt;id(), xJcc, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05863"></a>05863           VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05864"></a>05864           paddcut_atancc_lin, loc::atan, &amp;xJcc, 0 );
<a name="l05865"></a>05865       }
<a name="l05866"></a>05866 
<a name="l05867"></a>05867       <span class="keywordtype">double</span> xJcv = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l05868"></a>05868       xJcv = _newton( pFP, Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::l(Var-&gt;num().I), 0.,
<a name="l05869"></a>05869         fct::atanfunc, &amp;xJcv, 0 );
<a name="l05870"></a>05870       <span class="keywordflow">if</span>( mc::isequal(xJcv,Op&lt;T&gt;::l(Var-&gt;num().I)) ){
<a name="l05871"></a>05871         _addcut_atancv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05872"></a>05872         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l05873"></a>05873       }
<a name="l05874"></a>05874       <span class="keywordflow">else</span>{
<a name="l05875"></a>05875         void (FPOp&lt;T&gt;::*paddcut_atancv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05876"></a>05876           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05877"></a>05877           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancv_lin;
<a name="l05878"></a>05878         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), xJcv, 
<a name="l05879"></a>05879           VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05880"></a>05880           paddcut_atancv_lin, loc::atan, &amp;xJcv, 0 );
<a name="l05881"></a>05881       }
<a name="l05882"></a>05882     }
<a name="l05883"></a>05883   }
<a name="l05884"></a>05884 }
<a name="l05885"></a>05885 
<a name="l05886"></a>05886 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05887"></a>05887 FPOp&lt;T&gt;::_TAN_cuts
<a name="l05888"></a>05888 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l05889"></a>05889 {
<a name="l05890"></a>05890   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l05891"></a>05891     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::tan(Var-&gt;num().n),
<a name="l05892"></a>05892       VarR-&gt;id(), 1. );
<a name="l05893"></a>05893   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l05894"></a>05894     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, std::tan(Var-&gt;num().x),
<a name="l05895"></a>05895       VarR-&gt;id(), 1. );
<a name="l05896"></a>05896   <span class="keywordflow">else</span>{
<a name="l05897"></a>05897     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l05898"></a>05898     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; atan
<a name="l05899"></a>05899       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05900"></a>05900       { <span class="keywordflow">return</span> std::make_pair( std::atan(x), 1./(1.+x*x) ); }
<a name="l05901"></a>05901     };
<a name="l05902"></a>05902 
<a name="l05903"></a>05903     <span class="comment">// Append new linear cuts for univariate atan term</span>
<a name="l05904"></a>05904     <span class="comment">// -- Convex Portion</span>
<a name="l05905"></a>05905     <span class="keywordflow">if</span>( Op&lt;T&gt;::u(VarR-&gt;num().I) &lt;= 0. ){
<a name="l05906"></a>05906       _addcut_atancc_sec( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05907"></a>05907         Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), 0, 0 );
<a name="l05908"></a>05908       void (FPOp&lt;T&gt;::*paddcut_atancv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05909"></a>05909         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05910"></a>05910         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancv_lin;
<a name="l05911"></a>05911       _sandwich_cuts( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05912"></a>05912         Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05913"></a>05913         Op&lt;T&gt;::u(Var-&gt;num().I), paddcut_atancv_lin, loc::atan, 0, 0 );
<a name="l05914"></a>05914     }
<a name="l05915"></a>05915 
<a name="l05916"></a>05916     <span class="comment">// -- Concave Portion</span>
<a name="l05917"></a>05917     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::l(VarR-&gt;num().I) &gt;= 0. ){
<a name="l05918"></a>05918       void (FPOp&lt;T&gt;::*paddcut_atancc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05919"></a>05919         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05920"></a>05920         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancc_lin;
<a name="l05921"></a>05921       _sandwich_cuts( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05922"></a>05922         Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l05923"></a>05923         Op&lt;T&gt;::u(Var-&gt;num().I), paddcut_atancc_lin, loc::atan, 0, 0 );
<a name="l05924"></a>05924       _addcut_atancv_sec( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05925"></a>05925         Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), 0, 0 );
<a name="l05926"></a>05926     }
<a name="l05927"></a>05927 
<a name="l05928"></a>05928     <span class="comment">// -- Concavo-convex Portion</span>
<a name="l05929"></a>05929     <span class="keywordflow">else</span>{
<a name="l05930"></a>05930       <span class="keyword">struct </span>fct{ <span class="keyword">static</span> std::pair&lt;double,double&gt; atanfunc
<a name="l05931"></a>05931         ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l05932"></a>05932         { <span class="keywordflow">return</span> std::make_pair(
<a name="l05933"></a>05933             x-(*rusr)+(1+x*x)*(std::atan(*rusr)-std::atan(x)),
<a name="l05934"></a>05934             2*x*(std::atan(*rusr)-std::atan(x)) ); }
<a name="l05935"></a>05935       };
<a name="l05936"></a>05936 
<a name="l05937"></a>05937       <span class="keywordtype">double</span> xJcc = Op&lt;T&gt;::l(VarR-&gt;num().I);
<a name="l05938"></a>05938       xJcc = _newton( pFP, Op&lt;T&gt;::u(VarR-&gt;num().I), 0., Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05939"></a>05939         fct::atanfunc, &amp;xJcc, 0 );
<a name="l05940"></a>05940       <span class="keywordflow">if</span>( mc::isequal( xJcc, Op&lt;T&gt;::u(VarR-&gt;num().I) ) ){
<a name="l05941"></a>05941         _addcut_atancc_sec( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05942"></a>05942           Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), 0, 0 );
<a name="l05943"></a>05943       }
<a name="l05944"></a>05944       <span class="keywordflow">else</span>{
<a name="l05945"></a>05945         void (FPOp&lt;T&gt;::*paddcut_atancc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05946"></a>05946           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05947"></a>05947           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancc_lin;
<a name="l05948"></a>05948         _sandwich_cuts( pFP, VarR-&gt;id(), xJcc, Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l05949"></a>05949           Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05950"></a>05950           paddcut_atancc_lin, loc::atan, &amp;xJcc, 0 );
<a name="l05951"></a>05951       }
<a name="l05952"></a>05952 
<a name="l05953"></a>05953       <span class="keywordtype">double</span> xJcv = Op&lt;T&gt;::u(VarR-&gt;num().I);
<a name="l05954"></a>05954       xJcv = _newton( pFP, Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::l(VarR-&gt;num().I), 0.,
<a name="l05955"></a>05955         fct::atanfunc, &amp;xJcv, 0 );
<a name="l05956"></a>05956       <span class="keywordflow">if</span>( mc::isequal(xJcv,Op&lt;T&gt;::l(VarR-&gt;num().I)) ){
<a name="l05957"></a>05957         _addcut_atancv_sec( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l05958"></a>05958         Op&lt;T&gt;::u(VarR-&gt;num().I), Var-&gt;id(), 0, 0 );
<a name="l05959"></a>05959       }
<a name="l05960"></a>05960       <span class="keywordflow">else</span>{
<a name="l05961"></a>05961         void (FPOp&lt;T&gt;::*paddcut_atancv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l05962"></a>05962           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l05963"></a>05963           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_atancv_lin;
<a name="l05964"></a>05964         _sandwich_cuts( pFP, VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), xJcv, 
<a name="l05965"></a>05965           Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l05966"></a>05966           paddcut_atancv_lin, loc::atan, &amp;xJcv, 0 );
<a name="l05967"></a>05967       }
<a name="l05968"></a>05968     }
<a name="l05969"></a>05969   }
<a name="l05970"></a>05970 }
<a name="l05971"></a>05971   
<a name="l05972"></a>05972 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05973"></a>05973 FPOp&lt;T&gt;::_addcut_atancv_lin
<a name="l05974"></a>05974 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05975"></a>05975   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05976"></a>05976   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05977"></a>05977 {
<a name="l05978"></a>05978   <span class="comment">// -x/(1+xref^2) + y &gt;= atan(xref) - xref/(1+xref^2)</span>
<a name="l05979"></a>05979   <span class="keyword">const</span> <span class="keywordtype">double</span> dfref = 1./(1+Xref*Xref);
<a name="l05980"></a>05980   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, std::atan(Xref)-Xref*dfref,
<a name="l05981"></a>05981     iY, 1., iX, -dfref );
<a name="l05982"></a>05982 }
<a name="l05983"></a>05983 
<a name="l05984"></a>05984 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05985"></a>05985 FPOp&lt;T&gt;::_addcut_atancc_lin
<a name="l05986"></a>05986 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l05987"></a>05987   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l05988"></a>05988   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l05989"></a>05989 {
<a name="l05990"></a>05990   <span class="comment">// -x/(1+xref^2) + y &lt;= atan(xref) - xref/(1+xref^2)</span>
<a name="l05991"></a>05991   <span class="keyword">const</span> <span class="keywordtype">double</span> dfref = 1./(1+Xref*Xref);
<a name="l05992"></a>05992   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, std::atan(Xref)-Xref*dfref,
<a name="l05993"></a>05993     iY, 1., iX, -dfref );
<a name="l05994"></a>05994 }
<a name="l05995"></a>05995 
<a name="l05996"></a>05996 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l05997"></a>05997 FPOp&lt;T&gt;::_addcut_atancv_sec
<a name="l05998"></a>05998 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l05999"></a>05999   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l06000"></a>06000   <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l06001"></a>06001 {
<a name="l06002"></a>06002   <span class="comment">// dy*x - dx*y &lt;= dy*xL - dx*yL</span>
<a name="l06003"></a>06003   <span class="keywordtype">double</span> dX = XU - XL, YL = std::atan(XL), dY = std::atan(XU) - YL;
<a name="l06004"></a>06004   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l06005"></a>06005 }
<a name="l06006"></a>06006 
<a name="l06007"></a>06007 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06008"></a>06008 FPOp&lt;T&gt;::_addcut_atancc_sec
<a name="l06009"></a>06009 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l06010"></a>06010   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l06011"></a>06011   <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l06012"></a>06012 {
<a name="l06013"></a>06013   <span class="comment">// dy*x - dx*y &gt;= dy*xL - dx*yL</span>
<a name="l06014"></a>06014   <span class="keywordtype">double</span> dX = XU - XL, YL = std::atan(XL), dY = std::atan(XU) - YL;
<a name="l06015"></a>06015   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l06016"></a>06016 }
<a name="l06017"></a>06017 
<a name="l06018"></a>06018 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06019"></a>06019 FPOp&lt;T&gt;::_ERF_cuts
<a name="l06020"></a>06020 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> FPVar&lt;T&gt;*VarR, <span class="keyword">const</span> FPVar&lt;T&gt;*Var )
<a name="l06021"></a>06021 {
<a name="l06022"></a>06022   <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXINT )
<a name="l06023"></a>06023     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, ::erf(Var-&gt;num().n),
<a name="l06024"></a>06024       VarR-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1. );
<a name="l06025"></a>06025   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Var-&gt;id().first == FPVar&lt;T&gt;::AUXREAL )
<a name="l06026"></a>06026     pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::EQ, ::erf(Var-&gt;num().x),
<a name="l06027"></a>06027       VarR-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>(), 1. );
<a name="l06028"></a>06028   <span class="keywordflow">else</span>{
<a name="l06029"></a>06029     <span class="keyword">typedef</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar pt_idVar;
<a name="l06030"></a>06030     <span class="keyword">struct </span>loc{ <span class="keyword">static</span> std::pair&lt;double,double&gt; erf
<a name="l06031"></a>06031       ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l06032"></a>06032       { <span class="keywordflow">return</span> std::make_pair( ::erf(x), 2./std::sqrt(PI)*std::exp(-x*x) ); }
<a name="l06033"></a>06033     };
<a name="l06034"></a>06034 
<a name="l06035"></a>06035     <span class="comment">// Append new linear cuts for univariate erf term</span>
<a name="l06036"></a>06036     <span class="comment">// -- Convex Portion</span>
<a name="l06037"></a>06037     <span class="keywordflow">if</span>( Op&lt;T&gt;::u(Var-&gt;num().I) &lt;= 0. ){
<a name="l06038"></a>06038       _addcut_erfcc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l06039"></a>06039         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l06040"></a>06040       void (FPOp&lt;T&gt;::*paddcut_erfcv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l06041"></a>06041         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l06042"></a>06042         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_erfcv_lin;
<a name="l06043"></a>06043       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l06044"></a>06044         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l06045"></a>06045         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_erfcv_lin, loc::erf, 0, 0 );
<a name="l06046"></a>06046     }
<a name="l06047"></a>06047 
<a name="l06048"></a>06048     <span class="comment">// -- Concave Portion</span>
<a name="l06049"></a>06049     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Var-&gt;num().I) &gt;= 0. ){
<a name="l06050"></a>06050       void (FPOp&lt;T&gt;::*paddcut_erfcc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l06051"></a>06051         <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l06052"></a>06052         <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_erfcc_lin;
<a name="l06053"></a>06053       _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l06054"></a>06054         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I),
<a name="l06055"></a>06055         Op&lt;T&gt;::u(VarR-&gt;num().I), paddcut_erfcc_lin, loc::erf, 0, 0 );
<a name="l06056"></a>06056       _addcut_erfcv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l06057"></a>06057         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l06058"></a>06058     }
<a name="l06059"></a>06059 
<a name="l06060"></a>06060     <span class="comment">// -- Concavo-convex Portion</span>
<a name="l06061"></a>06061     <span class="keywordflow">else</span>{
<a name="l06062"></a>06062       <span class="keyword">struct </span>fct{ <span class="keyword">static</span> std::pair&lt;double,double&gt; erffunc
<a name="l06063"></a>06063         ( <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span>*rusr, <span class="keyword">const</span> <span class="keywordtype">int</span>*iusr )
<a name="l06064"></a>06064         { <span class="keywordflow">return</span> std::make_pair(
<a name="l06065"></a>06065             2./std::sqrt(PI)*(x-(*rusr))+(::erf(*rusr)-::erf(x))*std::exp(x*x),
<a name="l06066"></a>06066             2.*x*std::exp(x*x)*(::erf(*rusr)-::erf(x)) ); }
<a name="l06067"></a>06067       };
<a name="l06068"></a>06068 
<a name="l06069"></a>06069       <span class="keywordtype">double</span> xJcc = Op&lt;T&gt;::l(Var-&gt;num().I);
<a name="l06070"></a>06070       xJcc = _newton( pFP, Op&lt;T&gt;::u(Var-&gt;num().I), 0., Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l06071"></a>06071         fct::erffunc, &amp;xJcc, 0 );
<a name="l06072"></a>06072       <span class="keywordflow">if</span>( mc::isequal( xJcc, Op&lt;T&gt;::u(Var-&gt;num().I) ) ){
<a name="l06073"></a>06073         _addcut_erfcc_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l06074"></a>06074           Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l06075"></a>06075       }
<a name="l06076"></a>06076       <span class="keywordflow">else</span>{
<a name="l06077"></a>06077         void (FPOp&lt;T&gt;::*paddcut_erfcc_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l06078"></a>06078           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l06079"></a>06079           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_erfcc_lin;
<a name="l06080"></a>06080         _sandwich_cuts( pFP, Var-&gt;id(), xJcc, Op&lt;T&gt;::u(Var-&gt;num().I),
<a name="l06081"></a>06081           VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l06082"></a>06082           paddcut_erfcc_lin, loc::erf, &amp;xJcc, 0 );
<a name="l06083"></a>06083       }
<a name="l06084"></a>06084 
<a name="l06085"></a>06085       <span class="keywordtype">double</span> xJcv = Op&lt;T&gt;::u(Var-&gt;num().I);
<a name="l06086"></a>06086       xJcv = _newton( pFP, Op&lt;T&gt;::l(Var-&gt;num().I), Op&lt;T&gt;::l(Var-&gt;num().I), 0.,
<a name="l06087"></a>06087         fct::erffunc, &amp;xJcv, 0 );
<a name="l06088"></a>06088       <span class="keywordflow">if</span>( mc::isequal(xJcv,Op&lt;T&gt;::l(Var-&gt;num().I)) ){
<a name="l06089"></a>06089         _addcut_erfcv_sec( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I),
<a name="l06090"></a>06090         Op&lt;T&gt;::u(Var-&gt;num().I), VarR-&gt;id(), 0, 0 );
<a name="l06091"></a>06091       }
<a name="l06092"></a>06092       <span class="keywordflow">else</span>{
<a name="l06093"></a>06093         void (FPOp&lt;T&gt;::*paddcut_erfcv_lin)( FPRelax&lt;T&gt;*, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, 
<a name="l06094"></a>06094           <span class="keyword">const</span> double, <span class="keyword">const</span> double, <span class="keyword">const</span> pt_idVar, <span class="keyword">const</span> double, <span class="keyword">const</span> double,
<a name="l06095"></a>06095           <span class="keyword">const</span> <span class="keywordtype">double</span>*, <span class="keyword">const</span> <span class="keywordtype">int</span>* ) = &amp;FPOp&lt;T&gt;::_addcut_erfcv_lin;
<a name="l06096"></a>06096         _sandwich_cuts( pFP, Var-&gt;id(), Op&lt;T&gt;::l(Var-&gt;num().I), xJcv, 
<a name="l06097"></a>06097           VarR-&gt;id(), Op&lt;T&gt;::l(VarR-&gt;num().I), Op&lt;T&gt;::u(VarR-&gt;num().I),
<a name="l06098"></a>06098           paddcut_erfcv_lin, loc::erf, &amp;xJcv, 0 );
<a name="l06099"></a>06099       }
<a name="l06100"></a>06100     }
<a name="l06101"></a>06101   }
<a name="l06102"></a>06102 }
<a name="l06103"></a>06103   
<a name="l06104"></a>06104 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06105"></a>06105 FPOp&lt;T&gt;::_addcut_erfcv_lin
<a name="l06106"></a>06106 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l06107"></a>06107   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l06108"></a>06108   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l06109"></a>06109 {
<a name="l06110"></a>06110   <span class="comment">// -x*erf&#39;(xref) + y &gt;= erf(xref) - xref*erf&#39;(xref)</span>
<a name="l06111"></a>06111   <span class="keyword">const</span> <span class="keywordtype">double</span> dfref = 2./std::sqrt(PI)*std::exp(-Xref*Xref);
<a name="l06112"></a>06112   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, ::erf(Xref)-Xref*dfref,
<a name="l06113"></a>06113     iY, 1., iX, -dfref );
<a name="l06114"></a>06114 }
<a name="l06115"></a>06115 
<a name="l06116"></a>06116 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06117"></a>06117 FPOp&lt;T&gt;::_addcut_erfcc_lin
<a name="l06118"></a>06118 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keywordtype">double</span> Xref, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX,
<a name="l06119"></a>06119   <span class="keyword">const</span> <span class="keywordtype">double</span> XL, <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY,
<a name="l06120"></a>06120   <span class="keyword">const</span> <span class="keywordtype">double</span> YL, <span class="keyword">const</span> <span class="keywordtype">double</span> YU, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar, <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l06121"></a>06121 {
<a name="l06122"></a>06122   <span class="comment">// -x*erf&#39;(xref) + y &lt;= erf(xref) - xref*erf&#39;(xref)</span>
<a name="l06123"></a>06123   <span class="keyword">const</span> <span class="keywordtype">double</span> dfref = 2./std::sqrt(PI)*std::exp(-Xref*Xref);
<a name="l06124"></a>06124   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, ::erf(Xref)-Xref*dfref,
<a name="l06125"></a>06125     iY, 1., iX, -dfref );
<a name="l06126"></a>06126 }
<a name="l06127"></a>06127 
<a name="l06128"></a>06128 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06129"></a>06129 FPOp&lt;T&gt;::_addcut_erfcv_sec
<a name="l06130"></a>06130 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l06131"></a>06131   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l06132"></a>06132   <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l06133"></a>06133 {
<a name="l06134"></a>06134   <span class="comment">// dy*x - dx*y &lt;= dy*xL - dx*yL</span>
<a name="l06135"></a>06135   <span class="keywordtype">double</span> dX = XU - XL, YL = ::erf(XL), dY = ::erf(XU) - YL;
<a name="l06136"></a>06136   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::LE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l06137"></a>06137 }
<a name="l06138"></a>06138 
<a name="l06139"></a>06139 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06140"></a>06140 FPOp&lt;T&gt;::_addcut_erfcc_sec
<a name="l06141"></a>06141 ( FPRelax&lt;T&gt;*pFP, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iX, <span class="keyword">const</span> <span class="keywordtype">double</span> XL,
<a name="l06142"></a>06142   <span class="keyword">const</span> <span class="keywordtype">double</span> XU, <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar iY, <span class="keyword">const</span> <span class="keywordtype">double</span>*rpar,
<a name="l06143"></a>06143   <span class="keyword">const</span> <span class="keywordtype">int</span>*ipar )
<a name="l06144"></a>06144 {
<a name="l06145"></a>06145   <span class="comment">// dy*x - dx*y &gt;= dy*xL - dx*yL</span>
<a name="l06146"></a>06146   <span class="keywordtype">double</span> dX = XU - XL, YL = ::erf(XL), dY = ::erf(XU) - YL;
<a name="l06147"></a>06147   pFP-&gt;_append_cut( <span class="keyword">this</span>, FPCut&lt;T&gt;::GE, dY*XL-dX*YL, iY, -dX, iX, dY );
<a name="l06148"></a>06148 }
<a name="l06149"></a>06149 
<a name="l06151"></a>06151 
<a name="l06152"></a>06152 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::ostream&amp;
<a name="l06153"></a>06153 <span class="keyword">operator</span> &lt;&lt;
<a name="l06154"></a>06154 ( std::ostream&amp;out, <span class="keyword">const</span> FPRelax&lt;T&gt;&amp;FP)
<a name="l06155"></a>06155 {
<a name="l06156"></a>06156   <span class="keyword">typename</span> FPRelax&lt;T&gt;::t_Vars Vars = FP._Vars;
<a name="l06157"></a>06157   <span class="keyword">typename</span> FPRelax&lt;T&gt;::it_Vars itv = Vars.begin();
<a name="l06158"></a>06158   out &lt;&lt; ( FP._nvar? <span class="stringliteral">&quot;\nVARIABLES:\n&quot;</span>: <span class="stringliteral">&quot;\nNO VARIABLE\n&quot;</span> );
<a name="l06159"></a>06159   <span class="keywordflow">for</span>( ; itv!=Vars.end() &amp;&amp; (*itv)-&gt;_id.first&lt;=FPVar&lt;T&gt;::VARBIN; ++itv ){
<a name="l06160"></a>06160     out &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; **itv;
<a name="l06161"></a>06161     <span class="comment">//if( (*itv)-&gt;_Op ) out &lt;&lt; &quot;\t:= &quot; &lt;&lt; *(*itv)-&gt;_Op;</span>
<a name="l06162"></a>06162     out &lt;&lt; std::endl;
<a name="l06163"></a>06163   }
<a name="l06164"></a>06164   out &lt;&lt; ( FP._naux? <span class="stringliteral">&quot;\nAUXILIARY:\n&quot;</span>: <span class="stringliteral">&quot;\nNO AUXILIARY\n&quot;</span> );
<a name="l06165"></a>06165   <span class="keywordflow">for</span>( ; itv!=Vars.end(); ++itv ){
<a name="l06166"></a>06166     out &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; **itv;
<a name="l06167"></a>06167     <span class="keywordflow">if</span>( (*itv)-&gt;_Op ) out &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; *(*itv)-&gt;_Op;
<a name="l06168"></a>06168     out &lt;&lt; std::endl;
<a name="l06169"></a>06169   }
<a name="l06170"></a>06170 
<a name="l06171"></a>06171   <span class="keyword">typename</span> FPRelax&lt;T&gt;::t_Cuts Cuts = FP._Cuts;
<a name="l06172"></a>06172   <span class="keyword">typename</span> FPRelax&lt;T&gt;::it_Cuts itc = Cuts.begin();
<a name="l06173"></a>06173   out &lt;&lt; ( Cuts.size()? <span class="stringliteral">&quot;\nCUTS:\n&quot;</span>: <span class="stringliteral">&quot;\nNO CUTS\n&quot;</span> );
<a name="l06174"></a>06174   <span class="keywordflow">for</span>( ; itc!=Cuts.end(); ++itc )
<a name="l06175"></a>06175     out &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; **itc &lt;&lt; std::endl;
<a name="l06176"></a>06176 
<a name="l06177"></a>06177   <span class="keywordflow">return</span> out;
<a name="l06178"></a>06178 }
<a name="l06179"></a>06179 
<a name="l06180"></a>06180 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06181"></a>06181 <a class="code" href="classmc_1_1FPRelax.html#acc5a0b6864118490094bb59c19e32d92" title="Set objective function in factorable program.">FPRelax&lt;T&gt;::set_objective</a>
<a name="l06182"></a><a class="code" href="classmc_1_1FPRelax.html#acc5a0b6864118490094bb59c19e32d92">06182</a> ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax.html#a72d882ae1ff04694cca19a3842a55117" title="Enumeration for objective function type in factorable program.">FPRelax&lt;T&gt;::OBJTYPE</a> type, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;objVar )
<a name="l06183"></a>06183 {
<a name="l06184"></a>06184   <span class="comment">// Erase any previous objective</span>
<a name="l06185"></a>06185   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> refOp( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a> );
<a name="l06186"></a>06186   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nobjOp = 2;
<a name="l06187"></a>06187   <span class="keyword">static</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> objOp[nobjOp] = { <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a> };
<a name="l06188"></a>06188   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iOp=0; iOp&lt;nobjOp; iOp++ ){
<a name="l06189"></a>06189     refOp.<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> = objOp[iOp];
<a name="l06190"></a>06190     std::pair&lt; cit_Ops, cit_Ops &gt; rangeOp = std::equal_range(
<a name="l06191"></a>06191       _Ops.begin(), _Ops.end(), &amp;refOp, <a class="code" href="structmc_1_1range__FPOp.html" title="C++ structure for comparing operations in a factorable program.">range_FPOp&lt;T&gt;</a>() );
<a name="l06192"></a>06192     <span class="keywordflow">for</span>( cit_Ops ito = rangeOp.first; ito != rangeOp.second; ++ito )
<a name="l06193"></a>06193       <span class="keyword">delete</span> *ito;
<a name="l06194"></a>06194     _Ops.erase( rangeOp.first, rangeOp.second );
<a name="l06195"></a>06195   }
<a name="l06196"></a>06196 
<a name="l06197"></a>06197   <span class="comment">// Constant objective case</span>
<a name="l06198"></a>06198   <span class="keywordflow">if</span>( objVar.<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().second == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::NOREF</a> ){
<a name="l06199"></a>06199     <span class="keywordtype">double</span> vobj = 0.;
<a name="l06200"></a>06200     <span class="keywordflow">switch</span>( objVar.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().t ){
<a name="l06201"></a>06201       <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::INT</a>:   vobj = (double)objVar.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().n; <span class="keywordflow">break</span>;
<a name="l06202"></a>06202       <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::REAL</a>:  vobj = objVar.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().x; <span class="keywordflow">break</span>;
<a name="l06203"></a>06203       <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::RANGE</a>:
<a name="l06204"></a>06204         <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::OBJECTIVE</a> );
<a name="l06205"></a>06205     }
<a name="l06206"></a>06206     <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pCst = _auxiliary_constant( vobj );
<a name="l06207"></a>06207     <span class="keywordflow">switch</span>( type ){
<a name="l06208"></a>06208       <span class="keywordflow">case</span> MIN: _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>, pCst-&gt;<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06209"></a>06209       <span class="keywordflow">case</span> MAX: _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a>, pCst-&gt;<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06210"></a>06210     }
<a name="l06211"></a>06211     <span class="keywordflow">return</span>;
<a name="l06212"></a>06212   }
<a name="l06213"></a>06213 
<a name="l06214"></a>06214   <span class="comment">// General case</span>
<a name="l06215"></a>06215   <span class="keywordflow">switch</span>( type ){
<a name="l06216"></a>06216     <span class="keywordflow">case</span> MIN: _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>, objVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06217"></a>06217     <span class="keywordflow">case</span> MAX: _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a>, objVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06218"></a>06218   }
<a name="l06219"></a>06219   <span class="keywordflow">return</span>;
<a name="l06220"></a>06220 }
<a name="l06221"></a>06221 
<a name="l06222"></a>06222 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*
<a name="l06223"></a>06223 <a class="code" href="classmc_1_1FPRelax.html#a73af7c422d8727ad932c385bdb4a15a7" title="Add constraint to factorable program.">FPRelax&lt;T&gt;::add_constraint</a>
<a name="l06224"></a><a class="code" href="classmc_1_1FPRelax.html#a73af7c422d8727ad932c385bdb4a15a7">06224</a> ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;lhsVar, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax.html#a7591f222e5febb758bd330667d29abf8" title="Enumeration for constraint type in factorable program.">FPRelax&lt;T&gt;::CTRTYPE</a> type,
<a name="l06225"></a>06225   <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>&amp;rhsVar )
<a name="l06226"></a>06226 {
<a name="l06227"></a>06227   <span class="comment">// Inconsistent case</span>
<a name="l06228"></a>06228   <span class="keywordflow">if</span>( lhsVar.<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().second == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::NOREF</a>
<a name="l06229"></a>06229    &amp;&amp; rhsVar.<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().second == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::NOREF</a> ){
<a name="l06230"></a>06230     <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::CONSTRAINT</a> );
<a name="l06231"></a>06231   }
<a name="l06232"></a>06232 
<a name="l06233"></a>06233   <span class="comment">// Constant LHS case</span>
<a name="l06234"></a>06234   <span class="keywordflow">if</span>( lhsVar.<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().second == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::NOREF</a> ){
<a name="l06235"></a>06235     <span class="keywordflow">switch</span>( type ){
<a name="l06236"></a>06236       <span class="keywordflow">case</span> LE: <span class="keywordflow">return</span> add_constraint( rhsVar, GE, lhsVar );
<a name="l06237"></a>06237       <span class="keywordflow">case</span> EQ: <span class="keywordflow">return</span> add_constraint( rhsVar, EQ, lhsVar );
<a name="l06238"></a>06238       <span class="keywordflow">case</span> GE: <span class="keywordflow">return</span> add_constraint( rhsVar, LE, lhsVar );
<a name="l06239"></a>06239     }
<a name="l06240"></a>06240   }
<a name="l06241"></a>06241   
<a name="l06242"></a>06242   <span class="comment">// Constant RHS case</span>
<a name="l06243"></a>06243   <span class="keywordflow">if</span>( rhsVar.<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().second == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::NOREF</a> ){
<a name="l06244"></a>06244     <span class="keywordtype">double</span> vrhs = 0.;
<a name="l06245"></a>06245     <span class="keywordflow">switch</span>( rhsVar.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().t ){
<a name="l06246"></a>06246       <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::INT</a>:   vrhs = (double)rhsVar.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().n; <span class="keywordflow">break</span>;
<a name="l06247"></a>06247       <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::REAL</a>:  vrhs = rhsVar.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().x; <span class="keywordflow">break</span>;
<a name="l06248"></a>06248       <span class="keywordflow">case</span> <a class="code" href="structmc_1_1FPVarNum.html" title="C++ template structure for defining the numeric field of a factorable program variable.">FPVarNum&lt;T&gt;::RANGE</a>:
<a name="l06249"></a>06249         <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::CONSTRAINT</a> );
<a name="l06250"></a>06250     }
<a name="l06251"></a>06251     <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pCst = _auxiliary_constant( vrhs );
<a name="l06252"></a>06252     <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* pOp = 0;
<a name="l06253"></a>06253     <span class="keywordflow">switch</span>( type ){
<a name="l06254"></a>06254       <span class="keywordflow">case</span> LE: pOp = _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>, lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres,
<a name="l06255"></a>06255         pCst-&gt;<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06256"></a>06256       <span class="keywordflow">case</span> EQ: pOp = _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>, lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres,
<a name="l06257"></a>06257         pCst-&gt;<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06258"></a>06258       <span class="keywordflow">case</span> GE: pOp = _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>, pCst-&gt;<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres,
<a name="l06259"></a>06259         lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06260"></a>06260     }
<a name="l06261"></a>06261     <span class="keywordflow">if</span>( !pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> ) pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> = lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres;
<a name="l06262"></a>06262     <span class="keywordflow">return</span> pOp;
<a name="l06263"></a>06263   }
<a name="l06264"></a>06264 
<a name="l06265"></a>06265   <span class="comment">// General case</span>
<a name="l06266"></a>06266   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* pOp = 0;
<a name="l06267"></a>06267   <span class="keywordflow">switch</span>( type ){
<a name="l06268"></a>06268     <span class="keywordflow">case</span> LE: pOp = _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>, lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres,
<a name="l06269"></a>06269       rhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06270"></a>06270     <span class="keywordflow">case</span> EQ: pOp = _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>, lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres,
<a name="l06271"></a>06271       rhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06272"></a>06272     <span class="keywordflow">case</span> GE: pOp = _operation( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>, rhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres,
<a name="l06273"></a>06273       lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres ); <span class="keywordflow">break</span>;
<a name="l06274"></a>06274   }
<a name="l06275"></a>06275   <span class="keywordflow">if</span>( !pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> ) pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> = lhsVar.<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>()-&gt;pres;
<a name="l06276"></a>06276   <span class="keywordflow">return</span> pOp;
<a name="l06277"></a>06277 }
<a name="l06278"></a>06278 
<a name="l06279"></a>06279 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*
<a name="l06280"></a>06280 <a class="code" href="classmc_1_1FPRelax.html#ab8c7126d3f23ec946da0fb687449e954" title="Looks for the operation of type op with left and right operands lop, rop in set _Ops and adds it if n...">FPRelax&lt;T&gt;::_operation</a>
<a name="l06281"></a><a class="code" href="classmc_1_1FPRelax.html#ab8c7126d3f23ec946da0fb687449e954">06281</a> ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> type, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*lop, <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*rop )
<a name="l06282"></a>06282 {
<a name="l06283"></a>06283   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* op = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>( type, lop, rop );
<a name="l06284"></a>06284   <span class="keyword">typename</span> FPRelax&lt;T&gt;::it_Ops itop = _Ops.find( op );
<a name="l06285"></a>06285   <span class="keywordflow">if</span>( itop!=_Ops.end() ){ <span class="keyword">delete</span> op; <span class="keywordflow">return</span> *itop; }
<a name="l06286"></a>06286   _Ops.insert( op );
<a name="l06287"></a>06287   <span class="keywordflow">return</span> op;
<a name="l06288"></a>06288 }
<a name="l06289"></a>06289 
<a name="l06290"></a>06290 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l06291"></a>06291 <a class="code" href="classmc_1_1FPRelax.html#a6bae03eeb3a84845c5d354fd8529e519" title="Erase operation op in set _Ops">FPRelax&lt;T&gt;::_erase_operation</a>
<a name="l06292"></a><a class="code" href="classmc_1_1FPRelax.html#a6bae03eeb3a84845c5d354fd8529e519">06292</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* op )
<a name="l06293"></a>06293 {
<a name="l06294"></a>06294   <span class="keyword">typename</span> FPRelax&lt;T&gt;::it_Ops itop = _Ops.find( op );
<a name="l06295"></a>06295   <span class="keywordflow">if</span>( itop!=_Ops.end() ){
<a name="l06296"></a>06296     _erase_cuts( op );
<a name="l06297"></a>06297     <span class="keyword">delete</span> op;
<a name="l06298"></a>06298     _Ops.erase( itop );
<a name="l06299"></a>06299     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l06300"></a>06300   }
<a name="l06301"></a>06301   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06302"></a>06302 }
<a name="l06303"></a>06303  
<a name="l06304"></a>06304 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06305"></a>06305 <a class="code" href="classmc_1_1FPRelax.html#a49cb376ec1138e08472d4462cae15c62" title="Erase all relaxation cuts in _Cuts.">FPRelax&lt;T&gt;::_erase_cuts</a>
<a name="l06306"></a><a class="code" href="classmc_1_1FPRelax.html#aaabb3e469e4ceca76d86f79f6a2b5488">06306</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* op )
<a name="l06307"></a>06307 {
<a name="l06308"></a>06308   it_Cuts itc = _Cuts.begin(), itp;
<a name="l06309"></a>06309   <span class="keywordflow">while</span>( itc != _Cuts.end() ){
<a name="l06310"></a>06310     itp = itc; ++itc;
<a name="l06311"></a>06311     <span class="keywordflow">if</span>( (*itp)-&gt;op() == op ){ <span class="keyword">delete</span> *itp; _Cuts.erase( itp ); }
<a name="l06312"></a>06312   } 
<a name="l06313"></a>06313 }
<a name="l06314"></a>06314  
<a name="l06315"></a>06315 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*
<a name="l06316"></a>06316 <a class="code" href="classmc_1_1FPRelax.html#ac20884ec2b7a4d2bd7dc2acc4e7fe822" title="Adds the auxiliary continuous variable with bounds X from operation pOp">FPRelax&lt;T&gt;::_auxiliary_variable</a>
<a name="l06317"></a><a class="code" href="classmc_1_1FPRelax.html#ac20884ec2b7a4d2bd7dc2acc4e7fe822">06317</a> ( <span class="keyword">const</span> T&amp;X, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*pOp )
<a name="l06318"></a>06318 {
<a name="l06319"></a>06319   pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( <span class="keyword">this</span>, X, pOp );
<a name="l06320"></a>06320   _append_aux( pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> );
<a name="l06321"></a>06321   <span class="keywordflow">return</span> pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>;
<a name="l06322"></a>06322 }
<a name="l06323"></a>06323   
<a name="l06324"></a>06324 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*
<a name="l06325"></a>06325 <a class="code" href="classmc_1_1FPRelax.html#ac20884ec2b7a4d2bd7dc2acc4e7fe822" title="Adds the auxiliary continuous variable with bounds X from operation pOp">FPRelax&lt;T&gt;::_auxiliary_variable</a>
<a name="l06326"></a><a class="code" href="classmc_1_1FPRelax.html#a13e20c9ac438d2c82f6123a3d269661f">06326</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*pOp )
<a name="l06327"></a>06327 {
<a name="l06328"></a>06328   pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( <span class="keyword">this</span>, pOp );
<a name="l06329"></a>06329   _append_aux( pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> );
<a name="l06330"></a>06330   <span class="keywordflow">return</span> pOp-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>;
<a name="l06331"></a>06331 }
<a name="l06332"></a>06332 
<a name="l06333"></a>06333 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*
<a name="l06334"></a>06334 <a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3" title="Looks for the real auxiliary constant x and adds it if not found.">FPRelax&lt;T&gt;::_auxiliary_constant</a>
<a name="l06335"></a><a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3">06335</a> ( <span class="keyword">const</span> <span class="keywordtype">double</span> x )
<a name="l06336"></a>06336 {
<a name="l06337"></a>06337   <span class="comment">// Check if real constant x already defined in _Vars</span>
<a name="l06338"></a>06338   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pAux = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( x );
<a name="l06339"></a>06339   it_Vars iAux = _Vars.find( pAux );
<a name="l06340"></a>06340   <span class="keywordflow">if</span>( iAux!=_Vars.end() ){ <span class="keyword">delete</span> pAux; <span class="keywordflow">return</span> *iAux; }
<a name="l06341"></a>06341 
<a name="l06342"></a>06342   <span class="comment">// Otherwise, append constant x</span>
<a name="l06343"></a>06343   _append_aux( pAux, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::CNST</a> );
<a name="l06344"></a>06344   <span class="keywordflow">return</span> pAux;
<a name="l06345"></a>06345 }
<a name="l06346"></a>06346 
<a name="l06347"></a>06347 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*
<a name="l06348"></a>06348 <a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3" title="Looks for the real auxiliary constant x and adds it if not found.">FPRelax&lt;T&gt;::_auxiliary_constant</a>
<a name="l06349"></a><a class="code" href="classmc_1_1FPRelax.html#af156e7b7cd22ce014fb45d0c8d23b6ec">06349</a> ( <span class="keyword">const</span> <span class="keywordtype">int</span> n )
<a name="l06350"></a>06350 {
<a name="l06351"></a>06351   <span class="comment">// Check if real constant x already defined in _Vars</span>
<a name="l06352"></a>06352   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pAux = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( n );
<a name="l06353"></a>06353   it_Vars iAux = _Vars.find( pAux );
<a name="l06354"></a>06354   <span class="keywordflow">if</span>( iAux!=_Vars.end() ){ <span class="keyword">delete</span> pAux; <span class="keywordflow">return</span> *iAux; }
<a name="l06355"></a>06355 
<a name="l06356"></a>06356   <span class="comment">// Otherwise, append constant n</span>
<a name="l06357"></a>06357   _append_aux( pAux, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::CNST</a> );
<a name="l06358"></a>06358   <span class="keywordflow">return</span> pAux;
<a name="l06359"></a>06359 }
<a name="l06360"></a>06360 
<a name="l06361"></a>06361 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*
<a name="l06362"></a>06362 <a class="code" href="classmc_1_1FPRelax.html#a0753ed00262b18d1e34cef87f0fd48b3" title="Looks for the real auxiliary constant x and adds it if not found.">FPRelax&lt;T&gt;::_auxiliary_constant</a>
<a name="l06363"></a><a class="code" href="classmc_1_1FPRelax.html#a1af4f424313b586768f96bb4c9a7ddde">06363</a> ( <span class="keyword">const</span> T&amp;I )
<a name="l06364"></a>06364 {
<a name="l06365"></a>06365   <span class="comment">// Append interval bounds I</span>
<a name="l06366"></a>06366   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pAux = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( I );
<a name="l06367"></a>06367   _append_aux( pAux, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::RANGE</a> );
<a name="l06368"></a>06368   <span class="keywordflow">return</span> pAux;
<a name="l06369"></a>06369 }
<a name="l06370"></a>06370 
<a name="l06371"></a>06371 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06372"></a>06372 <a class="code" href="classmc_1_1FPRelax.html#a35e7be64f140a34982162ffad129c659" title="Appends the auxiliary variable pAux and define it in _Ops with type tOp">FPRelax&lt;T&gt;::_append_aux</a>
<a name="l06373"></a><a class="code" href="classmc_1_1FPRelax.html#a35e7be64f140a34982162ffad129c659">06373</a> ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pAux, <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> tOp )
<a name="l06374"></a>06374 {
<a name="l06375"></a>06375   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*pOp = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>( tOp, 0, 0, pAux );
<a name="l06376"></a>06376   _Ops.insert( pOp );
<a name="l06377"></a>06377   pAux-&gt;<a class="code" href="group__FP.html#gac1d3125672336ebdc81a75e7ac947dac" title="Get const pointer to factorable program.">FP</a>() = <span class="keyword">this</span>;
<a name="l06378"></a>06378   pAux-&gt;<a class="code" href="group__FP.html#ga74e25d668b677985337b71ec892f10f6" title="Get const pointer to defining operation.">Oper</a>() = pOp;
<a name="l06379"></a>06379   pAux-&gt;<a class="code" href="group__FP.html#gaaf92fbd4c670c18d561c0aa04fb90534" title="Get variable identifier.">id</a>().second = _naux++;
<a name="l06380"></a>06380   _append_aux( pAux );
<a name="l06381"></a>06381 }
<a name="l06382"></a>06382 
<a name="l06383"></a>06383 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06384"></a>06384 <a class="code" href="classmc_1_1FPRelax.html#a35e7be64f140a34982162ffad129c659" title="Appends the auxiliary variable pAux and define it in _Ops with type tOp">FPRelax&lt;T&gt;::_append_aux</a>
<a name="l06385"></a><a class="code" href="classmc_1_1FPRelax.html#aefdffbaa47147f20b5f9bcbae07db27d">06385</a> ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pAux )
<a name="l06386"></a>06386 {
<a name="l06387"></a>06387   _Vars.insert( pAux );
<a name="l06388"></a>06388 }
<a name="l06389"></a>06389 
<a name="l06390"></a>06390 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06391"></a>06391 <a class="code" href="classmc_1_1FPRelax.html#ae869e37c863d88ea9bc2b7074fa03672" title="Appends new original variable.">FPRelax&lt;T&gt;::_append_var</a>
<a name="l06392"></a><a class="code" href="classmc_1_1FPRelax.html#ae869e37c863d88ea9bc2b7074fa03672">06392</a> ( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pVar )
<a name="l06393"></a>06393 {
<a name="l06394"></a>06394   _Vars.insert( pVar );
<a name="l06395"></a>06395 }   
<a name="l06396"></a>06396 
<a name="l06397"></a>06397 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*
<a name="l06398"></a>06398 <a class="code" href="classmc_1_1FPRelax.html#aeb076bff44dd597ef45b7ed609d2e095" title="Search for the variable with identify id in _Vars">FPRelax&lt;T&gt;::_find_var</a>
<a name="l06399"></a><a class="code" href="classmc_1_1FPRelax.html#aeb076bff44dd597ef45b7ed609d2e095">06399</a> ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>&amp;<span class="keywordtype">id</span> )
<a name="l06400"></a>06400 {
<a name="l06401"></a>06401   <span class="comment">// Check if real constant x already defined in _Vars</span>
<a name="l06402"></a>06402   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* pVar = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>( <span class="keyword">this</span>, id );
<a name="l06403"></a>06403   it_Vars iVar = _Vars.find( pVar );
<a name="l06404"></a>06404   <span class="keyword">delete</span> pVar;
<a name="l06405"></a>06405   <span class="keywordflow">return</span>( iVar==_Vars.end()? 0: *iVar );
<a name="l06406"></a>06406 }
<a name="l06407"></a>06407 
<a name="l06408"></a>06408 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>*
<a name="l06409"></a>06409 <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">FPRelax&lt;T&gt;::_append_cut</a>
<a name="l06410"></a><a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131">06410</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l06411"></a>06411   <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1,
<a name="l06412"></a>06412   <span class="keyword">const</span> <span class="keywordtype">double</span> a1 )
<a name="l06413"></a>06413 {
<a name="l06414"></a>06414   <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* pCut = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>( op, type, b, id1, a1 );
<a name="l06415"></a>06415   _Cuts.insert( pCut );
<a name="l06416"></a>06416   <span class="keywordflow">return</span> pCut;
<a name="l06417"></a>06417 }
<a name="l06418"></a>06418 
<a name="l06419"></a>06419 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>*
<a name="l06420"></a>06420 <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">FPRelax&lt;T&gt;::_append_cut</a>
<a name="l06421"></a><a class="code" href="classmc_1_1FPRelax.html#a92045325a693e16ab63ca44ac9f52d56">06421</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l06422"></a>06422   <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1,
<a name="l06423"></a>06423   <span class="keyword">const</span> <span class="keywordtype">double</span> a1, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id2,
<a name="l06424"></a>06424   <span class="keyword">const</span> <span class="keywordtype">double</span> a2 )
<a name="l06425"></a>06425 {
<a name="l06426"></a>06426   <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* pCut = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>( op, type, b, id1, a1, id2, a2 );
<a name="l06427"></a>06427   _Cuts.insert( pCut );
<a name="l06428"></a>06428   <span class="keywordflow">return</span> pCut;
<a name="l06429"></a>06429 }
<a name="l06430"></a>06430 
<a name="l06431"></a>06431 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>*
<a name="l06432"></a>06432 <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">FPRelax&lt;T&gt;::_append_cut</a>
<a name="l06433"></a><a class="code" href="classmc_1_1FPRelax.html#a8d06e9819e8cd7f578e2c450a9e0e1b4">06433</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l06434"></a>06434   <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id1,
<a name="l06435"></a>06435   <span class="keyword">const</span> <span class="keywordtype">double</span> a1, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id2,
<a name="l06436"></a>06436   <span class="keyword">const</span> <span class="keywordtype">double</span> a2, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a> id3,
<a name="l06437"></a>06437   <span class="keyword">const</span> <span class="keywordtype">double</span> a3 )
<a name="l06438"></a>06438 {
<a name="l06439"></a>06439   <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* pCut = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>( op, type, b, id1, a1, id2, a2, id3, a3 );
<a name="l06440"></a>06440   _Cuts.insert( pCut );
<a name="l06441"></a>06441   <span class="keywordflow">return</span> pCut;
<a name="l06442"></a>06442 }
<a name="l06443"></a>06443 
<a name="l06444"></a>06444 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>*
<a name="l06445"></a>06445 <a class="code" href="classmc_1_1FPRelax.html#a251d81e8e1144f489cc76d35f05a5131" title="Appends new relaxation cut in _Cuts w/ 1 variable.">FPRelax&lt;T&gt;::_append_cut</a>
<a name="l06446"></a><a class="code" href="classmc_1_1FPRelax.html#abcc7b196f473f7a5863ff054e05ac7ff">06446</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*op, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type,
<a name="l06447"></a>06447   <span class="keyword">const</span> <span class="keywordtype">double</span> b, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,
<a name="l06448"></a>06448   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>* <span class="keywordtype">id</span>, <span class="keyword">const</span> <span class="keywordtype">double</span>*a )
<a name="l06449"></a>06449 {
<a name="l06450"></a>06450   <span class="keywordflow">if</span>( !n ) <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l06451"></a>06451   <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>* pCut = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;</a>( op, type, b, n, id, a );
<a name="l06452"></a>06452   _Cuts.insert( pCut );
<a name="l06453"></a>06453   <span class="keywordflow">return</span> pCut;
<a name="l06454"></a>06454 }
<a name="l06455"></a>06455 
<a name="l06456"></a>06456 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06457"></a>06457 <a class="code" href="classmc_1_1FPRelax.html#a90277409a6e357ca8ff819a3f9201289" title="Generate polyhedral cuts for the objective and all constraints in the factorable program, after removing or not the existing cuts.">FPRelax&lt;T&gt;::generate_cuts</a>
<a name="l06458"></a><a class="code" href="classmc_1_1FPRelax.html#a90277409a6e357ca8ff819a3f9201289">06458</a> ( <span class="keyword">const</span> <span class="keywordtype">bool</span> reset )
<a name="l06459"></a>06459 {
<a name="l06460"></a>06460   <span class="comment">// Reset cuts in polyhedral relaxation?</span>
<a name="l06461"></a>06461   <span class="keywordflow">if</span>( reset ){
<a name="l06462"></a>06462     _erase_cuts();
<a name="l06463"></a>06463     _reset_operations();
<a name="l06464"></a>06464   }
<a name="l06465"></a>06465 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l06466"></a>06466 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nOPERATIONS BEFORE PROPAGATION:&quot;</span> &lt;&lt; std::endl;
<a name="l06467"></a>06467   <span class="keywordflow">for</span>( it_Ops ito = _Ops.begin(); ito != _Ops.end(); ++ito )
<a name="l06468"></a>06468     std::cout &lt;&lt; **ito &lt;&lt; <span class="stringliteral">&quot;   \t&quot;</span> &lt;&lt; (*ito)-&gt;status() &lt;&lt; std::endl;
<a name="l06469"></a>06469 <span class="preprocessor">#endif</span>
<a name="l06470"></a>06470 <span class="preprocessor"></span>
<a name="l06471"></a>06471   <span class="comment">// Generate cuts for all objective/constraints</span>
<a name="l06472"></a>06472   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> refOp( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a> );
<a name="l06473"></a>06473   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nfctOp = 4;
<a name="l06474"></a>06474   <span class="keyword">static</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> fctOp[nfctOp] = { <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>,
<a name="l06475"></a>06475     <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a> };
<a name="l06476"></a>06476   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iOp=0; iOp&lt;nfctOp; iOp++ ){
<a name="l06477"></a>06477     refOp.<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> = fctOp[iOp];
<a name="l06478"></a>06478     std::pair&lt; cit_Ops, cit_Ops &gt; rangeOp = std::equal_range(
<a name="l06479"></a>06479       _Ops.begin(), _Ops.end(), &amp;refOp, <a class="code" href="structmc_1_1range__FPOp.html" title="C++ structure for comparing operations in a factorable program.">range_FPOp&lt;T&gt;</a>() );
<a name="l06480"></a>06480     cit_Ops ito = rangeOp.first;
<a name="l06481"></a>06481     <span class="keywordflow">for</span>( ; ito != rangeOp.second; ++ito ) (*ito)-&gt;generate_cuts( <span class="keyword">this</span> );
<a name="l06482"></a>06482   }
<a name="l06483"></a>06483  
<a name="l06484"></a>06484 <span class="preprocessor">#ifdef MC__FPRELAX_DEBUG_PROPAGATION</span>
<a name="l06485"></a>06485 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;\nOPERATIONS AFTER PROPAGATION:&quot;</span> &lt;&lt; std::endl;
<a name="l06486"></a>06486   <span class="keywordflow">for</span>( it_Ops ito = _Ops.begin(); ito != _Ops.end(); ++ito )
<a name="l06487"></a>06487     std::cout &lt;&lt; **ito &lt;&lt; <span class="stringliteral">&quot;   \t&quot;</span> &lt;&lt; (*ito)-&gt;status() &lt;&lt; std::endl;
<a name="l06488"></a>06488 <span class="preprocessor">#endif</span>
<a name="l06489"></a>06489 <span class="preprocessor"></span>
<a name="l06490"></a>06490   <span class="keywordflow">return</span>;
<a name="l06491"></a>06491 }
<a name="l06492"></a>06492 
<a name="l06493"></a>06493 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06494"></a>06494 <a class="code" href="classmc_1_1FPRelax.html#a90277409a6e357ca8ff819a3f9201289" title="Generate polyhedral cuts for the objective and all constraints in the factorable program, after removing or not the existing cuts.">FPRelax&lt;T&gt;::generate_cuts</a>
<a name="l06495"></a><a class="code" href="classmc_1_1FPRelax.html#a6ad71d1ec5f1d35c374005194b80a462">06495</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*constr )
<a name="l06496"></a>06496 {
<a name="l06497"></a>06497   <span class="comment">// Generate cuts for constr only</span>
<a name="l06498"></a>06498   <span class="keywordflow">if</span>( !constr ) <span class="keywordflow">return</span>;
<a name="l06499"></a>06499   cit_Ops itop = _Ops.find( constr );
<a name="l06500"></a>06500   <span class="keywordflow">if</span>( itop == _Ops.end() ) <span class="keywordflow">return</span>;
<a name="l06501"></a>06501   <span class="keywordflow">return</span> (*itop)-&gt;generate_cuts( <span class="keyword">this</span> );
<a name="l06502"></a>06502 }
<a name="l06503"></a>06503 
<a name="l06504"></a>06504 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l06505"></a>06505 <a class="code" href="classmc_1_1FPRelax.html#a0c33eee46c2ebb35921425f3ae8833d9" title="Propagate constraints in the factorable program to reduce variable range, for the constraint constr o...">FPRelax&lt;T&gt;::propagate_constraints</a>
<a name="l06506"></a><a class="code" href="classmc_1_1FPRelax.html#a0c33eee46c2ebb35921425f3ae8833d9">06506</a> ( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>*constr )
<a name="l06507"></a>06507 {
<a name="l06508"></a>06508   <span class="comment">// Propagate constraint for constr only</span>
<a name="l06509"></a>06509   <span class="keywordflow">if</span>( constr ){
<a name="l06510"></a>06510     cit_Ops itop = _Ops.find( constr );
<a name="l06511"></a>06511     <span class="keywordflow">if</span>( itop == _Ops.end() ) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l06512"></a>06512     <span class="keywordflow">return</span> (*itop)-&gt;propagate_bounds( <span class="keyword">this</span> );
<a name="l06513"></a>06513   }
<a name="l06514"></a>06514 
<a name="l06515"></a>06515   <span class="comment">// Propagate all constraints</span>
<a name="l06516"></a>06516   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> refOp( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a> );
<a name="l06517"></a>06517   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nfctOp = 4;
<a name="l06518"></a>06518   <span class="keyword">static</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a> fctOp[nfctOp] = { <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>,
<a name="l06519"></a>06519     <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MIN</a>, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MAX</a> };
<a name="l06520"></a>06520   <span class="keywordtype">bool</span> keepgoing = <span class="keyword">true</span>;
<a name="l06521"></a>06521   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iOp=0; iOp&lt;nfctOp &amp;&amp; keepgoing; iOp++ ){
<a name="l06522"></a>06522     refOp.<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> = fctOp[iOp];
<a name="l06523"></a>06523     std::pair&lt; cit_Ops, cit_Ops &gt; rangeOp = std::equal_range(
<a name="l06524"></a>06524       _Ops.begin(), _Ops.end(), &amp;refOp, <a class="code" href="structmc_1_1range__FPOp.html" title="C++ structure for comparing operations in a factorable program.">range_FPOp&lt;T&gt;</a>() );
<a name="l06525"></a>06525     cit_Ops ito = rangeOp.first;
<a name="l06526"></a>06526     <span class="keywordflow">for</span>( ; ito != rangeOp.second &amp;&amp; keepgoing; ++ito )
<a name="l06527"></a>06527       keepgoing = (*ito)-&gt;propagate_bounds( <span class="keyword">this</span> );
<a name="l06528"></a>06528   }
<a name="l06529"></a>06529   <span class="keywordflow">return</span> keepgoing;
<a name="l06530"></a>06530 }
<a name="l06531"></a>06531 
<a name="l06532"></a>06532 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06533"></a><a class="code" href="classmc_1_1FPRelax.html#a1d4f8b79ad0d4a0b25d16d9ea0784c37">06533</a> <a class="code" href="classmc_1_1FPRelax.html#a1d4f8b79ad0d4a0b25d16d9ea0784c37" title="Generate reduction constraints via Liberti &amp; Pantelides&#39;s RRLT approach.">FPRelax&lt;T&gt;::generate_reduction_constraints</a>()
<a name="l06534"></a>06534 {
<a name="l06535"></a>06535   <a class="code" href="classmc_1_1FPRRLT.html" title="C++ template class for reduced RLT constraint generation.">FPRRLT&lt;T&gt;</a> RRLT( _Vars, _Ops );
<a name="l06536"></a>06536   <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_RLTMap&amp; RLTCuts
<a name="l06537"></a>06537     = RRLT.<a class="code" href="classmc_1_1FPRRLT.html#ae1ec5dd75c2239386de2e1398612ea2e" title="Identify valid reduction constraints with the possible candidate multiplier variables.">map_RLT</a>( options.RRLT_STRATEGY, options.RRLT_DISPLAY );
<a name="l06538"></a>06538   <span class="keyword">typename</span> FPRRLT&lt;T&gt;::cit_RLTMap it = RLTCuts.begin();
<a name="l06539"></a>06539 
<a name="l06540"></a>06540   <span class="keywordflow">for</span>( ; it != RLTCuts.end(); ++it ){
<a name="l06541"></a>06541     <span class="keywordflow">switch</span>( (*it).first.second ){
<a name="l06542"></a>06542     <span class="comment">// Case reduction constraint via multiplier variable</span>
<a name="l06543"></a>06543     <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TIMES</a>:
<a name="l06544"></a>06544       <span class="keywordflow">switch</span>( (*it).second-&gt;type ){
<a name="l06545"></a>06545         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>:
<a name="l06546"></a>06546           *(*it).first.first * *(*it).second-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a>
<a name="l06547"></a>06547             == *(*it).first.first * *(*it).second-&gt;prop;
<a name="l06548"></a>06548           <span class="keywordflow">break</span>;
<a name="l06549"></a>06549         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>:
<a name="l06550"></a>06550           *(*it).first.first * *(*it).second-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> - Op&lt;T&gt;::l((*it).first.first-&gt;I())
<a name="l06551"></a>06551             * ( *(*it).second-&gt;plop - *(*it).second-&gt;prop )
<a name="l06552"></a>06552             &lt;= *(*it).first.first * *(*it).second-&gt;prop;
<a name="l06553"></a>06553           *(*it).first.first * *(*it).second-&gt;plop - Op&lt;T&gt;::u((*it).first.first-&gt;I())
<a name="l06554"></a>06554             * ( *(*it).second-&gt;plop - *(*it).second-&gt;prop )
<a name="l06555"></a>06555             &gt;= *(*it).first.first * *(*it).second-&gt;prop;
<a name="l06556"></a>06556           <span class="keywordflow">break</span>;
<a name="l06557"></a>06557         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::PLUS</a>:
<a name="l06558"></a>06558           *(*it).first.first * *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>
<a name="l06559"></a>06559             == *(*it).first.first * *(*it).second-&gt;plop
<a name="l06560"></a>06560              + *(*it).first.first * *(*it).second-&gt;prop;
<a name="l06561"></a>06561           <span class="keywordflow">break</span>;
<a name="l06562"></a>06562         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::NEG</a>:
<a name="l06563"></a>06563           *(*it).first.first * *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>
<a name="l06564"></a>06564             + *(*it).first.first * *(*it).second-&gt;plop == 0;
<a name="l06565"></a>06565           <span class="keywordflow">break</span>;
<a name="l06566"></a>06566         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MINUS</a>:
<a name="l06567"></a>06567           *(*it).first.first * *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>
<a name="l06568"></a>06568             == *(*it).first.first * *(*it).second-&gt;plop
<a name="l06569"></a>06569              - *(*it).first.first * *(*it).second-&gt;prop;
<a name="l06570"></a>06570           <span class="keywordflow">break</span>;
<a name="l06571"></a>06571         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SCALE</a>:
<a name="l06572"></a>06572           *(*it).first.first * *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a>
<a name="l06573"></a>06573             == ( *(*it).first.first * *(*it).second-&gt;plop )
<a name="l06574"></a>06574              * *(*it).second-&gt;prop;
<a name="l06575"></a>06575           <span class="keywordflow">break</span>;
<a name="l06576"></a>06576         <span class="keywordflow">default</span>:
<a name="l06577"></a>06577           <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l06578"></a>06578       }
<a name="l06579"></a>06579       <span class="keywordflow">break</span>;
<a name="l06580"></a>06580       
<a name="l06581"></a>06581     <span class="comment">// Case reduction constraint via divider variable</span>
<a name="l06582"></a>06582     <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::DIV</a>:
<a name="l06583"></a>06583       <span class="keywordflow">if</span>( Op&lt;T&gt;::l((*it).first.first-&gt;I()) * Op&lt;T&gt;::u((*it).first.first-&gt;I()) &lt;= 0. )
<a name="l06584"></a>06584         <span class="keywordflow">break</span>;
<a name="l06585"></a>06585       <span class="keywordflow">switch</span>( (*it).second-&gt;type ){
<a name="l06586"></a>06586         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a>:
<a name="l06587"></a>06587           *(*it).second-&gt;<a class="code" href="group__FP.html#ga41ee92b90a9acd9b6d85a581dd0470a3" title="Pointer to left operand.">plop</a> / *(*it).first.first
<a name="l06588"></a>06588             == *(*it).second-&gt;prop / *(*it).first.first;
<a name="l06589"></a>06589           <span class="keywordflow">break</span>;
<a name="l06590"></a>06590         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a>:
<a name="l06591"></a>06591           <span class="comment">//*(*it).first.first * *(*it).second-&gt;plop - Op&lt;T&gt;::l((*it).first.first-&gt;I())</span>
<a name="l06592"></a>06592           <span class="comment">//  * ( *(*it).second-&gt;plop - *(*it).second-&gt;prop )</span>
<a name="l06593"></a>06593           <span class="comment">//  &lt;= *(*it).first.first * *(*it).second-&gt;prop;</span>
<a name="l06594"></a>06594           <span class="comment">//*(*it).first.first * *(*it).second-&gt;plop - Op&lt;T&gt;::u((*it).first.first-&gt;I())</span>
<a name="l06595"></a>06595           <span class="comment">//  * ( *(*it).second-&gt;plop - *(*it).second-&gt;prop )</span>
<a name="l06596"></a>06596           <span class="comment">//  &gt;= *(*it).first.first * *(*it).second-&gt;prop;</span>
<a name="l06597"></a>06597           <span class="keywordflow">break</span>;
<a name="l06598"></a>06598         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::PLUS</a>:
<a name="l06599"></a>06599           *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> / *(*it).first.first
<a name="l06600"></a>06600             == *(*it).second-&gt;plop / *(*it).first.first
<a name="l06601"></a>06601              + *(*it).second-&gt;prop / *(*it).first.first;
<a name="l06602"></a>06602           <span class="keywordflow">break</span>;
<a name="l06603"></a>06603         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::NEG</a>:
<a name="l06604"></a>06604            *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> / *(*it).first.first
<a name="l06605"></a>06605             + *(*it).second-&gt;plop / *(*it).first.first == 0;
<a name="l06606"></a>06606           <span class="keywordflow">break</span>;
<a name="l06607"></a>06607         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::MINUS</a>:
<a name="l06608"></a>06608           *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> / *(*it).first.first
<a name="l06609"></a>06609             == *(*it).second-&gt;plop / *(*it).first.first
<a name="l06610"></a>06610              - *(*it).second-&gt;prop / *(*it).first.first;
<a name="l06611"></a>06611           <span class="keywordflow">break</span>;
<a name="l06612"></a>06612         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::SCALE</a>:
<a name="l06613"></a>06613           *(*it).second-&gt;<a class="code" href="group__FP.html#ga1db0b89e7d132630617645287796718d" title="Pointer to operation result.">pres</a> / *(*it).first.first
<a name="l06614"></a>06614             == ( *(*it).second-&gt;plop / *(*it).first.first )
<a name="l06615"></a>06615              * *(*it).second-&gt;prop;
<a name="l06616"></a>06616           <span class="keywordflow">break</span>;
<a name="l06617"></a>06617         <span class="keywordflow">default</span>:
<a name="l06618"></a>06618           <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l06619"></a>06619       }
<a name="l06620"></a>06620       <span class="keywordflow">break</span>;
<a name="l06621"></a>06621 
<a name="l06622"></a>06622     <span class="comment">// Oups - Reduction constraint undefined...</span>
<a name="l06623"></a>06623     <span class="keywordflow">default</span>:
<a name="l06624"></a>06624       <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l06625"></a>06625     }
<a name="l06626"></a>06626   }
<a name="l06627"></a>06627 }
<a name="l06628"></a>06628 
<a name="l06629"></a>06629 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> mc::TModel&lt; FPVar&lt;T&gt; &gt;*
<a name="l06630"></a>06630 <a class="code" href="classmc_1_1FPRelax.html#a0979b2291106cf2fbd5447f8b6bee899" title="Build Taylor model environment mc::TModel&lt; FPVar&lt;U&gt; &gt; corresponding to environment mc::TModel&lt;U&gt; TM...">FPRelax&lt;T&gt;::create_TModel</a>
<a name="l06631"></a><a class="code" href="classmc_1_1FPRelax.html#a0979b2291106cf2fbd5447f8b6bee899">06631</a> ( <span class="keyword">const</span> mc::TModel&lt;U&gt;*TM, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub )
<a name="l06632"></a>06632 {
<a name="l06633"></a>06633   <span class="comment">// Build Taylor model environment mc::TModel&lt; FPVar&lt;T&gt; &gt;</span>
<a name="l06634"></a>06634   <span class="keywordflow">if</span>( !TM ) <span class="keywordflow">return</span> 0;
<a name="l06635"></a>06635   <span class="keyword">typedef</span> mc::TModel&lt; FPVar&lt;T&gt; &gt; TMFPT;
<a name="l06636"></a>06636   <span class="keyword">typedef</span> mc::TVar&lt; FPVar&lt;T&gt; &gt; TVFPT;
<a name="l06637"></a>06637   TMFPT *TMFP = <span class="keyword">new</span> TMFPT( TM-&gt;nvar(), TM-&gt;nord() );
<a name="l06638"></a>06638   TMFP-&gt;options = TM-&gt;options;
<a name="l06639"></a>06639   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;TM-&gt;nvar(); ix++ ){
<a name="l06640"></a>06640     <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pVar = _find_var( pt_idVar( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::VARCONT</a>, isub?isub[ix]:ix ) );
<a name="l06641"></a>06641     <span class="keywordflow">if</span>( !pVar ) pVar = _find_var( pt_idVar( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::VARBIN</a>, isub?isub[ix]:ix ) );
<a name="l06642"></a>06642     <span class="comment">// Throw exception if variable ix+ioff is undefined</span>
<a name="l06643"></a>06643     <span class="keywordflow">if</span>( !pVar ) <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INIT</a> );
<a name="l06644"></a>06644     TVFPT TVFP( TMFP, ix, *pVar );
<a name="l06645"></a>06645   }
<a name="l06646"></a>06646   <span class="keywordflow">return</span> TMFP;
<a name="l06647"></a>06647 }
<a name="l06648"></a>06648 
<a name="l06649"></a>06649 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06650"></a>06650 <a class="code" href="classmc_1_1FPRelax.html#abacbf0ab1918b92aa5520e5073fe05bc" title="Update Taylor model environment mc::TModel&lt; FPVar&lt;U&gt; &gt; corresponding to environment mc::TModel&lt;U&gt; TM...">FPRelax&lt;T&gt;::update_TModel</a>
<a name="l06651"></a><a class="code" href="classmc_1_1FPRelax.html#abacbf0ab1918b92aa5520e5073fe05bc">06651</a> ( mc::TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP, <span class="keyword">const</span> mc::TModel&lt;U&gt;*TM,
<a name="l06652"></a>06652   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*isub )
<a name="l06653"></a>06653 {
<a name="l06654"></a>06654   <span class="keywordflow">if</span>( !TM || !TMFP || TMFP-&gt;nvar()!=TM-&gt;nvar() )
<a name="l06655"></a>06655     <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INIT</a> );
<a name="l06656"></a>06656 
<a name="l06657"></a>06657   <span class="comment">// Update Taylor model environment mc::TModel&lt; FPVar&lt;T&gt; &gt;</span>
<a name="l06658"></a>06658   <span class="keyword">typedef</span> mc::TModel&lt; FPVar&lt;T&gt; &gt; TMFPT;
<a name="l06659"></a>06659   <span class="keyword">typedef</span> mc::TVar&lt; FPVar&lt;T&gt; &gt; TVFPT;
<a name="l06660"></a>06660   TMFP-&gt;options = TM-&gt;options;
<a name="l06661"></a>06661   TMFP-&gt;reset();
<a name="l06662"></a>06662   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;TM-&gt;nvar(); ix++ ){
<a name="l06663"></a>06663     <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*pVar = _find_var( pt_idVar( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::VARCONT</a>, isub?isub[ix]:ix ) );
<a name="l06664"></a>06664     <span class="keywordflow">if</span>( !pVar ) pVar = _find_var( pt_idVar( <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::VARBIN</a>, isub?isub[ix]:ix ) );
<a name="l06665"></a>06665     <span class="comment">// Throw exception if variable ix+ioff is undefined</span>
<a name="l06666"></a>06666     <span class="keywordflow">if</span>( !pVar ) <span class="keywordflow">throw</span> <span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPRelax&lt;T&gt;::Exceptions</a>( <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Exceptions::INIT</a> );
<a name="l06667"></a>06667     TVFPT TVFP( TMFP, ix, *pVar );
<a name="l06668"></a>06668   }
<a name="l06669"></a>06669 }
<a name="l06670"></a>06670 
<a name="l06671"></a>06671 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06672"></a>06672 <a class="code" href="classmc_1_1FPRelax.html#ad98673c4b979d11cc26ef7f0ff989481" title="Generate tightening constraints via Sherali&#39;s RLT approach for variables participating in the Taylor ...">FPRelax&lt;T&gt;::generate_RLT_TModel</a>
<a name="l06673"></a><a class="code" href="classmc_1_1FPRelax.html#ad98673c4b979d11cc26ef7f0ff989481">06673</a> ( mc::TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP )
<a name="l06674"></a>06674 {
<a name="l06675"></a>06675   <span class="keywordflow">if</span>( !TMFP || options.RLT_MAXORDER &lt; 2 ) <span class="keywordflow">return</span>;
<a name="l06676"></a>06676   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAXORD = ( options.RLT_MAXORDER &lt; TMFP-&gt;nord()?
<a name="l06677"></a>06677                           options.RLT_MAXORDER: TMFP-&gt;nord() );
<a name="l06678"></a>06678 
<a name="l06679"></a>06679   <span class="comment">// Generate RLT constraints up to order MAXORD</span>
<a name="l06680"></a>06680   std::list&lt; FPRLT&lt;T&gt;* &gt; RLT_lst;
<a name="l06681"></a>06681   RLT_lst.push_back( <span class="keyword">new</span> <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>( TMFP ) );
<a name="l06682"></a>06682   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iord=1; iord&lt;=MAXORD; iord++ ){
<a name="l06683"></a>06683     <span class="keyword">const</span> <span class="keywordtype">bool</span> disp = ( options.RLT_DISPLAY &gt;= 2
<a name="l06684"></a>06684                         || ( options.RLT_DISPLAY == 1 &amp;&amp; iord == MAXORD )?
<a name="l06685"></a>06685                         <span class="keyword">true</span>: <span class="keyword">false</span> );
<a name="l06686"></a>06686     <span class="keywordflow">if</span>( disp ) std::cout &lt;&lt; <span class="stringliteral">&quot;\nRLT Constraints: Order&quot;</span> &lt;&lt; iord &lt;&lt; std::endl;
<a name="l06687"></a>06687     _lift_RLT_TModel( TMFP, RLT_lst, disp );
<a name="l06688"></a>06688   }
<a name="l06689"></a>06689 
<a name="l06690"></a>06690   <span class="comment">// Append RLT cuts of order MAXORD</span>
<a name="l06691"></a>06691   _append_cuts_RLT_TModel( RLT_lst, MAXORD );
<a name="l06692"></a>06692 }
<a name="l06693"></a>06693  
<a name="l06694"></a>06694 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06695"></a>06695 <a class="code" href="classmc_1_1FPRelax.html#ad0cf327139aa537cc915a1befc0646d6" title="Append cuts for RLT constraints in RLT_lst">FPRelax&lt;T&gt;::_append_cuts_RLT_TModel</a>
<a name="l06696"></a><a class="code" href="classmc_1_1FPRelax.html#ad0cf327139aa537cc915a1befc0646d6">06696</a> ( std::list&lt; <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* &gt;&amp; RLT_lst, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nord )
<a name="l06697"></a>06697 {
<a name="l06698"></a>06698   <span class="comment">// Create new RLT operation - needed to order cuts</span>
<a name="l06699"></a>06699   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* op = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::RLT</a> );
<a name="l06700"></a>06700   _Ops.insert( op );
<a name="l06701"></a>06701 
<a name="l06702"></a>06702   <span class="comment">// Allocate variable indices/coefficient arrays (no more than 2*nord terms)</span>
<a name="l06703"></a>06703   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lhsmax = std::pow(2,nord);
<a name="l06704"></a>06704   std::pair&lt;typename FPVar&lt;T&gt;::pt_idVar*, <span class="keywordtype">double</span>*&gt; lhs
<a name="l06705"></a>06705     = make_pair( <span class="keyword">new</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>[lhsmax], <span class="keyword">new</span> <span class="keywordtype">double</span>[lhsmax] );
<a name="l06706"></a>06706 
<a name="l06707"></a>06707   <span class="comment">// Append all cuts in RLT list</span>
<a name="l06708"></a>06708   <span class="keyword">typedef</span> <span class="keyword">typename</span> std::list&lt; FPRLT&lt;T&gt;* &gt;::iterator it_RLT;
<a name="l06709"></a>06709   it_RLT it = RLT_lst.begin();
<a name="l06710"></a>06710   <span class="keywordflow">for</span>( ; it != RLT_lst.end(); ++it ){
<a name="l06711"></a>06711     <span class="comment">// Populate variable indices/coefficient arrays</span>
<a name="l06712"></a>06712     assert( (*it)-&gt;lhs2cut( lhs, lhsmax ) );
<a name="l06713"></a>06713     <span class="comment">// Append cut </span>
<a name="l06714"></a>06714     <span class="keyword">typename</span> <a class="code" href="group__FP.html#gaf42f21a24cd070666846afa763e6b755" title="Enumeration type for cuts and special sets.">FPCut&lt;T&gt;::TYPE</a> type = ( (*it)-&gt;type()==<a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;::LE</a>?
<a name="l06715"></a>06715                                      <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::LE</a>: <a class="code" href="classmc_1_1FPCut.html" title="C++ template class for defining cuts in the relaxation of factorable programs.">FPCut&lt;T&gt;::GE</a> );
<a name="l06716"></a>06716     _append_cut( op, type, (*it)-&gt;rhs(), (*it)-&gt;lhs().size(),
<a name="l06717"></a>06717                  lhs.first, lhs.second );
<a name="l06718"></a>06718     <span class="comment">// Clean up RLT entry</span>
<a name="l06719"></a>06719     <span class="keyword">delete</span> (*it); (*it) = 0;
<a name="l06720"></a>06720   }
<a name="l06721"></a>06721   <span class="comment">// Clean up index/coefficient arrays</span>
<a name="l06722"></a>06722   <span class="keyword">delete</span>[] lhs.first; <span class="keyword">delete</span>[] lhs.second;
<a name="l06723"></a>06723 }
<a name="l06724"></a>06724 
<a name="l06725"></a>06725 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06726"></a>06726 <a class="code" href="classmc_1_1FPRelax.html#a9ae269849d0f026ddafc47e67a3e45bc" title="Lift RLT constraints in RLT_lst by 1 order for variables participating in the Taylor model TMFP...">FPRelax&lt;T&gt;::_lift_RLT_TModel</a>
<a name="l06727"></a><a class="code" href="classmc_1_1FPRelax.html#a9ae269849d0f026ddafc47e67a3e45bc">06727</a> ( mc::TModel&lt; <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a> &gt;*TMFP, std::list&lt; <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* &gt;&amp; RLT_lst,
<a name="l06728"></a>06728   <span class="keyword">const</span> <span class="keywordtype">bool</span> disp )
<a name="l06729"></a>06729 {
<a name="l06730"></a>06730   <span class="comment">// Lift current RLT constraints by one order</span>
<a name="l06731"></a>06731   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlst = RLT_lst.size();
<a name="l06732"></a>06732   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ilst=0; ilst&lt;nlst; ilst++ ){
<a name="l06733"></a>06733     <span class="keyword">const</span> std::pair&lt;unsigned int,bool&gt; flag = (*RLT_lst.begin())-&gt;flag();
<a name="l06734"></a>06734 
<a name="l06735"></a>06735     <span class="comment">// Multiply every RLT constraint by every variable, avoiding duplicates</span>
<a name="l06736"></a>06736     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ivar=flag.first; ivar&lt; TMFP-&gt;nvar(); ivar++ ){
<a name="l06737"></a>06737       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ipos = TMFP-&gt;nvar() - ivar;
<a name="l06738"></a>06738       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ipb = ( ivar==flag.first? 1-flag.second: 0 );
<a name="l06739"></a>06739       <span class="keywordflow">for</span>( ; ipb&lt;=1; ipb++ ){
<a name="l06740"></a>06740         <span class="keyword">const</span> std::pair&lt;unsigned int,bool&gt; newflag( ivar, 1-ipb );
<a name="l06741"></a>06741         <span class="comment">//std::cout &lt;&lt; pTMFP_bnd[ipos] &lt;&lt; std::endl;</span>
<a name="l06742"></a>06742         <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* RLTprod = (*RLT_lst.begin())-&gt;product(
<a name="l06743"></a>06743           TMFP-&gt;bndmon()+ipos, TMFP-&gt;nvar(),
<a name="l06744"></a>06744           TMFP-&gt;expmon()+ipos*TMFP-&gt;nvar(), newflag
<a name="l06745"></a>06745         );
<a name="l06746"></a>06746         RLT_lst.push_back( RLTprod );  <span class="comment">// insert new RLT constraint for product with X-XL or X-XU</span>
<a name="l06747"></a>06747         <span class="keywordflow">if</span>( disp ) std::cout &lt;&lt; *RLTprod &lt;&lt; std::endl;
<a name="l06748"></a>06748       }
<a name="l06749"></a>06749     }
<a name="l06750"></a>06750 
<a name="l06751"></a>06751     <span class="comment">// Remove previous RLT constraint - Only keep new lifted RLT constraints</span>
<a name="l06752"></a>06752     <span class="keyword">delete</span> (*RLT_lst.begin());
<a name="l06753"></a>06753     RLT_lst.pop_front();
<a name="l06754"></a>06754   }
<a name="l06755"></a>06755   <span class="keywordflow">if</span>( disp ){ <span class="keywordtype">int</span> dum; std::cin &gt;&gt; dum; }
<a name="l06756"></a>06756 }
<a name="l06757"></a>06757 
<a name="l06759"></a>06759 
<a name="l06760"></a>06760 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::pair&lt;typename FPVar&lt;T&gt;::pt_idVar*, <span class="keywordtype">double</span>*&gt;
<a name="l06761"></a>06761 <a class="code" href="group__FP.html#ga193233685a7e543dadf781f809442f60" title="Generate and return pair of variables indices (pt_idVar*) and coefficient (double*) arrays for RLT co...">FPRLT&lt;T&gt;::lhs2cut</a>
<a name="l06762"></a><a class="code" href="group__FP.html#ga193233685a7e543dadf781f809442f60">06762</a> () <span class="keyword">const</span>
<a name="l06763"></a>06763 {
<a name="l06764"></a>06764   <span class="comment">// Allocate arrays of variable indices and coefficients</span>
<a name="l06765"></a>06765   <span class="keywordtype">double</span>*coef = <span class="keyword">new</span> <span class="keywordtype">double</span>[_lhs.size()];
<a name="l06766"></a>06766   <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>*<span class="keywordtype">id</span> = <span class="keyword">new</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>[_lhs.size()];
<a name="l06767"></a>06767 
<a name="l06768"></a>06768   <span class="comment">// Populate arrays of variable indices and coefficients</span>
<a name="l06769"></a>06769   <a class="code" href="classmc_1_1FPRLT.html#ac3ddd586348d20854178b3f2c7fdbaee" title="Typedef for left-hand side map const_iterator.">cit_lhs</a> cit = _lhs.begin();
<a name="l06770"></a>06770   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ilhs=0; cit != _lhs.end(); ++cit, ilhs++ ){
<a name="l06771"></a>06771     <span class="keywordtype">id</span>[ilhs] = (*cit).first-&gt;id();
<a name="l06772"></a>06772     coef[ilhs] = (*cit).second.coef;
<a name="l06773"></a>06773   }
<a name="l06774"></a>06774   <span class="keywordflow">return</span> std::make_pair(<span class="keywordtype">id</span>,coef);  
<a name="l06775"></a>06775 }
<a name="l06776"></a>06776 
<a name="l06777"></a>06777 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l06778"></a>06778 <a class="code" href="group__FP.html#ga193233685a7e543dadf781f809442f60" title="Generate and return pair of variables indices (pt_idVar*) and coefficient (double*) arrays for RLT co...">FPRLT&lt;T&gt;::lhs2cut</a>
<a name="l06779"></a><a class="code" href="group__FP.html#ga6ff646d71a617a1763c56e976bfd566a">06779</a> ( std::pair&lt;<span class="keyword">typename</span> <a class="code" href="group__FP.html#gac58e49145265586f1b33d8c5407732e6" title="Typedef for variable identifier in factorable program.">FPVar&lt;T&gt;::pt_idVar</a>*, <span class="keywordtype">double</span>*&gt;&amp;lhs,
<a name="l06780"></a>06780   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lhsmax ) <span class="keyword">const</span>
<a name="l06781"></a>06781 {
<a name="l06782"></a>06782   <span class="comment">//std::cout &lt;&lt; lhsmax &lt;&lt; &quot;  &quot; &lt;&lt; _lhs.size() &lt;&lt; std::endl;</span>
<a name="l06783"></a>06783   <span class="keywordflow">if</span>( _lhs.size() &gt; lhsmax ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l06784"></a>06784   
<a name="l06785"></a>06785   <span class="comment">// Populate arrays of variable indices and coefficients</span>
<a name="l06786"></a>06786   <a class="code" href="classmc_1_1FPRLT.html#ac3ddd586348d20854178b3f2c7fdbaee" title="Typedef for left-hand side map const_iterator.">cit_lhs</a> cit = _lhs.begin();
<a name="l06787"></a>06787   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ilhs=0; cit != _lhs.end(); ++cit, ilhs++ ){
<a name="l06788"></a>06788     lhs.first[ilhs] = (*cit).first-&gt;id();
<a name="l06789"></a>06789     lhs.second[ilhs] = (*cit).second.coef;
<a name="l06790"></a>06790   }
<a name="l06791"></a>06791   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l06792"></a>06792 }
<a name="l06793"></a>06793 
<a name="l06794"></a>06794 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>*
<a name="l06795"></a>06795 <a class="code" href="group__FP.html#ga771ea871eaf78f29d9f5fad614387f8c" title="Generate new RLT constraint by multiplying with (X-XL) or (X-XU) - flag indicates the current variabl...">FPRLT&lt;T&gt;::product</a>
<a name="l06796"></a><a class="code" href="group__FP.html#ga771ea871eaf78f29d9f5fad614387f8c">06796</a> ( <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>*Var, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nexp, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*iexp,
<a name="l06797"></a>06797   std::pair&lt;unsigned int, bool&gt; flag ) <span class="keyword">const</span>
<a name="l06798"></a>06798 {
<a name="l06799"></a>06799   <span class="comment">// Generate new RLT constraint via product with (X-XL) or (X-XU)</span>
<a name="l06800"></a>06800   <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>* RLT = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>( _pTM );
<a name="l06801"></a>06801 
<a name="l06802"></a>06802   <span class="comment">// Initialize RLT constraint</span>
<a name="l06803"></a>06803   <span class="keywordflow">if</span>( _lhs.empty() ){
<a name="l06804"></a>06804     RLT-&gt;_lhs.insert( <a class="code" href="group__FP.html#ga6b3480c95d85d534c1941dc3d05a4118" title="Typedef for left-hand side entry.">p_lhs</a>( Var, RLTTerm( 1., nexp, iexp ) ) );
<a name="l06805"></a>06805     RLT-&gt;_rhs = ( flag.second? Op&lt;T&gt;::l( Var-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() ): Op&lt;T&gt;::u( Var-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() ) );
<a name="l06806"></a>06806     RLT-&gt;_type = ( flag.second? GE: LE );
<a name="l06807"></a>06807     RLT-&gt;_flag = flag;
<a name="l06808"></a>06808     <span class="keywordflow">return</span> RLT;
<a name="l06809"></a>06809   }
<a name="l06810"></a>06810 
<a name="l06811"></a>06811   <span class="comment">// Account for LHS and RHS product with XL/XU</span>
<a name="l06812"></a>06812   <a class="code" href="classmc_1_1FPRLT.html#ac3ddd586348d20854178b3f2c7fdbaee" title="Typedef for left-hand side map const_iterator.">cit_lhs</a> cit = _lhs.begin();
<a name="l06813"></a>06813   <span class="keyword">const</span> <span class="keywordtype">double</span> c = ( flag.second? -Op&lt;T&gt;::l( Var-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() ): Op&lt;T&gt;::u( Var-&gt;<a class="code" href="group__FP.html#gaa8cf3ef06a111cf0ed3427989796176b" title="Get variable bounds.">I</a>() ) );
<a name="l06814"></a>06814   <span class="keywordflow">for</span>( ; !isequal( c, 0. ) &amp;&amp; cit != _lhs.end(); ++cit )
<a name="l06815"></a>06815     RLT-&gt;_lhs.insert(
<a name="l06816"></a>06816       <a class="code" href="group__FP.html#ga6b3480c95d85d534c1941dc3d05a4118" title="Typedef for left-hand side entry.">p_lhs</a>( (*cit).first, RLTTerm( c * (*cit).second.coef, nexp, (*cit).second.iexp ) )
<a name="l06817"></a>06817     );
<a name="l06818"></a>06818   RLT-&gt;_rhs = c * _rhs;
<a name="l06819"></a>06819 
<a name="l06820"></a>06820   <span class="comment">// Account for RHS product with X</span>
<a name="l06821"></a>06821   <a class="code" href="classmc_1_1FPRLT.html#a836077c92ae19821ac9540c25ff60819" title="Typedef for left-hand side map iterator.">it_lhs</a> it = RLT-&gt;_lhs.find( Var );
<a name="l06822"></a>06822   <span class="keywordflow">if</span>( !isequal( _rhs, 0. ) &amp;&amp; it != RLT-&gt;_lhs.end() ){
<a name="l06823"></a>06823     (*it).second.coef += ( flag.second? -_rhs: _rhs );
<a name="l06824"></a>06824     <span class="keywordflow">if</span>( isequal( (*it).second.coef, 0. ) ) RLT-&gt;_lhs.erase( it );
<a name="l06825"></a>06825   }
<a name="l06826"></a>06826   <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !isequal( _rhs, 0. ) )
<a name="l06827"></a>06827     RLT-&gt;_lhs.insert( <a class="code" href="group__FP.html#ga6b3480c95d85d534c1941dc3d05a4118" title="Typedef for left-hand side entry.">p_lhs</a>( Var, RLTTerm( ( flag.second? -_rhs: _rhs ), nexp, iexp ) ) );
<a name="l06828"></a>06828 
<a name="l06829"></a>06829   <span class="comment">// Account for LHS product with X</span>
<a name="l06830"></a>06830   cit = _lhs.begin();
<a name="l06831"></a>06831   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*iexpprod = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nexp];
<a name="l06832"></a>06832   assert( _pTM );
<a name="l06833"></a>06833   <span class="keywordflow">for</span>( ; cit != _lhs.end(); ++cit ){
<a name="l06834"></a>06834 
<a name="l06835"></a>06835     <span class="comment">// Location of new product term</span>
<a name="l06836"></a>06836     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nexp; i++ )
<a name="l06837"></a>06837       iexpprod[i] = (*cit).second.iexp[i] + iexp[i];
<a name="l06838"></a>06838     <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* Varprod = _pTM-&gt;bndmon() + _pTM-&gt;loc_expmon(iexpprod);
<a name="l06839"></a>06839     it = RLT-&gt;_lhs.find( Varprod );
<a name="l06840"></a>06840 
<a name="l06841"></a>06841     <span class="comment">// Account for new product term in LHS</span>
<a name="l06842"></a>06842     <span class="keywordflow">if</span>( !isequal( (*cit).second.coef, 0. ) &amp;&amp; it != RLT-&gt;_lhs.end() ){
<a name="l06843"></a>06843       (*it).second.coef += ( flag.second? (*cit).second.coef: -(*cit).second.coef );
<a name="l06844"></a>06844       <span class="keywordflow">if</span>( isequal( (*it).second.coef, 0. ) ) RLT-&gt;_lhs.erase( it );
<a name="l06845"></a>06845     }
<a name="l06846"></a>06846     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( !isequal( (*cit).second.coef, 0. ) )
<a name="l06847"></a>06847       RLT-&gt;_lhs.insert(
<a name="l06848"></a>06848         <a class="code" href="group__FP.html#ga6b3480c95d85d534c1941dc3d05a4118" title="Typedef for left-hand side entry.">p_lhs</a>( Varprod, RLTTerm( ( flag.second? (*cit).second.coef: -(*cit).second.coef ),
<a name="l06849"></a>06849                                  nexp, iexpprod ) )
<a name="l06850"></a>06850       );
<a name="l06851"></a>06851   }
<a name="l06852"></a>06852   <span class="keyword">delete</span>[] iexpprod;
<a name="l06853"></a>06853 
<a name="l06854"></a>06854   <span class="comment">// Set new RLT constraint sense and flag, then return</span>
<a name="l06855"></a>06855   RLT-&gt;_type = _type;
<a name="l06856"></a>06856   RLT-&gt;_flag = flag;
<a name="l06857"></a>06857   <span class="keywordflow">return</span> RLT;
<a name="l06858"></a>06858 }
<a name="l06859"></a>06859 
<a name="l06860"></a>06860 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> std::ostream&amp;
<a name="l06861"></a>06861 <span class="keyword">operator</span> &lt;&lt;
<a name="l06862"></a>06862 ( std::ostream&amp;out, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPRLT.html" title="C++ template class for RLT constraints in the relaxation of factorable programs involving Taylor mode...">FPRLT&lt;T&gt;</a>&amp;RLT )
<a name="l06863"></a>06863 {
<a name="l06864"></a>06864   <span class="keyword">const</span> <span class="keywordtype">int</span> iprec = 5;
<a name="l06865"></a>06865   out &lt;&lt; std::right &lt;&lt; std::scientific &lt;&lt; std::setprecision(iprec);
<a name="l06866"></a>06866 
<a name="l06867"></a>06867   <span class="comment">// RLT constraint is uninitialized</span>
<a name="l06868"></a>06868   <span class="keywordflow">if</span>( RLT._lhs.empty() ){
<a name="l06869"></a>06869     out &lt;&lt; <span class="stringliteral">&quot; Uninitialized RLT constraint&quot;</span>;
<a name="l06870"></a>06870     <span class="keywordflow">return</span> out;
<a name="l06871"></a>06871   }
<a name="l06872"></a>06872 
<a name="l06873"></a>06873   <span class="comment">// Display RLT constraint LHS</span>
<a name="l06874"></a>06874   <span class="keyword">typename</span> FPRLT&lt;T&gt;::cit_lhs it = RLT._lhs.begin();
<a name="l06875"></a>06875   <span class="keywordflow">for</span>( ; it != RLT._lhs.end(); ++it ){
<a name="l06876"></a>06876     <span class="keywordflow">if</span>( isequal( (*it).second.coef, 0. ) )
<a name="l06877"></a>06877       out &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::setw(iprec+6) &lt;&lt; 0.;
<a name="l06878"></a>06878     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (*it).second.coef &gt; 0. )
<a name="l06879"></a>06879       out &lt;&lt; <span class="stringliteral">&quot; + &quot;</span> &lt;&lt; std::setw(iprec+6) &lt;&lt;  (*it).second.coef;
<a name="l06880"></a>06880     <span class="keywordflow">else</span>
<a name="l06881"></a>06881       out &lt;&lt; <span class="stringliteral">&quot; - &quot;</span> &lt;&lt; std::setw(iprec+6) &lt;&lt; -(*it).second.coef;
<a name="l06882"></a>06882     out &lt;&lt; FPVar&lt;T&gt;::_name( (*it).first-&gt;id() );  
<a name="l06883"></a>06883   }
<a name="l06884"></a>06884   
<a name="l06885"></a>06885   <span class="comment">// Display RLT constraint sense</span>
<a name="l06886"></a>06886   <span class="keywordflow">switch</span>( RLT._type ){
<a name="l06887"></a>06887     <span class="keywordflow">case</span> FPRLT&lt;T&gt;::LE: out &lt;&lt; <span class="stringliteral">&quot; &lt;= &quot;</span>; <span class="keywordflow">break</span>;
<a name="l06888"></a>06888     <span class="keywordflow">case</span> FPRLT&lt;T&gt;::GE: out &lt;&lt; <span class="stringliteral">&quot; &gt;= &quot;</span>; <span class="keywordflow">break</span>;
<a name="l06889"></a>06889   }
<a name="l06890"></a>06890   
<a name="l06891"></a>06891   <span class="comment">// Display RLT constraint LHS</span>
<a name="l06892"></a>06892   out &lt;&lt; std::setw(iprec+6) &lt;&lt; RLT._rhs;
<a name="l06893"></a>06893   <span class="keywordflow">return</span> out;
<a name="l06894"></a>06894 }
<a name="l06895"></a>06895 
<a name="l06897"></a>06897 
<a name="l06898"></a>06898 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06899"></a>06899 FPRRLT&lt;T&gt;::_define_linear()
<a name="l06900"></a>06900 {
<a name="l06901"></a>06901   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlinOp = 6;
<a name="l06902"></a>06902   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> FPOp&lt;T&gt;::TYPE linOp[nlinOp] = { FPOp&lt;T&gt;::EQ,
<a name="l06903"></a>06903     FPOp&lt;T&gt;::LE, FPOp&lt;T&gt;::PLUS, FPOp&lt;T&gt;::NEG, FPOp&lt;T&gt;::MINUS, FPOp&lt;T&gt;::SCALE };
<a name="l06904"></a>06904 
<a name="l06905"></a>06905   <span class="comment">// Create subset of linear operations</span>
<a name="l06906"></a>06906   _linTerms  = subset_op( nlinOp, linOp );
<a name="l06907"></a>06907   <span class="keywordflow">if</span>( _display &gt;= 2 ){
<a name="l06908"></a>06908     std::cout &lt;&lt; <span class="stringliteral">&quot;\nLINEAR TERMS ACCOUNTED FOR IN RLT:\n&quot;</span>;
<a name="l06909"></a>06909     <span class="keywordflow">for</span>( it_Ops it = _linTerms.begin(); it != _linTerms.end(); ++it )
<a name="l06910"></a>06910       std::cout &lt;&lt; *(*it) &lt;&lt; std::endl;
<a name="l06911"></a>06911   }
<a name="l06912"></a>06912   _nlinTerms = _linTerms.size();
<a name="l06913"></a>06913   <span class="keyword">delete</span>[] _TermVisited;
<a name="l06914"></a>06914   _TermVisited  = <span class="keyword">new</span> <span class="keywordtype">bool</span>[ _nlinTerms ];
<a name="l06915"></a>06915 
<a name="l06916"></a>06916   <span class="comment">// Create subset of variables participating in linear operations</span>
<a name="l06917"></a>06917   _linVars = subset_var( _linTerms );
<a name="l06918"></a>06918   <span class="keywordflow">if</span>( _display &gt;= 2 ){
<a name="l06919"></a>06919     std::cout &lt;&lt; <span class="stringliteral">&quot;\nVARIABLES PARTICIPATING IN RLT TERMS:\n&quot;</span>;
<a name="l06920"></a>06920     <span class="keywordflow">for</span>( it_Vars it = _linVars.begin(); it != _linVars.end(); ++it )
<a name="l06921"></a>06921       std::cout &lt;&lt; *(*it) &lt;&lt; std::endl;
<a name="l06922"></a>06922   }
<a name="l06923"></a>06923 
<a name="l06924"></a>06924   <span class="comment">// Create map of linear operations and participating variables</span>
<a name="l06925"></a>06925   _linEdges = submap_var( _linTerms );
<a name="l06926"></a>06926   <span class="keywordflow">if</span>( _display &gt;= 2 ){
<a name="l06927"></a>06927     std::cout &lt;&lt; <span class="stringliteral">&quot;\nRLT TERMS &lt;-&gt; VARIABLES EDGES:\n&quot;</span>;
<a name="l06928"></a>06928     <span class="keywordflow">for</span>( it_Vars_Ops it = _linEdges.begin(); it != _linEdges.end(); ++it )
<a name="l06929"></a>06929       std::cout &lt;&lt; *(*it).first &lt;&lt; <span class="stringliteral">&quot;  &lt;-&gt;  &quot;</span> &lt;&lt; *(*it).second &lt;&lt; std::endl;
<a name="l06930"></a>06930   }
<a name="l06931"></a>06931 
<a name="l06932"></a>06932   <span class="comment">// Update size of linear operation arrays</span>
<a name="l06933"></a>06933   <span class="keywordflow">if</span>( _nlinTerms == _linTerms.size() ) <span class="keywordflow">return</span>;
<a name="l06934"></a>06934   _nlinTerms = _linTerms.size();
<a name="l06935"></a>06935   <span class="keyword">delete</span>[] _TermVisited;
<a name="l06936"></a>06936   _TermVisited  = <span class="keyword">new</span> <span class="keywordtype">bool</span>[ _nlinTerms ];
<a name="l06937"></a>06937 }
<a name="l06938"></a>06938 
<a name="l06939"></a>06939 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06940"></a>06940 FPRRLT&lt;T&gt;::_define_bilinear()
<a name="l06941"></a>06941 {
<a name="l06942"></a>06942   <span class="comment">// subsets of bilinear terms</span>
<a name="l06943"></a>06943   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbilOp = 2;
<a name="l06944"></a>06944   <span class="keyword">static</span> <span class="keyword">typename</span> FPOp&lt;T&gt;::TYPE bilOp[nbilOp] = { FPOp&lt;T&gt;::TIMES,
<a name="l06945"></a>06945     FPOp&lt;T&gt;::BILIN };
<a name="l06946"></a>06946   _bilTerms  = subset_op( nbilOp, bilOp );
<a name="l06947"></a>06947 
<a name="l06948"></a>06948   <span class="comment">// subsets of fractional terms</span>
<a name="l06949"></a>06949   _divTerms  = subset_op( FPOp&lt;T&gt;::DIV );
<a name="l06950"></a>06950 
<a name="l06951"></a>06951   <span class="comment">// subsets of square terms</span>
<a name="l06952"></a>06952   _sqrTerms  = subset_op( FPOp&lt;T&gt;::SQR );
<a name="l06953"></a>06953 
<a name="l06954"></a>06954   <span class="comment">// subsets of square root terms</span>
<a name="l06955"></a>06955   _sqrtTerms = subset_op( FPOp&lt;T&gt;::SQRT );
<a name="l06956"></a>06956 }
<a name="l06957"></a>06957 
<a name="l06958"></a>06958 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l06959"></a>06959 FPRRLT&lt;T&gt;::_bigraph_RLT_mult
<a name="l06960"></a>06960 ( <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars &amp;linVars, <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars_Ops &amp;linEdges,
<a name="l06961"></a>06961   <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar&amp; idMult )
<a name="l06962"></a>06962 {
<a name="l06963"></a>06963   <span class="comment">// Erase those variables participating with &lt;a&gt;idMult&lt;/a&gt; in bilinear terms</span>
<a name="l06964"></a>06964   <span class="keywordflow">for</span>( cit_Ops it = _bilTerms.begin(); it != _bilTerms.end(); ++it ){
<a name="l06965"></a>06965     <span class="keywordflow">if</span>( (*it)-&gt;plop-&gt;id() == idMult ){
<a name="l06966"></a>06966       linVars.erase( (*it)-&gt;prop ); linEdges.erase( (*it)-&gt;prop );
<a name="l06967"></a>06967     }
<a name="l06968"></a>06968     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (*it)-&gt;prop-&gt;id() == idMult ){
<a name="l06969"></a>06969       linVars.erase( (*it)-&gt;plop ); linEdges.erase( (*it)-&gt;plop );
<a name="l06970"></a>06970     }
<a name="l06971"></a>06971   }
<a name="l06972"></a>06972 
<a name="l06973"></a>06973   <span class="comment">// Erase those variables participating with &lt;a&gt;idMult&lt;/a&gt; in fractional terms</span>
<a name="l06974"></a>06974   <span class="keywordflow">for</span>( cit_Ops it = _divTerms.begin(); it != _divTerms.end(); ++it ){
<a name="l06975"></a>06975     <span class="keywordflow">if</span>( (*it)-&gt;pres-&gt;id() == idMult ){
<a name="l06976"></a>06976       linVars.erase( (*it)-&gt;prop ); linEdges.erase( (*it)-&gt;prop );
<a name="l06977"></a>06977     }
<a name="l06978"></a>06978     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (*it)-&gt;prop-&gt;id() == idMult ){
<a name="l06979"></a>06979       linVars.erase( (*it)-&gt;pres ); linEdges.erase( (*it)-&gt;pres );
<a name="l06980"></a>06980     }
<a name="l06981"></a>06981   }
<a name="l06982"></a>06982 
<a name="l06983"></a>06983   <span class="comment">// Erase those variables participating with &lt;a&gt;idMult&lt;/a&gt; in square terms</span>
<a name="l06984"></a>06984   <span class="keywordflow">for</span>( cit_Ops it = _sqrTerms.begin(); it != _sqrTerms.end(); ++it ){
<a name="l06985"></a>06985     <span class="keywordflow">if</span>( (*it)-&gt;plop-&gt;id() == idMult ){
<a name="l06986"></a>06986       linVars.erase( (*it)-&gt;plop ); linEdges.erase( (*it)-&gt;plop );
<a name="l06987"></a>06987     }
<a name="l06988"></a>06988   }
<a name="l06989"></a>06989 
<a name="l06990"></a>06990   <span class="comment">// Erase those variables participating with &lt;a&gt;idMult&lt;/a&gt; in square root terms</span>
<a name="l06991"></a>06991   <span class="keywordflow">for</span>( cit_Ops it = _sqrtTerms.begin(); it != _sqrtTerms.end(); ++it ){
<a name="l06992"></a>06992     <span class="keywordflow">if</span>( (*it)-&gt;pres-&gt;id() == idMult ){
<a name="l06993"></a>06993       linVars.erase( (*it)-&gt;pres ); linEdges.erase( (*it)-&gt;pres );
<a name="l06994"></a>06994     }
<a name="l06995"></a>06995   }
<a name="l06996"></a>06996 
<a name="l06997"></a>06997   <span class="keywordflow">if</span>( _display &gt;= 2 ){
<a name="l06998"></a>06998     std::cout &lt;&lt; <span class="stringliteral">&quot;\nVARIABLES PARTICIPATING IN RLT TERMS,\n&quot;</span>
<a name="l06999"></a>06999               &lt;&lt; <span class="stringliteral">&quot;YET NOT PARTICIPATING IN ANY BILINEAR TERM WITH &quot;</span>
<a name="l07000"></a>07000               &lt;&lt; FPVar&lt;T&gt;::_name( idMult ) &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;
<a name="l07001"></a>07001     <span class="keywordflow">for</span>( cit_Vars itv = linVars.begin(); itv != linVars.end(); ++itv )
<a name="l07002"></a>07002       std::cout &lt;&lt; *(*itv) &lt;&lt; std::endl;
<a name="l07003"></a>07003     std::cout &lt;&lt; <span class="stringliteral">&quot;\nRLT GRAPH FOR : &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( idMult )
<a name="l07004"></a>07004               &lt;&lt; <span class="stringliteral">&quot;: OPERATION &lt;-&gt; VARIABLE\n&quot;</span>;
<a name="l07005"></a>07005     <span class="keywordflow">for</span>( cit_Vars_Ops itvo = linEdges.begin(); itvo != linEdges.end(); ++itvo )
<a name="l07006"></a>07006       std::cout &lt;&lt; *(*itvo).second &lt;&lt; <span class="stringliteral">&quot;  &lt;-&gt;  &quot;</span> &lt;&lt; *(*itvo).first &lt;&lt; std::endl;
<a name="l07007"></a>07007   }
<a name="l07008"></a>07008 }
<a name="l07009"></a>07009 
<a name="l07010"></a>07010 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l07011"></a>07011 FPRRLT&lt;T&gt;::_bigraph_RLT_div
<a name="l07012"></a>07012 ( <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars &amp;linVars, <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars_Ops &amp;linEdges,
<a name="l07013"></a>07013   <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar&amp; idDiv )
<a name="l07014"></a>07014 {
<a name="l07015"></a>07015   <span class="comment">// Erase &lt;a&gt;idDiv&lt;/a&gt; since division by itself yield 1</span>
<a name="l07016"></a>07016   <span class="keywordflow">for</span>( cit_Vars it = linVars.begin(); it != linVars.end(); ++it )
<a name="l07017"></a>07017     <span class="keywordflow">if</span>( (*it)-&gt;id() == idDiv ){ linVars.erase( *it ); <span class="keywordflow">break</span>; }
<a name="l07018"></a>07018 
<a name="l07019"></a>07019   <span class="comment">// Erase those variables participating with &lt;a&gt;idDiv&lt;/a&gt; in bilinear terms</span>
<a name="l07020"></a>07020   <span class="keywordflow">for</span>( cit_Ops it = _bilTerms.begin(); it != _bilTerms.end(); ++it ){
<a name="l07021"></a>07021     <span class="keywordflow">if</span>( (*it)-&gt;plop-&gt;id() == idDiv ){
<a name="l07022"></a>07022       linVars.erase( (*it)-&gt;pres ); linEdges.erase( (*it)-&gt;pres );
<a name="l07023"></a>07023     }
<a name="l07024"></a>07024     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (*it)-&gt;prop-&gt;id() == idDiv ){
<a name="l07025"></a>07025       linVars.erase( (*it)-&gt;pres ); linEdges.erase( (*it)-&gt;pres );
<a name="l07026"></a>07026     }
<a name="l07027"></a>07027   }
<a name="l07028"></a>07028 
<a name="l07029"></a>07029   <span class="comment">// Erase those variables participating with &lt;a&gt;idDiv&lt;/a&gt; in fractional terms</span>
<a name="l07030"></a>07030   <span class="keywordflow">for</span>( cit_Ops it = _divTerms.begin(); it != _divTerms.end(); ++it ){
<a name="l07031"></a>07031     <span class="keywordflow">if</span>( (*it)-&gt;pres-&gt;id() == idDiv ){
<a name="l07032"></a>07032       linVars.erase( (*it)-&gt;plop ); linEdges.erase( (*it)-&gt;plop );
<a name="l07033"></a>07033     }
<a name="l07034"></a>07034     <span class="keywordflow">else</span> <span class="keywordflow">if</span>( (*it)-&gt;prop-&gt;id() == idDiv ){
<a name="l07035"></a>07035       linVars.erase( (*it)-&gt;plop ); linEdges.erase( (*it)-&gt;plop );
<a name="l07036"></a>07036     }
<a name="l07037"></a>07037   }
<a name="l07038"></a>07038 
<a name="l07039"></a>07039   <span class="comment">// Erase those variables participating with &lt;a&gt;idDiv&lt;/a&gt; in square terms</span>
<a name="l07040"></a>07040   <span class="keywordflow">for</span>( cit_Ops it = _sqrTerms.begin(); it != _sqrTerms.end(); ++it ){
<a name="l07041"></a>07041     <span class="keywordflow">if</span>( (*it)-&gt;plop-&gt;id() == idDiv ){
<a name="l07042"></a>07042       linVars.erase( (*it)-&gt;pres ); linEdges.erase( (*it)-&gt;pres );
<a name="l07043"></a>07043     }
<a name="l07044"></a>07044   }
<a name="l07045"></a>07045 
<a name="l07046"></a>07046   <span class="comment">// Erase those variables participating with &lt;a&gt;idDiv&lt;/a&gt; in square root terms</span>
<a name="l07047"></a>07047   <span class="keywordflow">for</span>( cit_Ops it = _sqrtTerms.begin(); it != _sqrtTerms.end(); ++it ){
<a name="l07048"></a>07048     <span class="keywordflow">if</span>( (*it)-&gt;pres-&gt;id() == idDiv ){
<a name="l07049"></a>07049       linVars.erase( (*it)-&gt;plop ); linEdges.erase( (*it)-&gt;plop );
<a name="l07050"></a>07050     }
<a name="l07051"></a>07051   }
<a name="l07052"></a>07052 
<a name="l07053"></a>07053   <span class="keywordflow">if</span>( _display &gt;= 2 ){
<a name="l07054"></a>07054     std::cout &lt;&lt; <span class="stringliteral">&quot;\nVARIABLES PARTICIPATING IN RLT TERMS,\n&quot;</span>
<a name="l07055"></a>07055               &lt;&lt; <span class="stringliteral">&quot;YET NOT PARTICIPATING IN ANY FRACTIONAL TERM WITH &quot;</span>
<a name="l07056"></a>07056               &lt;&lt; FPVar&lt;T&gt;::_name( idDiv ) &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;
<a name="l07057"></a>07057     <span class="keywordflow">for</span>( cit_Vars itv = linVars.begin(); itv != linVars.end(); ++itv )
<a name="l07058"></a>07058       std::cout &lt;&lt; *(*itv) &lt;&lt; std::endl;
<a name="l07059"></a>07059     std::cout &lt;&lt; <span class="stringliteral">&quot;\nRLT GRAPH FOR : &quot;</span> &lt;&lt; FPVar&lt;T&gt;::_name( idDiv )
<a name="l07060"></a>07060               &lt;&lt; <span class="stringliteral">&quot;: OPERATION &lt;-&gt; VARIABLE\n&quot;</span>;
<a name="l07061"></a>07061     <span class="keywordflow">for</span>( cit_Vars_Ops itvo = linEdges.begin(); itvo != linEdges.end(); ++itvo )
<a name="l07062"></a>07062       std::cout &lt;&lt; *(*itvo).second &lt;&lt; <span class="stringliteral">&quot;  &lt;-&gt;  &quot;</span> &lt;&lt; *(*itvo).first &lt;&lt; std::endl;
<a name="l07063"></a>07063   }
<a name="l07064"></a>07064 }
<a name="l07065"></a>07065 
<a name="l07066"></a>07066 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l07067"></a>07067 FPRRLT&lt;T&gt;::_bigraph_RLT
<a name="l07068"></a>07068 ( <span class="keyword">const</span> <span class="keyword">typename</span> FPVar&lt;T&gt;::pt_idVar&amp; idVar, <span class="keyword">const</span> <span class="keyword">typename</span> FPOp&lt;T&gt;::TYPE&amp; idOp )
<a name="l07069"></a>07069 {
<a name="l07070"></a>07070   <span class="comment">// Initialize variable nodes and edges in bigraph</span>
<a name="l07071"></a>07071   _RLTVars = _linVars;
<a name="l07072"></a>07072   _RLTEdges = _linEdges;
<a name="l07073"></a>07073 
<a name="l07074"></a>07074   <span class="comment">// Erase those variables participating in nonlinear terms with variable &lt;a&gt;idVar&lt;/a&gt;</span>
<a name="l07075"></a>07075   <span class="keywordflow">switch</span>( idOp ){
<a name="l07076"></a>07076   <span class="keywordflow">case</span> FPOp&lt;T&gt;::TIMES:
<a name="l07077"></a>07077     _bigraph_RLT_mult( _RLTVars, _RLTEdges, idVar ); <span class="keywordflow">break</span>;
<a name="l07078"></a>07078   <span class="keywordflow">case</span> FPOp&lt;T&gt;::DIV:
<a name="l07079"></a>07079     _bigraph_RLT_div( _RLTVars, _RLTEdges, idVar );  <span class="keywordflow">break</span>;
<a name="l07080"></a>07080   <span class="keywordflow">default</span>:
<a name="l07081"></a>07081     <span class="keywordflow">throw</span> <span class="keyword">typename</span> FPRelax&lt;T&gt;::Exceptions( <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html#a7b76ecabddb09948e5f69f0c716b3284a16924b8a3445bf87649086a3e17eaa06" title="Internal error.">FPRelax&lt;T&gt;::Exceptions::INTERNAL</a> );
<a name="l07082"></a>07082   }
<a name="l07083"></a>07083 
<a name="l07084"></a>07084   <span class="comment">// Update size of RLT variable arrays</span>
<a name="l07085"></a>07085   <span class="keywordflow">if</span>(  _nRLTVars == _RLTVars.size() ) <span class="keywordflow">return</span>;
<a name="l07086"></a>07086   _nRLTVars = _RLTVars.size();
<a name="l07087"></a>07087   <span class="keyword">delete</span>[] _VarAssigned;
<a name="l07088"></a>07088   <span class="keyword">delete</span>[] _VarVisited;
<a name="l07089"></a>07089   _VarAssigned = <span class="keyword">new</span> pt_Op[ _nRLTVars ];
<a name="l07090"></a>07090   _VarVisited  = <span class="keyword">new</span> <span class="keywordtype">bool</span>[ _nRLTVars ];
<a name="l07091"></a>07091 }
<a name="l07092"></a>07092 
<a name="l07093"></a>07093 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_RLTMap&amp;
<a name="l07094"></a>07094 <a class="code" href="classmc_1_1FPRRLT.html#ae1ec5dd75c2239386de2e1398612ea2e" title="Identify valid reduction constraints with the possible candidate multiplier variables.">FPRRLT&lt;T&gt;::map_RLT</a>
<a name="l07095"></a><a class="code" href="classmc_1_1FPRRLT.html#ae1ec5dd75c2239386de2e1398612ea2e">07095</a> ( <span class="keyword">typename</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html#adcb99295f3b1ce277c1c6c19b73b544c" title="Enumeration type for reduced (R)RLT strategy.">FPRelax&lt;T&gt;::Options::RRLT</a> option, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> display )
<a name="l07096"></a>07096 {
<a name="l07097"></a>07097   <span class="comment">// No RLT constraint requested</span>
<a name="l07098"></a>07098   _RLTMap.clear();
<a name="l07099"></a>07099   <span class="comment">//if( option == FPRelax&lt;T&gt;::Options::NORRLT ) return _RLTMap;</span>
<a name="l07100"></a>07100   _display = display;
<a name="l07101"></a>07101 
<a name="l07102"></a>07102   <span class="comment">// Define subsets and map of linear operations and participating variables</span>
<a name="l07103"></a>07103   _define_linear();
<a name="l07104"></a>07104 
<a name="l07105"></a>07105   <span class="comment">// Define subsets of bilinear, fractional, square and square root terms</span>
<a name="l07106"></a>07106   _define_bilinear();
<a name="l07107"></a>07107 
<a name="l07108"></a>07108   <span class="comment">// MAIN LOOP: Valid RRLT cut for each candidate multiplier/divider variables</span>
<a name="l07109"></a>07109   <span class="keywordflow">for</span>( cit_Vars itVar = _Vars.begin(); itVar != _Vars.end(); ++itVar ){
<a name="l07110"></a>07110     <span class="keyword">const</span> pt_idVar&amp; idVar = (*itVar)-&gt;id();
<a name="l07111"></a>07111 
<a name="l07112"></a>07112     <span class="comment">// Multiplying/dividing constraints by a constant is worthless</span>
<a name="l07113"></a>07113     <span class="keywordflow">if</span>( idVar.first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a>
<a name="l07114"></a>07114       || idVar.first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> ) <span class="keywordflow">continue</span>;
<a name="l07115"></a>07115 
<a name="l07116"></a>07116     <span class="comment">// Multiplier/divider variables limited to primary variables (no auxiliary)</span>
<a name="l07117"></a>07117     <span class="keywordflow">if</span>( option == <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPRelax&lt;T&gt;::Options::PRIMRRLT</a>
<a name="l07118"></a>07118     &amp;&amp; ( idVar.first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXCONT</a>
<a name="l07119"></a>07119       || idVar.first == <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXBIN</a> ) ) <span class="keywordflow">continue</span>;
<a name="l07120"></a>07120 
<a name="l07121"></a>07121     <span class="comment">// Erase those variables participating in nonlinear terms multiplied by</span>
<a name="l07122"></a>07122     <span class="comment">// variable &lt;a&gt;idVar&lt;/a&gt;</span>
<a name="l07123"></a>07123     _bigraph_RLT( idVar, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TIMES</a> );
<a name="l07124"></a>07124 
<a name="l07125"></a>07125     <span class="comment">// Identify valid reduction constraints with the candidate multiplier</span>
<a name="l07126"></a>07126     <span class="comment">// variable</span>
<a name="l07127"></a>07127     _reduction_RLT( std::make_pair( (*itVar), <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TIMES</a> ) );
<a name="l07128"></a>07128 
<a name="l07129"></a>07129     <span class="comment">// Identify variables not yet participating in any bilinear terms with</span>
<a name="l07130"></a>07130     <span class="comment">// the candidate multiplier variable</span>
<a name="l07131"></a>07131     _bigraph_RLT( idVar, <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::DIV</a> );
<a name="l07132"></a>07132 
<a name="l07133"></a>07133     <span class="comment">// Identify valid reduction constraints with the candidate divider</span>
<a name="l07134"></a>07134     <span class="comment">// variable</span>
<a name="l07135"></a>07135     _reduction_RLT( std::make_pair( (*itVar), <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::DIV</a> ) );
<a name="l07136"></a>07136   }
<a name="l07137"></a>07137 
<a name="l07138"></a>07138   <span class="keywordflow">if</span>( _display &gt;= 1 ){
<a name="l07139"></a>07139     <span class="keywordflow">if</span>( _RLTMap.begin() == _RLTMap.end() )
<a name="l07140"></a>07140       std::cout &lt;&lt; <span class="stringliteral">&quot;\n NO VALID REDUCTION CONSTRAINTS FOUND\n&quot;</span>;
<a name="l07141"></a>07141     <span class="keywordflow">else</span>{
<a name="l07142"></a>07142       std::cout &lt;&lt; <span class="stringliteral">&quot;\n VALID REDUCTION CONSTRAINTS: &quot;</span>
<a name="l07143"></a>07143                 &lt;&lt; <span class="stringliteral">&quot; REDUCTION VARIABLE &lt;-TYPE-&gt; OPERATION\n&quot;</span>;
<a name="l07144"></a>07144       <span class="keywordflow">for</span>( cit_RLTMap it = _RLTMap.begin(); it != _RLTMap.end(); ++it ){
<a name="l07145"></a>07145         std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; *(*it).first.first &lt;&lt; <span class="stringliteral">&quot;  &lt;&quot;</span>;
<a name="l07146"></a>07146         <span class="keywordflow">switch</span>( (*it).first.second ){
<a name="l07147"></a>07147         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::TIMES</a>:
<a name="l07148"></a>07148           std::cout &lt;&lt; <span class="stringliteral">&quot;MULT&quot;</span>; <span class="keywordflow">break</span>;
<a name="l07149"></a>07149         <span class="keywordflow">case</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::DIV</a>:
<a name="l07150"></a>07150           std::cout &lt;&lt; <span class="stringliteral">&quot;DIV&quot;</span>;  <span class="keywordflow">break</span>;
<a name="l07151"></a>07151         <span class="keywordflow">default</span>:
<a name="l07152"></a>07152           std::cout &lt;&lt; <span class="stringliteral">&quot;???&quot;</span>;  <span class="keywordflow">break</span>;
<a name="l07153"></a>07153         }
<a name="l07154"></a>07154         std::cout &lt;&lt; <span class="stringliteral">&quot;&gt;  &quot;</span> &lt;&lt; *(*it).second &lt;&lt; std::endl;
<a name="l07155"></a>07155       }
<a name="l07156"></a>07156     }
<a name="l07157"></a>07157   }
<a name="l07158"></a>07158 
<a name="l07159"></a>07159   <span class="keywordflow">return</span> _RLTMap;
<a name="l07160"></a>07160 }
<a name="l07161"></a>07161 
<a name="l07162"></a>07162 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l07163"></a>07163 <a class="code" href="classmc_1_1FPRRLT.html" title="C++ template class for reduced RLT constraint generation.">FPRRLT&lt;T&gt;::_reduction_RLT</a>
<a name="l07164"></a>07164 ( <span class="keyword">const</span> t_RLTVar&amp; VarRed )
<a name="l07165"></a>07165 {
<a name="l07166"></a>07166   <span class="comment">// Matching initially empty</span>
<a name="l07167"></a>07167   <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a>* NA = 0;
<a name="l07168"></a>07168   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iv=0; iv&lt;_nRLTVars; iv++ )
<a name="l07169"></a>07169     _VarAssigned[iv] = std::make_pair( NA, 0 );
<a name="l07170"></a>07170 
<a name="l07171"></a>07171   <span class="comment">// Try to construct an augmenting emanating from each constraint</span>
<a name="l07172"></a>07172   cit_Ops ito = _linTerms.begin();
<a name="l07173"></a>07173   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> io=0; ito != _linTerms.end(); ++ito, io++ ){
<a name="l07174"></a>07174     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;_nlinTerms; j++ ) _TermVisited[j] = <span class="keyword">false</span>;
<a name="l07175"></a>07175     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_nRLTVars; i++ )  _VarVisited[i] = <span class="keyword">false</span>;
<a name="l07176"></a>07176     <span class="comment">// No augmenting emanating found from current constraint</span>
<a name="l07177"></a>07177     <span class="keywordflow">if</span>( !_augpath_RLT( std::make_pair(*ito,io) ) ){
<a name="l07178"></a>07178       cit_Ops jto = _linTerms.begin();
<a name="l07179"></a>07179       <span class="comment">// Append new valid reduction RLT constraints</span>
<a name="l07180"></a>07180       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jo=0; jto != _linTerms.end(); ++jto, jo++ )
<a name="l07181"></a>07181         <span class="keywordflow">if</span>( _TermVisited[jo] )
<a name="l07182"></a>07182           _RLTMap.insert( std::make_pair( VarRed, *jto ) );
<a name="l07183"></a>07183     }
<a name="l07184"></a>07184   }
<a name="l07185"></a>07185 }
<a name="l07186"></a>07186 
<a name="l07187"></a>07187 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keywordtype">bool</span>
<a name="l07188"></a>07188 FPRRLT&lt;T&gt;::_augpath_RLT
<a name="l07189"></a>07189 ( <span class="keyword">const</span> pt_Op&amp; pOp )
<a name="l07190"></a>07190 {
<a name="l07191"></a>07191   _TermVisited[pOp.second] = <span class="keyword">true</span>;
<a name="l07192"></a>07192 
<a name="l07193"></a>07193   <span class="comment">// Try and find immediate assignment</span>
<a name="l07194"></a>07194   cit_Vars itv = _RLTVars.begin();
<a name="l07195"></a>07195   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iv=0; itv != _RLTVars.end(); ++itv, iv++ ){
<a name="l07196"></a>07196     std::pair&lt; cit_Vars_Ops, cit_Vars_Ops &gt; rangeOp;
<a name="l07197"></a>07197     <span class="keywordflow">if</span>( _VarAssigned[iv].first ) <span class="keywordflow">continue</span>;
<a name="l07198"></a>07198     rangeOp = _RLTEdges.equal_range( *itv );
<a name="l07199"></a>07199     <span class="keywordflow">for</span>( cit_Vars_Ops itvo = rangeOp.first; itvo != rangeOp.second; ++itvo ){
<a name="l07200"></a>07200       <span class="keywordflow">if</span>( (*itvo).second != pOp.first ) <span class="keywordflow">continue</span>;
<a name="l07201"></a>07201       _VarAssigned[iv] = pOp;
<a name="l07202"></a>07202       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07203"></a>07203     }
<a name="l07204"></a>07204   }
<a name="l07205"></a>07205 
<a name="l07206"></a>07206   <span class="comment">// Try and find an augmenting path starting from another variable</span>
<a name="l07207"></a>07207   itv = _RLTVars.begin();
<a name="l07208"></a>07208   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iv=0; itv != _RLTVars.end(); ++itv, iv++ ){
<a name="l07209"></a>07209     std::pair&lt; cit_Vars_Ops, cit_Vars_Ops &gt; rangeOp;
<a name="l07210"></a>07210     <span class="keywordflow">if</span>( _VarVisited[iv] ) <span class="keywordflow">continue</span>;
<a name="l07211"></a>07211     rangeOp = _RLTEdges.equal_range( *itv );
<a name="l07212"></a>07212     <span class="keywordflow">for</span>( cit_Vars_Ops itvo = rangeOp.first; itvo != rangeOp.second; ++itvo ){
<a name="l07213"></a>07213       <span class="keywordflow">if</span>( (*itvo).second != pOp.first ) <span class="keywordflow">continue</span>;
<a name="l07214"></a>07214       _VarVisited[iv] = <span class="keyword">true</span>;
<a name="l07215"></a>07215       <span class="keywordflow">if</span>( !_augpath_RLT( _VarAssigned[iv] ) ) <span class="keywordflow">continue</span>;
<a name="l07216"></a>07216       _VarAssigned[iv] = pOp;
<a name="l07217"></a>07217       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07218"></a>07218     }
<a name="l07219"></a>07219   }
<a name="l07220"></a>07220 
<a name="l07221"></a>07221   <span class="comment">// Failed to find an augmenting path</span>
<a name="l07222"></a>07222   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07223"></a>07223 }
<a name="l07224"></a>07224 
<a name="l07225"></a>07225 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Ops
<a name="l07226"></a>07226 <a class="code" href="classmc_1_1FPRRLT.html#ada6dd0a2375b697c9ddccf47e0ee0300" title="Create subset of operations of given type.">FPRRLT&lt;T&gt;::subset_op</a>
<a name="l07227"></a><a class="code" href="classmc_1_1FPRRLT.html#ada6dd0a2375b697c9ddccf47e0ee0300">07227</a> ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nOp, <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a>*typeOp ) <span class="keyword">const</span>
<a name="l07228"></a>07228 {
<a name="l07229"></a>07229   <span class="comment">// Create subset of operations of given type</span>
<a name="l07230"></a>07230   t_Ops Ops;
<a name="l07231"></a>07231   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> refOp( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::CNST</a> );
<a name="l07232"></a>07232   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iOp=0; iOp&lt;nOp; iOp++ ){
<a name="l07233"></a>07233     refOp.<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> = typeOp[iOp];
<a name="l07234"></a>07234     std::pair&lt; cit_Ops, cit_Ops &gt; rangeOp = std::equal_range(
<a name="l07235"></a>07235       _Ops.begin(), _Ops.end(), &amp;refOp, <a class="code" href="structmc_1_1range__FPOp.html" title="C++ structure for comparing operations in a factorable program.">range_FPOp&lt;T&gt;</a>() );
<a name="l07236"></a>07236     Ops.insert( rangeOp.first, rangeOp.second );
<a name="l07237"></a>07237   }
<a name="l07238"></a>07238   <span class="keywordflow">return</span> Ops;
<a name="l07239"></a>07239 }
<a name="l07240"></a>07240 
<a name="l07241"></a>07241 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Ops
<a name="l07242"></a>07242 <a class="code" href="classmc_1_1FPRRLT.html#ada6dd0a2375b697c9ddccf47e0ee0300" title="Create subset of operations of given type.">FPRRLT&lt;T&gt;::subset_op</a>
<a name="l07243"></a><a class="code" href="classmc_1_1FPRRLT.html#a5d79b73e52ee1a84e70a5226872d0fca">07243</a> ( <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="group__FP.html#ga750f65fb8c16ed0c6a771fa22097c2c9" title="Enumeration type for unary and binary operations.">FPOp&lt;T&gt;::TYPE</a>&amp;typeOp ) <span class="keyword">const</span>
<a name="l07244"></a>07244 {
<a name="l07245"></a>07245   <span class="comment">// Create subset of operations of given type</span>
<a name="l07246"></a>07246   t_Ops Ops;
<a name="l07247"></a>07247   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;</a> refOp( <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::CNST</a> );
<a name="l07248"></a>07248   refOp.<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> = typeOp;
<a name="l07249"></a>07249   std::pair&lt; cit_Ops, cit_Ops &gt; rangeOp = std::equal_range(
<a name="l07250"></a>07250     _Ops.begin(), _Ops.end(), &amp;refOp, <a class="code" href="structmc_1_1range__FPOp.html" title="C++ structure for comparing operations in a factorable program.">range_FPOp&lt;T&gt;</a>() );
<a name="l07251"></a>07251   Ops.insert( rangeOp.first, rangeOp.second );
<a name="l07252"></a>07252   <span class="keywordflow">return</span> Ops;
<a name="l07253"></a>07253 }
<a name="l07254"></a>07254 
<a name="l07255"></a>07255 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars
<a name="l07256"></a>07256 <a class="code" href="classmc_1_1FPRRLT.html#adb37ba95851d28331ab76cefcad398be" title="Create subset of variables participating in operations Ops.">FPRRLT&lt;T&gt;::subset_var</a>
<a name="l07257"></a><a class="code" href="classmc_1_1FPRRLT.html#adb37ba95851d28331ab76cefcad398be">07257</a> ( <span class="keyword">const</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Ops&amp; Ops )
<a name="l07258"></a>07258 {
<a name="l07259"></a>07259   <span class="comment">// Create subset of variables participating in a set of operations Ops</span>
<a name="l07260"></a>07260   t_Vars Vars;
<a name="l07261"></a>07261   <span class="keywordflow">for</span>( cit_Ops it = Ops.begin(); it != Ops.end(); ++it ){
<a name="l07262"></a>07262     <span class="keywordflow">if</span>( (*it)-&gt;plop ){
<a name="l07263"></a>07263       <span class="keyword">const</span> pt_idVar&amp; idlop = (*it)-&gt;plop-&gt;id();
<a name="l07264"></a>07264       <span class="keywordflow">if</span>( idlop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> &amp;&amp; idlop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l07265"></a>07265         Vars.insert( (*it)-&gt;plop );
<a name="l07266"></a>07266     }
<a name="l07267"></a>07267     <span class="keywordflow">if</span>( (*it)-&gt;prop ){
<a name="l07268"></a>07268       <span class="keyword">const</span> pt_idVar&amp; idrop = (*it)-&gt;prop-&gt;id();
<a name="l07269"></a>07269       <span class="keywordflow">if</span>( idrop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> &amp;&amp; idrop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l07270"></a>07270         Vars.insert( (*it)-&gt;prop );
<a name="l07271"></a>07271     }
<a name="l07272"></a>07272     <span class="keywordflow">if</span>( (*it)-&gt;pres &amp;&amp; (*it)-&gt;type != <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a> &amp;&amp; (*it)-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> != <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a> ){
<a name="l07273"></a>07273       <span class="keyword">const</span> pt_idVar&amp; idres = (*it)-&gt;pres-&gt;id();
<a name="l07274"></a>07274       <span class="keywordflow">if</span>( idres.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> &amp;&amp; idres.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l07275"></a>07275         Vars.insert( (*it)-&gt;pres );
<a name="l07276"></a>07276     }
<a name="l07277"></a>07277   }
<a name="l07278"></a>07278   <span class="keywordflow">return</span> Vars;
<a name="l07279"></a>07279 }
<a name="l07280"></a>07280 
<a name="l07281"></a>07281 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Vars_Ops
<a name="l07282"></a>07282 <a class="code" href="classmc_1_1FPRRLT.html#aa148ee92664872e0f81a39ceac8067cf" title="Create subset of variables participating in operations Ops and corresponding edges.">FPRRLT&lt;T&gt;::submap_var</a>
<a name="l07283"></a><a class="code" href="classmc_1_1FPRRLT.html#aa148ee92664872e0f81a39ceac8067cf">07283</a> ( <span class="keyword">const</span> <span class="keyword">typename</span> FPRRLT&lt;T&gt;::t_Ops&amp; Ops )
<a name="l07284"></a>07284 {
<a name="l07285"></a>07285   <span class="comment">// Create subset of variables participating in operations Ops</span>
<a name="l07286"></a>07286   t_Vars_Ops Vars_Ops;
<a name="l07287"></a>07287   <span class="keywordflow">for</span>( cit_Ops it = Ops.begin(); it != Ops.end(); ++it ){
<a name="l07288"></a>07288     <span class="keywordflow">if</span>( (*it)-&gt;plop ){
<a name="l07289"></a>07289       <span class="keyword">const</span> pt_idVar&amp; idlop = (*it)-&gt;plop-&gt;id();
<a name="l07290"></a>07290       <span class="keywordflow">if</span>( idlop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> &amp;&amp; idlop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l07291"></a>07291         Vars_Ops.insert( std::make_pair( (*it)-&gt;plop, *it ) );
<a name="l07292"></a>07292     }
<a name="l07293"></a>07293     <span class="keywordflow">if</span>( (*it)-&gt;prop ){
<a name="l07294"></a>07294       <span class="keyword">const</span> pt_idVar&amp; idrop = (*it)-&gt;prop-&gt;id();
<a name="l07295"></a>07295       <span class="keywordflow">if</span>( idrop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> &amp;&amp; idrop.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l07296"></a>07296         Vars_Ops.insert( std::make_pair( (*it)-&gt;prop, *it ) );
<a name="l07297"></a>07297     }
<a name="l07298"></a>07298     <span class="keywordflow">if</span>( (*it)-&gt;pres &amp;&amp; (*it)-&gt;type != <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::EQ</a> &amp;&amp; (*it)-&gt;<a class="code" href="group__FP.html#gaba123d0aee8f88addedeae2265719d4a" title="Type of operation.">type</a> != <a class="code" href="classmc_1_1FPOp.html" title="C++ class for defining operations in a factorable program, and generating linear relaxations for such...">FPOp&lt;T&gt;::LE</a> ){
<a name="l07299"></a>07299       <span class="keyword">const</span> pt_idVar&amp; idres = (*it)-&gt;pres-&gt;id();
<a name="l07300"></a>07300       <span class="keywordflow">if</span>( idres.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXINT</a> &amp;&amp; idres.first != <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;::AUXREAL</a> )
<a name="l07301"></a>07301         Vars_Ops.insert( std::make_pair( (*it)-&gt;pres, *it ) );
<a name="l07302"></a>07302     }
<a name="l07303"></a>07303   }
<a name="l07304"></a>07304   <span class="keywordflow">return</span> Vars_Ops;
<a name="l07305"></a>07305 }
<a name="l07306"></a>07306 
<a name="l07307"></a>07307 } <span class="comment">// namespace mc</span>
<a name="l07308"></a>07308 
<a name="l07309"></a>07309 <span class="preprocessor">#include &quot;mcop.hpp&quot;</span>
<a name="l07310"></a>07310 
<a name="l07311"></a>07311 <span class="keyword">namespace </span>mc
<a name="l07312"></a>07312 {
<a name="l07313"></a>07313 
<a name="l07315"></a><a class="code" href="structmc_1_1Op_3_01mc_1_1FPVar_3_01T_01_4_01_4.html">07315</a> <span class="keyword">template</span> &lt;&gt; <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>Op&lt; mc::<a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar</a>&lt;T&gt; &gt;
<a name="l07316"></a>07316 {
<a name="l07317"></a>07317   <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">mc::FPVar&lt;T&gt;</a> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>;
<a name="l07318"></a>07318   <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">mc::FPRelax&lt;T&gt;</a> <a class="code" href="classmc_1_1FPRelax.html" title="C++ template base class for the definition and linear relaxation of factorable programs.">FPR</a>;
<a name="l07319"></a>07319   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> point( <span class="keyword">const</span> <span class="keywordtype">double</span> c ) { <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>(c); }
<a name="l07320"></a>07320   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> zeroone() { <span class="keywordflow">return</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>( mc::Op&lt;T&gt;::zeroone() ); }
<a name="l07321"></a>07321   <span class="keyword">static</span> <span class="keywordtype">void</span> I(<a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp;y) { x = y; }
<a name="l07322"></a>07322   <span class="keyword">static</span> <span class="keywordtype">double</span> l(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::l(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07323"></a>07323   <span class="keyword">static</span> <span class="keywordtype">double</span> u(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::u(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07324"></a>07324   <span class="keyword">static</span> <span class="keywordtype">double</span> abs (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::abs(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I);  }
<a name="l07325"></a>07325   <span class="keyword">static</span> <span class="keywordtype">double</span> mid (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::mid(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I);  }
<a name="l07326"></a>07326   <span class="keyword">static</span> <span class="keywordtype">double</span> diam(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::diam(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07327"></a>07327   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> inv (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::inv(x);  }
<a name="l07328"></a>07328   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> sqr (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::sqr(x);  }
<a name="l07329"></a>07329   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> sqrt(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::sqrt(x); }
<a name="l07330"></a>07330   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> log (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::log(x);  }
<a name="l07331"></a>07331   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> xlog(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::xlog(x); }
<a name="l07332"></a>07332   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> fabs(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::fabs(x); }
<a name="l07333"></a>07333   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> exp (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::exp(x);  }
<a name="l07334"></a>07334   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> sin (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::sin(x);  }
<a name="l07335"></a>07335   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> cos (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::cos(x);  }
<a name="l07336"></a>07336   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> tan (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::tan(x);  }
<a name="l07337"></a>07337   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> asin(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::asin(x); }
<a name="l07338"></a>07338   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> acos(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::acos(x); }
<a name="l07339"></a>07339   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> atan(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::atan(x); }
<a name="l07340"></a>07340   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> erf (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::erf(x);  }
<a name="l07341"></a>07341   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> erfc(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x) { <span class="keywordflow">return</span> mc::erfc(x); }
<a name="l07342"></a>07342   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> min (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y) { <span class="keywordflow">return</span> mc::min(x,y);  }
<a name="l07343"></a>07343   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> max (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y) { <span class="keywordflow">return</span> mc::max(x,y);  }
<a name="l07344"></a>07344   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> arh (<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <span class="keywordtype">double</span> k) { <span class="keywordflow">return</span> mc::arh(x,k); }
<a name="l07345"></a>07345   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y&gt; <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> pow(<span class="keyword">const</span> X&amp; x, <span class="keyword">const</span> Y&amp; y)
<a name="l07346"></a>07346     { <span class="keywordflow">return</span> mc::pow(x,y); }
<a name="l07347"></a>07347   <span class="keyword">static</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a> hull(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07348"></a>07348     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::hull(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07349"></a>07349   <span class="keyword">static</span> <span class="keywordtype">bool</span> inter(<a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; xIy, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07350"></a>07350     { <span class="keywordflow">try</span>{ xIy = x^y; <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l07351"></a>07351       <span class="keywordflow">catch</span>(<span class="keyword">typename</span> <a class="code" href="classmc_1_1FPRelax_1_1Exceptions.html" title="FPRelax exceptions.">FPR::Exceptions</a> &amp;eObj){ <span class="keywordflow">return</span> <span class="keyword">false</span>; } }
<a name="l07352"></a>07352   <span class="keyword">static</span> <span class="keywordtype">bool</span> eq(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07353"></a>07353     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::eq(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07354"></a>07354   <span class="keyword">static</span> <span class="keywordtype">bool</span> ne(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07355"></a>07355     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::ne(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07356"></a>07356   <span class="keyword">static</span> <span class="keywordtype">bool</span> lt(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07357"></a>07357     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::lt(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07358"></a>07358   <span class="keyword">static</span> <span class="keywordtype">bool</span> le(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07359"></a>07359     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::le(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07360"></a>07360   <span class="keyword">static</span> <span class="keywordtype">bool</span> gt(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07361"></a>07361     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::gt(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07362"></a>07362   <span class="keyword">static</span> <span class="keywordtype">bool</span> ge(<span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPV</a>&amp; y)
<a name="l07363"></a>07363     { <span class="keywordflow">return</span> mc::Op&lt;T&gt;::ge(x.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I,y.<a class="code" href="group__FP.html#ga25a22e7a82c6637f874b44edfa4b22c2" title="Get const reference to variable numeric field.">num</a>().I); }
<a name="l07364"></a>07364 };
<a name="l07365"></a>07365 
<a name="l07366"></a>07366 } <span class="comment">// namespace mc</span>
<a name="l07367"></a>07367 
<a name="l07368"></a>07368 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>fprelax.hpp</b>      </li>

    <li class="footer">Generated on Thu Feb 13 2014 20:08:11 for GOLIB by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
