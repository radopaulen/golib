<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GOLIB: global/odegpe.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GOLIB
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('odegpe_8hpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">odegpe.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright (C) 2012, 2014 Benoit Chachuat, Imperial College London.</span>
<a name="l00002"></a>00002 <span class="comment">// All Rights Reserved.</span>
<a name="l00003"></a>00003 <span class="comment">// This code is published under the Eclipse Public License.</span>
<a name="l00004"></a>00004 
<a name="l00284"></a>00284 <span class="preprocessor">#ifndef MC__ODEGPE_HPP</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor">#define MC__ODEGPE_HPP</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>
<a name="l00287"></a>00287 <span class="preprocessor">#define USE_CPLEX </span>
<a name="l00288"></a>00288 <span class="preprocessor"></span><span class="comment">//#undef USE_CPLEX</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00291"></a>00291 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00292"></a>00292 <span class="preprocessor">#include &quot;setinv.hpp&quot;</span>
<a name="l00293"></a>00293 <span class="preprocessor">#include &quot;pestruct.hpp&quot;</span>
<a name="l00294"></a>00294 <span class="preprocessor">#include &quot;odebnd_val.hpp&quot;</span>
<a name="l00295"></a>00295 <span class="preprocessor">#include &quot;odebnd_gsl.hpp&quot;</span>
<a name="l00296"></a>00296 <span class="preprocessor">#ifdef USE_CPLEX</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">  #include &quot;fprcplex.hpp&quot;</span>
<a name="l00298"></a>00298 <span class="preprocessor">#else</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span><span class="preprocessor">  #include &quot;fprgurobi.hpp&quot;</span>
<a name="l00300"></a>00300 <span class="preprocessor">#endif</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span><span class="preprocessor">#include &quot;structure.hpp&quot;</span>
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="preprocessor">#undef MC__ODEGPE_DEBUG</span>
<a name="l00304"></a>00304 <span class="preprocessor"></span><span class="preprocessor">#undef MC__ODEGPE_SHOW_FAILURE</span>
<a name="l00305"></a>00305 <span class="preprocessor"></span><span class="preprocessor">#undef MC__ODEGPE_SHOW_REDUCTION</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span><span class="preprocessor">#undef MC__ODEGPE_TRACE</span>
<a name="l00307"></a>00307 <span class="preprocessor"></span>
<a name="l00308"></a>00308 <span class="comment">/* TO DO:</span>
<a name="l00309"></a>00309 <span class="comment">- Describe options in documentation</span>
<a name="l00310"></a>00310 <span class="comment"></span>
<a name="l00311"></a>00311 <span class="comment">BUGS:</span>
<a name="l00312"></a>00312 <span class="comment">*/</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keyword">namespace </span>mc
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">//template &lt;typename T, typename PE&gt; class ODEGPENode;</span>
<a name="l00318"></a>00318 
<a name="l00320"></a>00320 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00321"></a><a class="code" href="classmc_1_1TMNode.html">00321</a> <span class="keyword">class </span><a class="code" href="classmc_1_1TMNode.html" title="Storage class for converged Taylor models of SetInvNode.">TMNode</a>
<a name="l00322"></a>00322 {
<a name="l00323"></a>00323 <span class="keyword">public</span>:
<a name="l00324"></a>00324   <a class="code" href="classmc_1_1TMNode.html" title="Storage class for converged Taylor models of SetInvNode.">TMNode</a>
<a name="l00325"></a>00325     ( TVar&lt;T&gt;**TVx, <span class="keyword">const</span> TModel&lt;T&gt;*TMx, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns )
<a name="l00326"></a>00326     : TVxk(TVx), _ns(ns)
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328       <span class="keywordflow">if</span>( !TVx || !TMx ) <span class="keywordflow">return</span>;
<a name="l00329"></a>00329       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> np = TMx-&gt;nvar();
<a name="l00330"></a>00330       scaling  = <span class="keyword">new</span> <span class="keywordtype">double</span>[np];
<a name="l00331"></a>00331       refpoint = <span class="keyword">new</span> <span class="keywordtype">double</span>[np];
<a name="l00332"></a>00332       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;np; ip++ ){
<a name="l00333"></a>00333         scaling[ip]  = TMx-&gt;scaling()[ip];
<a name="l00334"></a>00334         refpoint[ip] = TMx-&gt;reference()[ip];
<a name="l00335"></a>00335       }
<a name="l00336"></a>00336     }
<a name="l00337"></a>00337   ~<a class="code" href="classmc_1_1TMNode.html" title="Storage class for converged Taylor models of SetInvNode.">TMNode</a>()
<a name="l00338"></a>00338     {
<a name="l00339"></a>00339       <span class="keyword">delete</span>[] scaling;
<a name="l00340"></a>00340       <span class="keyword">delete</span>[] refpoint;
<a name="l00341"></a>00341       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_ns; is++ ) <span class="keyword">delete</span>[] TVxk[is];
<a name="l00342"></a>00342       <span class="keyword">delete</span>[] TVxk;
<a name="l00343"></a>00343     }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keywordtype">double</span> *scaling;
<a name="l00346"></a>00346   <span class="keywordtype">double</span> *refpoint;
<a name="l00347"></a>00347   TVar&lt;T&gt; **TVxk;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349   <span class="keywordtype">void</span> shift
<a name="l00350"></a>00350     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix, <span class="keyword">const</span> <span class="keywordtype">double</span>*refnew,
<a name="l00351"></a>00351       <span class="keyword">const</span> <span class="keywordtype">double</span>*scalnew, <span class="keywordtype">double</span>*coefupd )<span class="keyword"> const</span>
<a name="l00352"></a>00352 <span class="keyword">    </span>{
<a name="l00353"></a>00353       std::pair&lt;unsigned int, const double*&gt; TVxk_coef = TVxk[is][ix].coefmon();
<a name="l00354"></a>00354       TModel&lt;T&gt;* pTM = TVxk[is][ix].env();
<a name="l00355"></a>00355 
<a name="l00356"></a>00356       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> imon=0; imon&lt;TVxk_coef.first; imon++ )
<a name="l00357"></a>00357         coefupd[imon] = TVxk_coef.second[imon];
<a name="l00358"></a>00358       <span class="comment">// Case model is 0th-order or does not have an environment linked to it</span>
<a name="l00359"></a>00359       <span class="keywordflow">if</span>( !pTM || !pTM-&gt;nord() ) <span class="keywordflow">return</span>;
<a name="l00360"></a>00360       <span class="comment">// Adjust coefficients due to reference shift</span>
<a name="l00361"></a>00361       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iexp[pTM-&gt;nvar()];
<a name="l00362"></a>00362       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ivar=0; ivar&lt;pTM-&gt;nvar(); ivar++ ){
<a name="l00363"></a>00363         <span class="keyword">const</span> <span class="keywordtype">double</span> refshift = refnew[ivar]*scalnew[ivar]/scaling[ivar] - refpoint[ivar];
<a name="l00364"></a>00364         <span class="comment">//std::cout &lt;&lt; &quot;refshift[&quot; &lt;&lt; ivar &lt;&lt; &quot;]: &quot; &lt;&lt; refshift &lt;&lt; std::endl;</span>
<a name="l00365"></a>00365         <span class="comment">//if( refshift == 0. ) continue;//&lt; machprec() &amp;&amp; refshift &gt; -machprec() )</span>
<a name="l00366"></a>00366         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> imon=0; imon&lt;TVxk_coef.first; imon++ ){
<a name="l00367"></a>00367           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iord = 0;
<a name="l00368"></a>00368           <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kvar=0; kvar&lt;pTM-&gt;nvar(); kvar++ ){
<a name="l00369"></a>00369             iexp[kvar] = pTM-&gt;expmon()[imon*pTM-&gt;nvar()+kvar];
<a name="l00370"></a>00370             iord += iexp[kvar];
<a name="l00371"></a>00371           }
<a name="l00372"></a>00372           iexp[ivar]++;
<a name="l00373"></a>00373           <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=1; k&lt;=pTM-&gt;nord()-iord; k++, iexp[ivar]++ )
<a name="l00374"></a>00374             coefupd[imon] += coefupd[pTM-&gt;loc_expmon(iexp)] * pTM-&gt;get_binom(iexp[ivar],k)
<a name="l00375"></a>00375                            * std::pow(refshift,k);
<a name="l00376"></a>00376         }
<a name="l00377"></a>00377       }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379       <span class="comment">// Adjust coefficients due to scaling</span>
<a name="l00380"></a>00380       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> imon=0; imon&lt;TVxk_coef.first; imon++ )
<a name="l00381"></a>00381         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kvar=0; imon &amp;&amp; kvar&lt;pTM-&gt;nvar(); kvar++ )
<a name="l00382"></a>00382           coefupd[imon] *= std::pow( scalnew[kvar] / scaling[kvar],
<a name="l00383"></a>00383                                      pTM-&gt;expmon()[imon*pTM-&gt;nvar()+kvar] );
<a name="l00384"></a>00384     }
<a name="l00385"></a>00385   
<a name="l00386"></a>00386 <span class="keyword">private</span>:
<a name="l00387"></a>00387   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _ns;
<a name="l00388"></a>00388 };
<a name="l00389"></a>00389 
<a name="l00395"></a>00395 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00396"></a><a class="code" href="classmc_1_1ODEGPE.html">00396</a> <span class="keyword">class </span><a class="code" href="classmc_1_1ODEGPE.html" title="C++ class for guaranteed parameter estimation in dynamic systems using set inversion techniques...">ODEGPE</a>: <span class="keyword">protected</span> <a class="code" href="classmc_1_1SetInv.html" title="Pure virtual base class for set inversion.">SetInv</a>&lt; T, SetInvNode&lt; T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt; T,TMNode&lt;T&gt; &gt; &gt;, <span class="keyword">public</span> <a class="code" href="classmc_1_1PESTRUCT.html" title="C++ base class for dynamic optimization problem formulation.">PESTRUCT</a>
<a name="l00397"></a>00397 {
<a name="l00398"></a>00398   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> W&gt; <span class="keyword">friend</span> <span class="keyword">class </span>ODEGPENode;
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   <span class="comment">// Overloading stdout operator</span>
<a name="l00401"></a>00401   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> PU&gt; <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;
<a name="l00402"></a>00402     ( std::ostream&amp;os, <span class="keyword">const</span> <a class="code" href="classmc_1_1ODEGPE.html" title="C++ class for guaranteed parameter estimation in dynamic systems using set inversion techniques...">ODEGPE&lt;U,PU&gt;</a>&amp; );
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="keyword">public</span>:
<a name="l00405"></a>00405   <span class="keyword">typedef</span> Ellipsoid    E;
<a name="l00406"></a>00406   <span class="keyword">typedef</span> TModel&lt;T&gt;    TMT;
<a name="l00407"></a>00407   <span class="keyword">typedef</span> TVar&lt;T&gt;      TVT;
<a name="l00408"></a>00408 <span class="preprocessor">#ifdef USE_CPLEX</span>
<a name="l00409"></a>00409 <span class="preprocessor"></span>  <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPRCplex.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Cplex.">FPRCplex&lt;T&gt;</a>  <a class="code" href="classmc_1_1FPRCplex.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Cplex.">FPRT</a>;
<a name="l00410"></a>00410 <span class="preprocessor">#else</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span>  <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPRGurobi.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Gurobi.">FPRGurobi&lt;T&gt;</a> <a class="code" href="classmc_1_1FPRCplex.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Cplex.">FPRT</a>;
<a name="l00412"></a>00412 <span class="preprocessor">#endif</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span>  <span class="keyword">typedef</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>     <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVT</a>;
<a name="l00414"></a>00414   <span class="keyword">typedef</span> TModel&lt;FPVT&gt; TMFPVT;
<a name="l00415"></a>00415 
<a name="l00419"></a>00419 
<a name="l00420"></a>00420   <a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952" title="Constructor.">ODEGPE</a>();
<a name="l00421"></a>00421 
<a name="l00423"></a>00423   <span class="keyword">virtual</span> <a class="code" href="group__ODEGPE.html#ga33acdd38bf63da864e5a648a5e3d169e" title="Destructor.">~ODEGPE</a>();
<a name="l00424"></a>00424 
<a name="l00426"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html">00426</a>   <span class="keyword">struct </span><a class="code" href="structmc_1_1ODEGPE_1_1Options.html" title="ODEGPE options.">Options</a>
<a name="l00427"></a>00427   {
<a name="l00429"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a0e481a8e6ff5fa0f49bbd7c1fc118027">00429</a>     <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a0e481a8e6ff5fa0f49bbd7c1fc118027" title="Constructor.">Options</a>():
<a name="l00430"></a>00430       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a807f477ae380befd36b9b10849076291" title="IVP bounder.">IVP_BOUNDING_TYPE</a>(<a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abca22de61c38b0b34ba9325719dde2821a7" title="Taylor model.">TM</a>), <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a107dd9207ae111823c06fc35c8b6674a" title="IVP bounding method.">IVP_BOUNDING_PROPAGATION</a>(<a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fda5e5525c3cadde8d2199e1f2198251d02" title="Differential methods not accouting for truncation errors.">DINEQ</a>),
<a name="l00431"></a>00431       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a33ac70cb6606e5ade4cebabecad8c679" title="Order of Taylor/McCormick-Taylor model for IVP bounding.">TAYLOR_MODEL_ORDER</a>(2), <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a1b63b6aefea08c1db9b85a0aa87638f2" title="Whether to pre-process nodes using constraint propagation.">USE_CONSTRAINT_PROPAGATION</a>(false),
<a name="l00432"></a>00432       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ae733ea75dc969f1f600b1534750711d7" title="Whether to post-process nodes using optimality-based domain reduction.">USE_DOMAIN_REDUCTION</a>(true), <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a73dc942c18195093996c5ff1f161bc41" title="Maximum number of domain reduction loops per node.">DOMAIN_REDUCTION_MAXLOOPS</a>(4),
<a name="l00433"></a>00433       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ad77960a27b4ff673099076701ab3c89c" title="Threshold for repeating domain reduction (minimum domain reduction ratio)">DOMAIN_REDUCTION_THRESHOLD</a>(0.2), <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#af502bce16747b554fcb196e10f0d422d" title="Whether to tighten Taylor model relaxations using RLT constraints.">USE_RLT_TMODEL</a>(false),
<a name="l00434"></a>00434       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#af1c2dc23ac07e363a04d9d0c5f2c44be" title="Threshold for reusing Taylor models at a parent node w.r.t the Taylor remainder.">REUSE_TMODEL_THRESHOLD</a>(1e-7)
<a name="l00435"></a>00435       {}
<a name="l00437"></a>00437     <span class="keywordtype">void</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ac8236cb27236222c2f0bb9eef8286853" title="Display.">display</a>
<a name="l00438"></a>00438       ( std::ostream&amp;out ) <span class="keyword">const</span>;
<a name="l00440"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abc">00440</a>     <span class="keyword">enum</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abc" title="IVP bounder.">IVPBOUND</a>{
<a name="l00441"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abcad95715b3cd95e1dc678ce6b65c626df9">00441</a>       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abcad95715b3cd95e1dc678ce6b65c626df9" title="Interval analysis.">IA</a>=0, 
<a name="l00442"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abca22de61c38b0b34ba9325719dde2821a7">00442</a>       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abca22de61c38b0b34ba9325719dde2821a7" title="Taylor model.">TM</a>,   
<a name="l00443"></a>00443     };
<a name="l00445"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fd">00445</a>     <span class="keyword">enum</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fd" title="IVP bounding method.">IVPMETH</a>{
<a name="l00446"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fda5e5525c3cadde8d2199e1f2198251d02">00446</a>       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fda5e5525c3cadde8d2199e1f2198251d02" title="Differential methods not accouting for truncation errors.">DINEQ</a>=0, 
<a name="l00447"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fdac8e6986d987ccbef157075fbbb134222">00447</a>       <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fdac8e6986d987ccbef157075fbbb134222" title="Verified integration accounting for truncation errors.">VERIF</a> 
<a name="l00448"></a>00448     };
<a name="l00450"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a807f477ae380befd36b9b10849076291">00450</a>     <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a5f0275bd7615dd58b12faab4bd745abc" title="IVP bounder.">IVPBOUND</a> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a807f477ae380befd36b9b10849076291" title="IVP bounder.">IVP_BOUNDING_TYPE</a>;
<a name="l00452"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a107dd9207ae111823c06fc35c8b6674a">00452</a>     <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fd" title="IVP bounding method.">IVPMETH</a> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a107dd9207ae111823c06fc35c8b6674a" title="IVP bounding method.">IVP_BOUNDING_PROPAGATION</a>;
<a name="l00454"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a33ac70cb6606e5ade4cebabecad8c679">00454</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a33ac70cb6606e5ade4cebabecad8c679" title="Order of Taylor/McCormick-Taylor model for IVP bounding.">TAYLOR_MODEL_ORDER</a>;
<a name="l00456"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a1b63b6aefea08c1db9b85a0aa87638f2">00456</a>     <span class="keywordtype">bool</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a1b63b6aefea08c1db9b85a0aa87638f2" title="Whether to pre-process nodes using constraint propagation.">USE_CONSTRAINT_PROPAGATION</a>;
<a name="l00458"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ae733ea75dc969f1f600b1534750711d7">00458</a>     <span class="keywordtype">bool</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ae733ea75dc969f1f600b1534750711d7" title="Whether to post-process nodes using optimality-based domain reduction.">USE_DOMAIN_REDUCTION</a>;
<a name="l00460"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a73dc942c18195093996c5ff1f161bc41">00460</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#a73dc942c18195093996c5ff1f161bc41" title="Maximum number of domain reduction loops per node.">DOMAIN_REDUCTION_MAXLOOPS</a>;
<a name="l00462"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ad77960a27b4ff673099076701ab3c89c">00462</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ad77960a27b4ff673099076701ab3c89c" title="Threshold for repeating domain reduction (minimum domain reduction ratio)">DOMAIN_REDUCTION_THRESHOLD</a>;
<a name="l00464"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#af502bce16747b554fcb196e10f0d422d">00464</a>     <span class="keywordtype">bool</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#af502bce16747b554fcb196e10f0d422d" title="Whether to tighten Taylor model relaxations using RLT constraints.">USE_RLT_TMODEL</a>;
<a name="l00466"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#af1c2dc23ac07e363a04d9d0c5f2c44be">00466</a>     <span class="keywordtype">double</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#af1c2dc23ac07e363a04d9d0c5f2c44be" title="Threshold for reusing Taylor models at a parent node w.r.t the Taylor remainder.">REUSE_TMODEL_THRESHOLD</a>;
<a name="l00467"></a>00467   } options;
<a name="l00468"></a>00468 
<a name="l00470"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html">00470</a>   <span class="keyword">class </span><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html" title="ODEGPE exceptions.">Exceptions</a>
<a name="l00471"></a>00471   {
<a name="l00472"></a>00472   <span class="keyword">public</span>:
<a name="l00474"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bca">00474</a>     <span class="keyword">enum</span> <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bca" title="Enumeration type for ODEGPE exception handling.">TYPE</a>{
<a name="l00475"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa51231718540b475126c3a1f39a816e87">00475</a>       <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa51231718540b475126c3a1f39a816e87" title="Error in measurement data specification.">DATA</a>=0,  
<a name="l00476"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa9ab3e44f8ef4abccdf17d82a6506ec06">00476</a>       <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa9ab3e44f8ef4abccdf17d82a6506ec06" title="Error during variable domain reduction.">REDUC</a>,   
<a name="l00477"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa2fd206f69f2b7f6d1813678b7f604b3f">00477</a>       <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa2fd206f69f2b7f6d1813678b7f604b3f" title="Error due to calling a function/feature not yet implemented.">UNDEF</a>=-33   
<a name="l00478"></a>00478     };
<a name="l00480"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#aff8f5219df05ec15b8efb2ef1c51b745">00480</a>     <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#aff8f5219df05ec15b8efb2ef1c51b745" title="Constructor for error ierr">Exceptions</a>( <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bca" title="Enumeration type for ODEGPE exception handling.">TYPE</a> <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#ad86d441c23a250831f883904a47b7a9a" title="Inline function returning the error flag.">ierr</a> ) : _ierr( ierr ){}
<a name="l00482"></a><a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#ad86d441c23a250831f883904a47b7a9a">00482</a>     <span class="keywordtype">int</span> <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#ad86d441c23a250831f883904a47b7a9a" title="Inline function returning the error flag.">ierr</a>(){ <span class="keywordflow">return</span> _ierr; }
<a name="l00483"></a>00483     std::string what(){
<a name="l00484"></a>00484       <span class="keywordflow">switch</span>( _ierr ){
<a name="l00485"></a>00485       <span class="keywordflow">case</span> <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa51231718540b475126c3a1f39a816e87" title="Error in measurement data specification.">DATA</a>:
<a name="l00486"></a>00486         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error in measurement data specification&quot;</span>;
<a name="l00487"></a>00487       <span class="keywordflow">case</span> <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa9ab3e44f8ef4abccdf17d82a6506ec06" title="Error during variable domain reduction.">REDUC</a>:
<a name="l00488"></a>00488         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error during variable domain reduction&quot;</span>;
<a name="l00489"></a>00489       <span class="keywordflow">case</span> <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bcaa2fd206f69f2b7f6d1813678b7f604b3f" title="Error due to calling a function/feature not yet implemented.">UNDEF</a>: <span class="keywordflow">default</span>:
<a name="l00490"></a>00490         <span class="keywordflow">return</span> <span class="stringliteral">&quot;Error due to calling a feature not yet implemented in ODEGPE&quot;</span>;
<a name="l00491"></a>00491       }
<a name="l00492"></a>00492     }
<a name="l00493"></a>00493   <span class="keyword">private</span>:
<a name="l00494"></a>00494     <a class="code" href="classmc_1_1ODEGPE_1_1Exceptions.html#abb9101f8dd2819f7cf3051128d259bca" title="Enumeration type for ODEGPE exception handling.">TYPE</a> _ierr;
<a name="l00495"></a>00495   };
<a name="l00496"></a>00496 
<a name="l00498"></a><a class="code" href="structmc_1_1ODEGPE_1_1Stats.html">00498</a>   <span class="keyword">struct </span><a class="code" href="structmc_1_1ODEGPE_1_1Stats.html" title="Structure holding current statistics.">Stats</a>{
<a name="l00499"></a>00499     <span class="keywordtype">double</span> cumul_ODEBND;
<a name="l00500"></a>00500     <span class="keywordtype">double</span> cumul_FPREL;
<a name="l00501"></a>00501     <span class="keywordtype">double</span> cumul_REDUC;
<a name="l00502"></a>00502     <span class="keywordtype">double</span> cumul_SETINV;
<a name="l00503"></a>00503   } stats;
<a name="l00504"></a>00504 
<a name="l00506"></a><a class="code" href="structmc_1_1ODEGPE_1_1Data.html">00506</a>   <span class="keyword">struct </span><a class="code" href="structmc_1_1ODEGPE_1_1Data.html" title="Structure to hold measurement data.">Data</a>{
<a name="l00507"></a>00507     <a class="code" href="structmc_1_1ODEGPE_1_1Data.html" title="Structure to hold measurement data.">Data</a>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iy, <span class="keywordtype">double</span> yl, <span class="keywordtype">double</span> yu ):
<a name="l00508"></a>00508       stage(is), index(iy), lower(yl), upper(yu)
<a name="l00509"></a>00509       {}
<a name="l00510"></a>00510     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stage;
<a name="l00511"></a>00511     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l00512"></a>00512     <span class="keywordtype">double</span> lower;
<a name="l00513"></a>00513     <span class="keywordtype">double</span> upper;
<a name="l00514"></a>00514   };
<a name="l00515"></a>00515 
<a name="l00517"></a><a class="code" href="group__ODEGPE.html#gadd7c6767a3171e702c91523e4f6568ee">00517</a>   <span class="keyword">typename</span> <a class="code" href="classmc_1_1SetInv.html" title="Pure virtual base class for set inversion.">SetInv&lt; T, SetInvNode&lt; T,TMNode&lt;T&gt;</a> &gt;, <a class="code" href="structmc_1_1lt__SetInvNode.html" title="C++ structure for comparing SetInv Nodes.">lt_SetInvNode&lt; T,TMNode&lt;T&gt;</a> &gt; &gt;<a class="code" href="structmc_1_1ODEGPE_1_1Options.html" title="ODEGPE options.">::Options</a>&amp; <a class="code" href="group__ODEGPE.html#gadd7c6767a3171e702c91523e4f6568ee" title="Reference to SetInv options.">options_SetInv</a>()
<a name="l00518"></a>00518     { <span class="keywordflow">return</span> <a class="code" href="classmc_1_1SetInv.html" title="Pure virtual base class for set inversion.">SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt;, <a class="code" href="structmc_1_1lt__SetInvNode.html" title="C++ structure for comparing SetInv Nodes.">lt_SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt; &gt;::options; }
<a name="l00520"></a><a class="code" href="group__ODEGPE.html#ga6f8c6237a7d14746adff4674029df4f4">00520</a>   <span class="keyword">typename</span> ODEBND_VAL&lt;T,PE&gt;::Options&amp; <a class="code" href="group__ODEGPE.html#ga6f8c6237a7d14746adff4674029df4f4" title="Reference to ODEBND options.">options_ODEBND_VAL</a>()
<a name="l00521"></a>00521     { <span class="keywordflow">return</span> _pODEBND_VAL-&gt;options; }
<a name="l00523"></a><a class="code" href="group__ODEGPE.html#ga7df417433c4efafdee492867dd1dfaa5">00523</a>   <span class="keyword">typename</span> ODEBND_GSL&lt;T,PE&gt;::Options&amp; <a class="code" href="group__ODEGPE.html#ga7df417433c4efafdee492867dd1dfaa5" title="Reference to ODEBND_GSL options.">options_ODEBND_GSL</a>()
<a name="l00524"></a>00524     { <span class="keywordflow">return</span> _pODEBND_GSL-&gt;options; }
<a name="l00526"></a><a class="code" href="group__ODEGPE.html#ga75a9b8e6562fa11800c96ac70d0ad9ae">00526</a>   <span class="keyword">typename</span> <a class="code" href="structmc_1_1FPRelax_1_1Options.html" title="FPRelax options.">FPRelax&lt;T&gt;::Options</a>&amp; <a class="code" href="group__ODEGPE.html#ga75a9b8e6562fa11800c96ac70d0ad9ae" title="Reference to FPRelax options.">options_FPRelax</a>()
<a name="l00527"></a>00527     { <span class="keywordflow">return</span> _pFPR-&gt;options; }
<a name="l00529"></a><a class="code" href="group__ODEGPE.html#ga96d18293d46d04ad66c4df409e2032e4">00529</a>   <span class="keyword">typename</span> TModel&lt;T&gt;::Options&amp; <a class="code" href="group__ODEGPE.html#ga96d18293d46d04ad66c4df409e2032e4" title="Reference to Taylor model options.">options_TModel</a>()
<a name="l00530"></a>00530     { <span class="keywordflow">return</span> *_pTMOpt; }
<a name="l00531"></a>00531 
<a name="l00533"></a>00533   std::pair&lt;double,double&gt; <a class="code" href="group__ODEGPE.html#gae7e0148ec3590e9cfc93c1e5510c5892" title="Solve GPE problem -- return value is pair of inner-approximation and boundary volumes.">solve</a>
<a name="l00534"></a>00534     ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns, <span class="keyword">const</span> <span class="keywordtype">double</span>*tk, <span class="keyword">const</span> T*P,
<a name="l00535"></a>00535       <span class="keyword">const</span> std::list&lt; Data &gt;*Y, std::ostream&amp;os=std::cout );
<a name="l00537"></a>00537   <span class="keywordtype">void</span> <a class="code" href="group__ODEGPE.html#gafce9061bf7bcc5ae2b95c9bae8b604c2" title="Append all open nodes and inner nodes to, respectively, os_open and os_inner - Number of significant ...">output_stacks</a>
<a name="l00538"></a>00538     ( std::ostream&amp;os_open, std::ostream&amp;os_inner,
<a name="l00539"></a>00539       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DPREC=6 ) <span class="keyword">const</span>;
<a name="l00542"></a>00542 <span class="keyword">private</span>:
<a name="l00544"></a>00544   ODEBND_VAL&lt;T,PE&gt;* _pODEBND_VAL;
<a name="l00546"></a>00546   ODEBND_GSL&lt;T,PE&gt;* _pODEBND_GSL;
<a name="l00548"></a>00548 <span class="preprocessor">#ifdef USE_CPLEX</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>  <a class="code" href="classmc_1_1FPRCplex.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Cplex.">FPRCplex&lt;T&gt;</a>* _pFPR;
<a name="l00550"></a>00550 <span class="preprocessor">#else</span>
<a name="l00551"></a>00551 <span class="preprocessor"></span>  <a class="code" href="classmc_1_1FPRGurobi.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Gurobi.">FPRGurobi&lt;T&gt;</a>* _pFPR;
<a name="l00552"></a>00552 <span class="preprocessor">#endif</span>
<a name="l00553"></a>00553 <span class="preprocessor"></span>
<a name="l00554"></a>00554   <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVar&lt;T&gt;</a>* _pFPV;
<a name="l00556"></a>00556   TModel&lt;T&gt;* _pTM;
<a name="l00558"></a>00558   TModel&lt;FPVT&gt;* _pTMFP;
<a name="l00560"></a>00560   std::pair&lt;double,double&gt;* _pP;
<a name="l00562"></a>00562   <span class="keyword">typename</span> TModel&lt;T&gt;::Options* _pTMOpt;
<a name="l00563"></a>00563 
<a name="l00565"></a>00565   <a class="code" href="classmc_1_1Structure.html" title="C++ class for evaluation of the sparsity pattern of a factorable function.">Structure</a> _PEstruct[2];
<a name="l00567"></a>00567   std::set&lt;unsigned int&gt; _IVPdepend;
<a name="l00569"></a>00569   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *_IVPparam;
<a name="l00570"></a>00570 
<a name="l00572"></a>00572   <span class="keyword">struct </span>Internal{
<a name="l00573"></a>00573     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns;
<a name="l00574"></a>00574     <span class="keyword">const</span> <span class="keywordtype">double</span>*tk;  
<a name="l00575"></a>00575     <span class="keyword">const</span> T*P;
<a name="l00576"></a>00576     <span class="keyword">const</span> std::list&lt; Data &gt;*Y;
<a name="l00577"></a>00577   } _data;
<a name="l00578"></a>00578 
<a name="l00580"></a>00580   std::list&lt; TMNode&lt;T&gt;* &gt; _TMNodeList;
<a name="l00581"></a>00581 
<a name="l00583"></a>00583   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> assess
<a name="l00584"></a>00584     ( SetInvNode&lt;T,TMNode&lt;T&gt; &gt;*pNode );
<a name="l00585"></a>00585 
<a name="l00587"></a>00587   <span class="keywordtype">void</span> _set_PE_structure();
<a name="l00589"></a>00589   <span class="keywordtype">void</span> _init_IVP_relax();
<a name="l00590"></a>00590 
<a name="l00592"></a>00592   <span class="keywordtype">void</span> _relaxation_setup
<a name="l00593"></a>00593     ( <span class="keyword">const</span> T*P );
<a name="l00595"></a>00595   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _bound_IVP_IA
<a name="l00596"></a>00596     ( SetInvNode&lt;T,TMNode&lt;T&gt; &gt;*pNode, FPVT**FPVxk, <span class="keyword">typename</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fd" title="IVP bounding method.">Options::IVPMETH</a> meth );
<a name="l00598"></a>00598   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _bound_IVP_TM
<a name="l00599"></a>00599     ( SetInvNode&lt;T,TMNode&lt;T&gt; &gt;*pNode, FPVT**FPVxk, <span class="keyword">typename</span> <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#adb54f630c37b3bfbd1945ad4da5122fd" title="IVP bounding method.">Options::IVPMETH</a> meth );
<a name="l00600"></a>00600 
<a name="l00602"></a>00602   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _bound_output
<a name="l00603"></a>00603     ( <span class="keyword">const</span> T&amp;Iyk, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp;lo, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp;up );
<a name="l00605"></a>00605   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _bound_output
<a name="l00606"></a>00606     ( <span class="keyword">const</span> T*Ip, T* <span class="keyword">const</span>*Ixk );
<a name="l00608"></a>00608   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _bound_output
<a name="l00609"></a>00609     ( <span class="keyword">const</span> TVT*TVp, TVT* <span class="keyword">const</span>*TVxk );
<a name="l00610"></a>00610 
<a name="l00612"></a>00612   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _relax_outputs_constraints
<a name="l00613"></a>00613     ( FPVT*<span class="keyword">const</span>*FPVxk );
<a name="l00615"></a>00615   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;<a class="code" href="classmc_1_1SetInv.html#a744b2af4d0f42db4a87ba16ee60e7499" title="Status of subproblems.">::STATUS</a> _domain_reduction
<a name="l00616"></a>00616     ( FPVT*<span class="keyword">const</span>*FPVxk, T*P, <span class="keywordtype">double</span> &amp;maxred );
<a name="l00617"></a>00617 
<a name="l00619"></a>00619   <a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952" title="Constructor.">ODEGPE</a>(<span class="keyword">const</span> <a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952" title="Constructor.">ODEGPE</a>&amp;);
<a name="l00620"></a>00620   <a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952" title="Constructor.">ODEGPE</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952" title="Constructor.">ODEGPE</a>&amp;);
<a name="l00621"></a>00621 };
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00624"></a>00624 <span class="keyword">inline</span>
<a name="l00625"></a><a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952">00625</a> <a class="code" href="group__ODEGPE.html#gac6035094b4cf6d6b84974f93a1af8952" title="Constructor.">ODEGPE&lt;T,PE&gt;::ODEGPE</a>()
<a name="l00626"></a>00626 : <a class="code" href="classmc_1_1PESTRUCT.html" title="C++ base class for dynamic optimization problem formulation.">PESTRUCT</a>(PE())
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628   _pODEBND_VAL = <span class="keyword">new</span> ODEBND_VAL&lt;T,PE&gt;;
<a name="l00629"></a>00629   _pODEBND_GSL = <span class="keyword">new</span> ODEBND_GSL&lt;T,PE&gt;;
<a name="l00630"></a>00630   _pFPR      = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPRCplex.html" title="C++ template class for the definition and linear relaxation of factorable programs, and the solution of these relaxations using Cplex.">FPRT</a>;
<a name="l00631"></a>00631   _pFPV      = <span class="keyword">new</span> <a class="code" href="classmc_1_1FPVar.html" title="C++ template class for defining variables in a factorable program.">FPVT</a>[_np];
<a name="l00632"></a>00632   _pTM   = 0;
<a name="l00633"></a>00633   _pTMFP = 0;
<a name="l00634"></a>00634   _IVPparam = 0;
<a name="l00635"></a>00635   _pP = <span class="keyword">new</span> std::pair&lt;double,double&gt;[_np];
<a name="l00636"></a>00636   _pTMOpt = <span class="keyword">new</span> <span class="keyword">typename</span> TModel&lt;T&gt;::Options;
<a name="l00637"></a>00637 }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00640"></a>00640 <span class="keyword">inline</span>
<a name="l00641"></a><a class="code" href="group__ODEGPE.html#ga33acdd38bf63da864e5a648a5e3d169e">00641</a> <a class="code" href="group__ODEGPE.html#ga33acdd38bf63da864e5a648a5e3d169e" title="Destructor.">ODEGPE&lt;T,PE&gt;::~ODEGPE</a>()
<a name="l00642"></a>00642 {
<a name="l00643"></a>00643   <span class="keyword">delete</span> _pODEBND_VAL;
<a name="l00644"></a>00644   <span class="keyword">delete</span> _pODEBND_GSL;
<a name="l00645"></a>00645   <span class="keyword">delete</span> _pFPR;
<a name="l00646"></a>00646   <span class="keyword">delete</span>[] _pFPV;
<a name="l00647"></a>00647   <span class="keyword">delete</span> _pTM;
<a name="l00648"></a>00648   <span class="keyword">delete</span> _pTMFP;
<a name="l00649"></a>00649   <span class="keyword">delete</span>[] _IVPparam;
<a name="l00650"></a>00650   <span class="keyword">delete</span>[] _pP;
<a name="l00651"></a>00651   <span class="keyword">delete</span> _pTMOpt;
<a name="l00652"></a>00652   <span class="keyword">typename</span> std::list&lt; TMNode&lt;T&gt;* &gt;::iterator it = _TMNodeList.begin();
<a name="l00653"></a>00653   <span class="keywordflow">for</span>( ; it != _TMNodeList.end(); ++it ) <span class="keyword">delete</span> *it;
<a name="l00654"></a>00654 }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00657"></a>00657 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00658"></a>00658 <a class="code" href="group__ODEGPE.html#gafce9061bf7bcc5ae2b95c9bae8b604c2" title="Append all open nodes and inner nodes to, respectively, os_open and os_inner - Number of significant ...">ODEGPE&lt;T,PE&gt;::output_stacks</a>
<a name="l00659"></a><a class="code" href="group__ODEGPE.html#gafce9061bf7bcc5ae2b95c9bae8b604c2">00659</a> ( std::ostream&amp;os_open, std::ostream&amp;os_inner, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> DPREC ) <span class="keyword">const</span>
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661   <span class="keywordflow">return</span> <a class="code" href="classmc_1_1SetInv.html" title="Pure virtual base class for set inversion.">SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt;, <a class="code" href="structmc_1_1lt__SetInvNode.html" title="C++ structure for comparing SetInv Nodes.">lt_SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt; &gt;::output_stacks( os_open, os_inner, DPREC );
<a name="l00662"></a>00662 }
<a name="l00663"></a>00663 
<a name="l00664"></a>00664 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00665"></a>00665 <span class="keyword">inline</span> std::pair&lt;double,double&gt;
<a name="l00666"></a>00666 <a class="code" href="group__ODEGPE.html#gae7e0148ec3590e9cfc93c1e5510c5892" title="Solve GPE problem -- return value is pair of inner-approximation and boundary volumes.">ODEGPE&lt;T,PE&gt;::solve</a>
<a name="l00667"></a><a class="code" href="group__ODEGPE.html#gae7e0148ec3590e9cfc93c1e5510c5892">00667</a> ( <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns, <span class="keyword">const</span> <span class="keywordtype">double</span>*tk, <span class="keyword">const</span> T*P,
<a name="l00668"></a>00668   <span class="keyword">const</span> std::list&lt; Data &gt;*Y, std::ostream&amp;os )
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670   <span class="comment">// Keep track of time stages, bounds, and measurement data</span>
<a name="l00671"></a>00671   _data.tk = tk;
<a name="l00672"></a>00672   _data.ns = ns;
<a name="l00673"></a>00673   _data.P  = P;
<a name="l00674"></a>00674   _data.Y  = Y;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676   <span class="comment">// Keep track of execution times</span>
<a name="l00677"></a>00677   stats.cumul_ODEBND = stats.cumul_FPREL = stats.cumul_REDUC =
<a name="l00678"></a>00678   stats.cumul_SETINV = 0.;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="comment">// Clear list of converged Taylor models</span>
<a name="l00681"></a>00681   <span class="keyword">typename</span> std::list&lt; TMNode&lt;T&gt;* &gt;::iterator it = _TMNodeList.begin();
<a name="l00682"></a>00682   <span class="keywordflow">for</span>( ; it != _TMNodeList.end(); ++it ) <span class="keyword">delete</span> *it;
<a name="l00683"></a>00683   _TMNodeList.clear();
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   <span class="comment">// Determine PE problem structure</span>
<a name="l00686"></a>00686   _set_PE_structure();
<a name="l00687"></a>00687   _init_IVP_relax();
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <span class="comment">// Run set-inversion algorithm</span>
<a name="l00690"></a>00690   <a class="code" href="classmc_1_1SetInv.html" title="Pure virtual base class for set inversion.">SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt;, <a class="code" href="structmc_1_1lt__SetInvNode.html" title="C++ structure for comparing SetInv Nodes.">lt_SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt; &gt;::variables( _np, P );
<a name="l00691"></a>00691   stats.cumul_SETINV = -time();
<a name="l00692"></a>00692   <span class="keyword">const</span> std::pair&lt;double,double&gt;&amp; res = <a class="code" href="classmc_1_1SetInv.html" title="Pure virtual base class for set inversion.">SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt;, <a class="code" href="structmc_1_1lt__SetInvNode.html" title="C++ structure for comparing SetInv Nodes.">lt_SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt; &gt;::solve( os );
<a name="l00693"></a>00693   stats.cumul_SETINV += time();
<a name="l00694"></a>00694   <span class="keywordflow">return</span> res;
<a name="l00695"></a>00695 }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00698"></a>00698 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00699"></a>00699 <a class="code" href="classmc_1_1ODEGPE.html" title="C++ class for guaranteed parameter estimation in dynamic systems using set inversion techniques...">ODEGPE&lt;T,PE&gt;::_set_PE_structure</a>()
<a name="l00700"></a>00700 {
<a name="l00701"></a>00701   <span class="comment">// Initialize structure detection variables</span>
<a name="l00702"></a>00702   <a class="code" href="classmc_1_1Structure.html" title="C++ class for evaluation of the sparsity pattern of a factorable function.">Structure</a> *pS = <span class="keyword">new</span> <a class="code" href="classmc_1_1Structure.html" title="C++ class for evaluation of the sparsity pattern of a factorable function.">Structure</a>[_np];
<a name="l00703"></a>00703   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;_np; ip++ )
<a name="l00704"></a>00704     pS[ip].indep(ip);   
<a name="l00705"></a>00705   <a class="code" href="classmc_1_1Structure.html" title="C++ class for evaluation of the sparsity pattern of a factorable function.">Structure</a> **xkS = <span class="keyword">new</span> <a class="code" href="classmc_1_1Structure.html" title="C++ class for evaluation of the sparsity pattern of a factorable function.">Structure</a>*[_data.ns+1];
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">// detect structure of initial conditions in IVP</span>
<a name="l00708"></a>00708   xkS[0] = <span class="keyword">new</span> <a class="code" href="classmc_1_1Structure.html" title="C++ class for evaluation of the sparsity pattern of a factorable function.">Structure</a>[_nx];
<a name="l00709"></a>00709   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ ){
<a name="l00710"></a>00710     xkS[0][ix] = PE().IC( ix, pS );
<a name="l00711"></a>00711 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l00712"></a>00712 <span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;xkS[0][&quot;</span> &lt;&lt; ix &lt;&lt; <span class="stringliteral">&quot;] &lt;- &quot;</span> &lt;&lt; xkS[0][ix]
<a name="l00713"></a>00713               &lt;&lt; std::endl;
<a name="l00714"></a>00714 <span class="preprocessor">#endif</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span>  }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717   <span class="comment">// Detect structure of right-hand side in each stage in IVP</span>
<a name="l00718"></a>00718   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;_data.ns; is++ ){
<a name="l00719"></a>00719     xkS[is+1] = <span class="keyword">new</span> Structure[_nx];
<a name="l00720"></a>00720     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ )
<a name="l00721"></a>00721       xkS[is+1][ix] = PE().RHS( ix, pS, xkS[is], _data.tk[is], is ) + xkS[is][ix];
<a name="l00722"></a>00722     <span class="keywordtype">bool</span> iterate = <span class="keyword">true</span>;
<a name="l00723"></a>00723     <span class="keywordflow">while</span>( iterate ){
<a name="l00724"></a>00724       iterate = <span class="keyword">false</span>;
<a name="l00725"></a>00725       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ ){
<a name="l00726"></a>00726         Structure xiSnew = PE().RHS( ix, pS, xkS[is+1], _data.tk[is], is ) + xkS[is+1][ix];
<a name="l00727"></a>00727         <span class="keywordflow">if</span>( xkS[is+1][ix] != xiSnew ){
<a name="l00728"></a>00728      xkS[is+1][ix] = xiSnew; iterate = <span class="keyword">true</span>;
<a name="l00729"></a>00729    }
<a name="l00730"></a>00730       }
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ )
<a name="l00734"></a>00734       std::cout &lt;&lt; <span class="stringliteral">&quot;xkS[&quot;</span> &lt;&lt; is+1 &lt;&lt; <span class="stringliteral">&quot;][&quot;</span> &lt;&lt; ix &lt;&lt; <span class="stringliteral">&quot;] &lt;- &quot;</span> &lt;&lt; xkS[is+1][ix]
<a name="l00735"></a>00735                 &lt;&lt; std::endl;
<a name="l00736"></a>00736 <span class="preprocessor">#endif</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span>  }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739   <span class="comment">// Set IVP variable dependence in _IVPdepend</span>
<a name="l00740"></a>00740   _IVPdepend.clear();
<a name="l00741"></a>00741   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;_np; ip++ ){
<a name="l00742"></a>00742     <span class="keywordtype">bool</span> keepgoing = <span class="keyword">true</span>;
<a name="l00743"></a>00743     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; keepgoing &amp;&amp; ix&lt;_nx; ix++ ){
<a name="l00744"></a>00744       std::map&lt;int,bool&gt;&amp; IVPdep = xkS[_data.ns][ix].<a class="code" href="group__Structure.html#ga0756ae4ee24c842ab8bf042590cfc3e4" title="Determines if the current object is dependent on the variable of index ind">dep</a>();
<a name="l00745"></a>00745       std::map&lt;int,bool&gt;::iterator it = IVPdep.find(ip);
<a name="l00746"></a>00746       <span class="keywordflow">if</span>( it != IVPdep.end() ){
<a name="l00747"></a>00747         _IVPdepend.insert(ip);
<a name="l00748"></a>00748         keepgoing = <span class="keyword">false</span>;
<a name="l00749"></a>00749       }
<a name="l00750"></a>00750     }
<a name="l00751"></a>00751   }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   <span class="comment">// Detect structure of constraints (parameter dependence)</span>
<a name="l00754"></a>00754   _PEstruct[0] = 0.;
<a name="l00755"></a>00755   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ic=0; ic&lt;_nc; ic++ )
<a name="l00756"></a>00756     _PEstruct[0] += PE().CTR( ic, pS, xkS, _data.ns ).first;
<a name="l00757"></a>00757   <span class="keyword">typename</span> std::list&lt; Data &gt;::const_iterator cit = _data.Y-&gt;begin();
<a name="l00758"></a>00758   <span class="keywordflow">for</span>( ; cit != _data.Y-&gt;end(); ++cit ){
<a name="l00759"></a>00759     <span class="keywordflow">if</span>( (*cit).index &gt;= _ny || (*cit).stage &gt; _data.ns )
<a name="l00760"></a>00760       <span class="keywordflow">throw</span> Exceptions( Exceptions::DATA );
<a name="l00761"></a>00761     _PEstruct[0] += PE().OUT( (*cit).index, pS, xkS[(*cit).stage], (*cit).stage );
<a name="l00762"></a>00762   }
<a name="l00763"></a>00763 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l00764"></a>00764 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;PE &lt;- &quot;</span> &lt;&lt; _PEstruct[0] &lt;&lt; std::endl;
<a name="l00765"></a>00765   {<span class="keywordtype">int</span> dum; std::cin &gt;&gt; dum;}
<a name="l00766"></a>00766 <span class="preprocessor">#endif</span>
<a name="l00767"></a>00767 <span class="preprocessor"></span>
<a name="l00768"></a>00768   <span class="comment">// Variables to exclude from branching</span>
<a name="l00769"></a>00769   SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::_exclude_vars.clear();
<a name="l00770"></a>00770   std::map&lt;int,bool&gt;&amp; PEdep = _PEstruct[0].dep();
<a name="l00771"></a>00771   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;_np; ip++ ){
<a name="l00772"></a>00772     std::map&lt;int,bool&gt;::iterator it = PEdep.find(ip);
<a name="l00773"></a>00773     <span class="keywordflow">if</span>( it == PEdep.end() )
<a name="l00774"></a>00774       SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::_exclude_vars.insert(ip);
<a name="l00775"></a>00775   }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777   <span class="comment">// Structure of constraints (parameter &amp; state dependence)</span>
<a name="l00778"></a>00778   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0, ixs=_np; is&lt;=_data.ns; is++ )
<a name="l00779"></a>00779     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++, ixs++)
<a name="l00780"></a>00780       xkS[is][ix].indep(ixs);
<a name="l00781"></a>00781   _PEstruct[1] = 0.;
<a name="l00782"></a>00782   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ic=0; ic&lt;_nc; ic++ )
<a name="l00783"></a>00783     _PEstruct[1] += PE().CTR( ic, pS, xkS, _data.ns ).first;
<a name="l00784"></a>00784   cit = _data.Y-&gt;begin();
<a name="l00785"></a>00785   <span class="keywordflow">for</span>( ; cit != _data.Y-&gt;end(); ++cit ){
<a name="l00786"></a>00786     <span class="keywordflow">if</span>( (*cit).index &gt;= _ny || (*cit).stage &gt; _data.ns )
<a name="l00787"></a>00787       <span class="keywordflow">throw</span> Exceptions( Exceptions::DATA );
<a name="l00788"></a>00788     _PEstruct[1] += PE().OUT( (*cit).index, pS, xkS[(*cit).stage], (*cit).stage );
<a name="l00789"></a>00789   }
<a name="l00790"></a>00790 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;PE &lt;- &quot;</span> &lt;&lt; _PEstruct[1] &lt;&lt; std::endl;
<a name="l00792"></a>00792   {<span class="keywordtype">int</span> dum; std::cin &gt;&gt; dum;}
<a name="l00793"></a>00793 <span class="preprocessor">#endif</span>
<a name="l00794"></a>00794 <span class="preprocessor"></span>
<a name="l00795"></a>00795   <span class="comment">// clean up</span>
<a name="l00796"></a>00796   <span class="keyword">delete</span>[] pS;
<a name="l00797"></a>00797   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ )
<a name="l00798"></a>00798     <span class="keyword">delete</span>[] xkS[is];
<a name="l00799"></a>00799   <span class="keyword">delete</span>[] xkS;
<a name="l00800"></a>00800 }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00803"></a>00803 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l00804"></a>00804 ODEGPE&lt;T,PE&gt;::_init_IVP_relax
<a name="l00805"></a>00805 ()
<a name="l00806"></a>00806 {
<a name="l00807"></a>00807   <span class="keyword">delete</span> _pTM;   _pTM   = 0;
<a name="l00808"></a>00808   <span class="keyword">delete</span> _pTMFP; _pTMFP = 0;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="comment">// Match IVP parameters to PE problem in array _IVPparam</span>
<a name="l00811"></a>00811   <span class="keyword">delete</span>[] _IVPparam;
<a name="l00812"></a>00812   _IVPparam = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[_IVPdepend.size()];
<a name="l00813"></a>00813   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0, isub=0; ip&lt;_np; ip++ )
<a name="l00814"></a>00814     <span class="keywordflow">if</span>( _IVPdepend.find(ip) != _IVPdepend.end() ) _IVPparam[isub++] = ip;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keywordflow">switch</span>( options.IVP_BOUNDING_TYPE ){
<a name="l00817"></a>00817   <span class="comment">// Set Taylor model environments</span>
<a name="l00818"></a>00818   <span class="keywordflow">case</span> Options::TM:
<a name="l00819"></a>00819     _pTM = <span class="keyword">new</span> TMT( _IVPdepend.size(), options.TAYLOR_MODEL_ORDER );
<a name="l00820"></a>00820     _pTMFP = <span class="keyword">new</span> TMFPVT( _IVPdepend.size(), options.TAYLOR_MODEL_ORDER );
<a name="l00821"></a>00821     _pTMFP-&gt;options = _pTM-&gt;options = *_pTMOpt;
<a name="l00822"></a>00822     <span class="keywordflow">break</span>;
<a name="l00823"></a>00823   <span class="keywordflow">default</span>:
<a name="l00824"></a>00824     <span class="keywordflow">break</span>;
<a name="l00825"></a>00825   }
<a name="l00826"></a>00826 }
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00829"></a>00829 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l00830"></a>00830 ODEGPE&lt;T,PE&gt;::_bound_IVP_IA
<a name="l00831"></a>00831 ( SetInvNode&lt;T,TMNode&lt;T&gt; &gt;*pNode, FPVT**FPVxk, <span class="keyword">typename</span> Options::IVPMETH meth )
<a name="l00832"></a>00832 {
<a name="l00833"></a>00833   <span class="comment">// Set interval bounds for states at stage times</span>
<a name="l00834"></a>00834   stats.cumul_ODEBND -= time();
<a name="l00835"></a>00835   <span class="keyword">const</span> T* Ip = pNode-&gt;P();
<a name="l00836"></a>00836   T* Ixk[_data.ns+1];
<a name="l00837"></a>00837   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ )
<a name="l00838"></a>00838     Ixk[is] = <span class="keyword">new</span> T[_nx];
<a name="l00839"></a>00839   E Exk[_data.ns+1];
<a name="l00840"></a>00840   
<a name="l00841"></a>00841   <span class="comment">// Compute state bounds at stage times</span>
<a name="l00842"></a>00842   <span class="keywordtype">bool</span> failed = <span class="keyword">true</span>;
<a name="l00843"></a>00843   <span class="keywordflow">switch</span>( meth ){
<a name="l00844"></a>00844   <span class="keywordflow">case</span> Options::VERIF:
<a name="l00845"></a>00845     <span class="keywordflow">if</span>( _pODEBND_VAL-&gt;bounds( _data.ns, _data.tk, Ip, Ixk, Exk )
<a name="l00846"></a>00846         == ODEBND_VAL&lt;T,PE&gt;::NORMAL ) failed = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l00847"></a>00847   <span class="keywordflow">case</span> Options::DINEQ: <span class="keywordflow">default</span>:
<a name="l00848"></a>00848     <span class="keywordflow">if</span>( _pODEBND_GSL-&gt;bounds( _data.ns, _data.tk, Ip, Ixk )
<a name="l00849"></a>00849         == ODEBND_GSL&lt;T,PE&gt;::NORMAL ) failed = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851   <span class="keywordflow">if</span>( failed ){
<a name="l00852"></a>00852     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] Ixk[is];
<a name="l00853"></a>00853     stats.cumul_ODEBND += time();
<a name="l00854"></a>00854     <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::FAILURE;
<a name="l00855"></a>00855   }
<a name="l00856"></a>00856 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l00857"></a>00857 <span class="preprocessor"></span>  std::cout &lt;&lt; *_pODEBND_VAL;
<a name="l00858"></a>00858 <span class="preprocessor">#endif</span>
<a name="l00859"></a>00859 <span class="preprocessor"></span>  stats.cumul_ODEBND += time();
<a name="l00860"></a>00860 
<a name="l00861"></a>00861   <span class="comment">// Set current independent variables (_pFPV) and state variables (FPVxk)</span>
<a name="l00862"></a>00862   <span class="comment">//in FPRelax</span>
<a name="l00863"></a>00863   stats.cumul_FPREL -= time();
<a name="l00864"></a>00864   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS flag = _bound_output( Ip, Ixk );
<a name="l00865"></a>00865   <span class="keywordflow">if</span>( flag == SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED
<a name="l00866"></a>00866    &amp;&amp; options.USE_DOMAIN_REDUCTION ){   
<a name="l00867"></a>00867     _relaxation_setup( Ip );
<a name="l00868"></a>00868     std::map&lt;int,bool&gt;&amp; PEdep = _PEstruct[1].dep();
<a name="l00869"></a>00869     failed = <span class="keyword">false</span>;
<a name="l00870"></a>00870     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0, ixs=_np; !failed &amp;&amp; is&lt;=_data.ns; is++ )
<a name="l00871"></a>00871       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++, ixs++ ){
<a name="l00872"></a>00872         <span class="keywordflow">if</span>( Op&lt;T&gt;::diam(Ixk[is][ix]) &gt;= <a class="code" href="classmc_1_1PESTRUCT.html#a7c0940f536bbf16b87af18a41c664e99" title="Infinity.">PESTRUCT::INF</a> ){
<a name="l00873"></a>00873           failed = <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l00874"></a>00874         }
<a name="l00875"></a>00875         std::map&lt;int,bool&gt;::iterator it = PEdep.find(ixs);
<a name="l00876"></a>00876         <span class="keywordflow">if</span>( it!=PEdep.end() )
<a name="l00877"></a>00877           FPVxk[is][ix] = Ixk[is][ix];
<a name="l00878"></a>00878       }
<a name="l00879"></a>00879   }
<a name="l00880"></a>00880   stats.cumul_FPREL += time();
<a name="l00881"></a>00881   
<a name="l00882"></a>00882   <span class="comment">// Clean-up</span>
<a name="l00883"></a>00883   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] Ixk[is];
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="keywordflow">return</span> flag;
<a name="l00886"></a>00886 }
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00889"></a>00889 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l00890"></a>00890 ODEGPE&lt;T,PE&gt;::_bound_output
<a name="l00891"></a>00891 ( <span class="keyword">const</span> T*Ip, T* <span class="keyword">const</span>*Ixk )
<a name="l00892"></a>00892 {
<a name="l00893"></a>00893   <span class="keywordtype">bool</span> inner = <span class="keyword">true</span>;
<a name="l00894"></a>00894   <span class="keyword">typename</span> std::list&lt; Data &gt;::const_iterator cit = _data.Y-&gt;begin();
<a name="l00895"></a>00895   <span class="keywordflow">for</span>( ; cit != _data.Y-&gt;end(); ++cit ){
<a name="l00896"></a>00896     <span class="keywordflow">switch</span>( _bound_output( PE().OUT( (*cit).index, Ip, Ixk[(*cit).stage],
<a name="l00897"></a>00897                            (*cit).stage ), (*cit).lower, (*cit).upper ) ){
<a name="l00898"></a>00898       <span class="keywordflow">case</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER:
<a name="l00899"></a>00899         <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER;
<a name="l00900"></a>00900       <span class="keywordflow">case</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED:
<a name="l00901"></a>00901         inner = <span class="keyword">false</span>; <span class="keywordflow">continue</span>;
<a name="l00902"></a>00902       <span class="keywordflow">case</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INNER:
<a name="l00903"></a>00903       <span class="keywordflow">default</span>:
<a name="l00904"></a>00904         <span class="keywordflow">continue</span>;
<a name="l00905"></a>00905     }
<a name="l00906"></a>00906   }
<a name="l00907"></a>00907   <span class="keywordflow">return</span>( inner? SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INNER
<a name="l00908"></a>00908                : SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED );
<a name="l00909"></a>00909 }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l00912"></a>00912 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l00913"></a>00913 ODEGPE&lt;T,PE&gt;::_bound_IVP_TM
<a name="l00914"></a>00914 ( SetInvNode&lt;T,TMNode&lt;T&gt; &gt;*pNode, FPVT**FPVxk, <span class="keyword">typename</span> Options::IVPMETH meth )
<a name="l00915"></a>00915 {
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   <span class="comment">// Set Taylor models corresponding to parameters</span>
<a name="l00918"></a>00918   stats.cumul_ODEBND -= time();
<a name="l00919"></a>00919   <span class="keyword">const</span> T* Ip = pNode-&gt;P();
<a name="l00920"></a>00920   TVT TVp[_np];
<a name="l00921"></a>00921   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0, isub=0; ip&lt;_np; ip++ ){
<a name="l00922"></a>00922     <span class="keywordflow">if</span>( _IVPdepend.find(ip) != _IVPdepend.end() ){
<a name="l00923"></a>00923       TVp[ip] = TVT( _pTM, isub, Ip[ip] );
<a name="l00924"></a>00924       isub++;
<a name="l00925"></a>00925     }
<a name="l00926"></a>00926     <span class="keywordflow">else</span>
<a name="l00927"></a>00927       TVp[ip] = Ip[ip];
<a name="l00928"></a>00928   }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="comment">// Set Taylor model for states at stage times</span>
<a name="l00931"></a>00931   TVT** TVxk = <span class="keyword">new</span> TVT*[_data.ns+1];
<a name="l00932"></a>00932   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ )
<a name="l00933"></a>00933     TVxk[is] = <span class="keyword">new</span> TVT[_nx];
<a name="l00934"></a>00934   E Exk[_data.ns+1];
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   <span class="comment">// Check if a Taylor model is available at the parent node</span>
<a name="l00937"></a>00937   <span class="keywordtype">bool</span> failed = <span class="keyword">false</span>;
<a name="l00938"></a>00938   <span class="keywordtype">bool</span> TVxk_cvg = ( pNode-&gt;model()? <span class="keyword">true</span>: false );
<a name="l00939"></a>00939   <span class="keywordflow">if</span>( TVxk_cvg ){
<a name="l00940"></a>00940 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l00941"></a>00941 <span class="preprocessor"></span>    std::cerr &lt;&lt; <span class="stringliteral">&quot;existing Taylor model: &quot;</span> &lt;&lt; pNode-&gt;model() &lt;&lt; std::endl;
<a name="l00942"></a>00942 <span class="preprocessor">#endif</span>
<a name="l00943"></a>00943 <span class="preprocessor"></span>
<a name="l00944"></a>00944     <span class="comment">// Initialize Taylor model environment</span>
<a name="l00945"></a>00945     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0, isub=0; ip&lt;_np; ip++ )
<a name="l00946"></a>00946       <span class="keywordflow">if</span>( _IVPdepend.find(ip) != _IVPdepend.end() ){
<a name="l00947"></a>00947         TVp[ip] = TVT( _pTM, isub, Ip[ip] );
<a name="l00948"></a>00948 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l00949"></a>00949 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Model: TVp[&quot;</span> &lt;&lt; ip &lt;&lt; <span class="stringliteral">&quot;] =&quot;</span> &lt;&lt; TVp[ip];
<a name="l00950"></a>00950         { <span class="keywordtype">int</span> dum; std::cout &lt;&lt; <span class="stringliteral">&quot;\nPAUSED\n&quot;</span>; std::cin &gt;&gt; dum; }
<a name="l00951"></a>00951 <span class="preprocessor">#endif</span>
<a name="l00952"></a>00952 <span class="preprocessor"></span>       isub++;
<a name="l00953"></a>00953       }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     <span class="comment">// Assign state Taylor models</span>
<a name="l00956"></a>00956     <span class="keywordtype">double</span>*coefupd = <span class="keyword">new</span> <span class="keywordtype">double</span>[_pTM-&gt;nmon()];
<a name="l00957"></a>00957     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ){
<a name="l00958"></a>00958       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ ){
<a name="l00959"></a>00959 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l00960"></a>00960 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Model: TVxk[&quot;</span> &lt;&lt; is &lt;&lt; <span class="stringliteral">&quot;][&quot;</span> &lt;&lt; ix &lt;&lt; <span class="stringliteral">&quot;] =&quot;</span> &lt;&lt; pNode-&gt;model()-&gt;TVxk[is][ix];
<a name="l00961"></a>00961 <span class="preprocessor">#endif</span>
<a name="l00962"></a>00962 <span class="preprocessor"></span>        <span class="comment">// Update reference point and scaling in stored Taylor model</span>
<a name="l00963"></a>00963         <span class="keywordflow">if</span>( !pNode-&gt;model()-&gt;TVxk[is][ix].env() ){
<a name="l00964"></a>00964           TVxk[is][ix] = pNode-&gt;model()-&gt;TVxk[is][ix];
<a name="l00965"></a>00965           <span class="keywordflow">continue</span>;
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967         pNode-&gt;model()-&gt;shift( is, ix, _pTM-&gt;reference(), _pTM-&gt;scaling(), coefupd );
<a name="l00968"></a>00968         TVxk[is][ix].set( _pTM );
<a name="l00969"></a>00969         TVxk[is][ix].set( coefupd );
<a name="l00970"></a>00970         TVxk[is][ix].set( pNode-&gt;model()-&gt;TVxk[is][ix].R() );
<a name="l00971"></a>00971 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Update: TVxk[&quot;</span> &lt;&lt; is &lt;&lt; <span class="stringliteral">&quot;][&quot;</span> &lt;&lt; ix &lt;&lt; <span class="stringliteral">&quot;] =&quot;</span> &lt;&lt; TVxk[is][ix];
<a name="l00973"></a>00973         { <span class="keywordtype">int</span> dum; std::cout &lt;&lt; <span class="stringliteral">&quot;\nPAUSED\n&quot;</span>; std::cin &gt;&gt; dum; }
<a name="l00974"></a>00974 <span class="preprocessor">#endif</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>      }
<a name="l00976"></a>00976     }
<a name="l00977"></a>00977     <span class="keyword">delete</span>[] coefupd;
<a name="l00978"></a>00978   }
<a name="l00979"></a>00979   
<a name="l00980"></a>00980   <span class="comment">// Compute state bounds at stage times</span>
<a name="l00981"></a>00981   <span class="keywordflow">else</span>{
<a name="l00982"></a>00982     failed = <span class="keyword">true</span>;
<a name="l00983"></a>00983     <span class="keywordflow">switch</span>( meth ){
<a name="l00984"></a>00984     <span class="keywordflow">case</span> Options::VERIF:
<a name="l00985"></a>00985       <span class="keywordflow">if</span>( _pODEBND_VAL-&gt;bounds( _data.ns, _data.tk, TVp, E(), TVxk, Exk )
<a name="l00986"></a>00986           == ODEBND_VAL&lt;T,PE&gt;::NORMAL ) failed = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l00987"></a>00987     <span class="keywordflow">case</span> Options::DINEQ: <span class="keywordflow">default</span>:
<a name="l00988"></a>00988       <span class="keywordflow">if</span>( _pODEBND_GSL-&gt;bounds( _data.ns, _data.tk, TVp, TVxk )
<a name="l00989"></a>00989           == ODEBND_GSL&lt;T,PE&gt;::NORMAL ) failed = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991     <span class="keywordflow">if</span>( failed ){
<a name="l00992"></a>00992       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] TVxk[is];
<a name="l00993"></a>00993       stats.cumul_ODEBND += time();
<a name="l00994"></a>00994       <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::FAILURE;
<a name="l00995"></a>00995     }
<a name="l00996"></a>00996 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l00997"></a>00997 <span class="preprocessor"></span>    std::cout &lt;&lt; *_pODEBND_VAL;
<a name="l00998"></a>00998 <span class="preprocessor">#endif</span>
<a name="l00999"></a>00999 <span class="preprocessor"></span>
<a name="l01000"></a>01000     <span class="comment">// Check if Taylor model has converged</span>
<a name="l01001"></a>01001     <span class="keywordflow">if</span>( options.REUSE_TMODEL_THRESHOLD &gt; 0. ){
<a name="l01002"></a>01002       TVxk_cvg = <span class="keyword">true</span>;
<a name="l01003"></a>01003       <span class="keywordtype">double</span> maxrem = 0.;
<a name="l01004"></a>01004       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; TVxk_cvg &amp;&amp; is&lt;=_data.ns; is++ )
<a name="l01005"></a>01005         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ ){
<a name="l01006"></a>01006           <span class="keywordflow">if</span>( Op&lt;T&gt;::diam(TVxk[is][ix].R()) &gt; maxrem ) maxrem = Op&lt;T&gt;::diam(TVxk[is][ix].R());
<a name="l01007"></a>01007           <span class="keywordflow">if</span>( Op&lt;T&gt;::diam(TVxk[is][ix].R()) &gt; options.REUSE_TMODEL_THRESHOLD ){
<a name="l01008"></a>01008             TVxk_cvg = <span class="keyword">false</span>;
<a name="l01009"></a>01009             <span class="keywordflow">break</span>;
<a name="l01010"></a>01010           }
<a name="l01011"></a>01011         }
<a name="l01012"></a>01012 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span>      std::cerr &lt;&lt; <span class="stringliteral">&quot;max. Taylor remainder: &quot;</span> &lt;&lt; maxrem &lt;&lt; std::endl;
<a name="l01014"></a>01014 <span class="preprocessor">#endif</span>
<a name="l01015"></a>01015 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( TVxk_cvg ){
<a name="l01016"></a>01016 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l01017"></a>01017 <span class="preprocessor"></span>        std::cerr &lt;&lt; <span class="stringliteral">&quot;converged Taylor remainder!\n&quot;</span>;
<a name="l01018"></a>01018         { <span class="keywordtype">int</span> dum; std::cin &gt;&gt; dum; }
<a name="l01019"></a>01019 <span class="preprocessor">#endif</span>
<a name="l01020"></a>01020 <span class="preprocessor"></span>        pNode-&gt;model() = <span class="keyword">new</span> TMNode&lt;T&gt;( TVxk, _pTM, _data.ns );
<a name="l01021"></a>01021         _TMNodeList.push_back( pNode-&gt;model() );
<a name="l01022"></a>01022       }
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   stats.cumul_ODEBND += time();
<a name="l01027"></a>01027   stats.cumul_FPREL  -= time();
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 <span class="comment">/*</span>
<a name="l01030"></a>01030 <span class="comment">    // Up to which order has the Taylor model converged?</span>
<a name="l01031"></a>01031 <span class="comment">    bool cvghot = true;</span>
<a name="l01032"></a>01032 <span class="comment">    double maxhot = 0.;</span>
<a name="l01033"></a>01033 <span class="comment">    for( unsigned int is=0; cvghot &amp;&amp; is&lt;=_data.ns; is++ )</span>
<a name="l01034"></a>01034 <span class="comment">      for( unsigned int ix=0; ix&lt;_nx; ix++ ){</span>
<a name="l01035"></a>01035 <span class="comment">        if( Op&lt;T&gt;::diam(pNode-&gt;model()-&gt;TVxk[is][ix].B(_pTM-&gt;nord())) &gt; maxhot )</span>
<a name="l01036"></a>01036 <span class="comment">          maxhot = Op&lt;T&gt;::diam(pNode-&gt;model()-&gt;TVxk[is][ix].B(_pTM-&gt;nord()));</span>
<a name="l01037"></a>01037 <span class="comment">        if( Op&lt;T&gt;::diam(pNode-&gt;model()-&gt;TVxk[is][ix].B(_pTM-&gt;nord())) &gt; options.REUSE_TMODEL_THRESHOLD ){</span>
<a name="l01038"></a>01038 <span class="comment">          cvghot = false;</span>
<a name="l01039"></a>01039 <span class="comment">          break;</span>
<a name="l01040"></a>01040 <span class="comment">        }</span>
<a name="l01041"></a>01041 <span class="comment">      }</span>
<a name="l01042"></a>01042 <span class="comment">//#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l01043"></a>01043 <span class="comment">      std::cerr &lt;&lt; &quot;max. Taylor H.O.T.: &quot; &lt;&lt; std::scientific &lt;&lt; std::setprecision(5) &lt;&lt; maxhot &lt;&lt; std::endl;</span>
<a name="l01044"></a>01044 <span class="comment">//#endif</span>
<a name="l01045"></a>01045 <span class="comment">*/</span>
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="comment">// Up to which order has the Taylor model converged?</span>
<a name="l01048"></a>01048   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TVxk_ordred = ( TVxk_cvg? _pTM-&gt;nord()+1: 0 );
<a name="l01049"></a>01049   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; TVxk_ordred &amp;&amp; is&lt;=_data.ns; is++ )
<a name="l01050"></a>01050     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++ ){
<a name="l01051"></a>01051       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ordred=1;
<a name="l01052"></a>01052       <span class="keywordflow">for</span>( ; ordred&lt;TVxk_ordred; ordred++ ){
<a name="l01053"></a>01053 <span class="preprocessor"> #ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l01054"></a>01054 <span class="preprocessor"></span>       std::cout &lt;&lt; is &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; ix &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>  &lt;&lt; _pTM-&gt;nord()+1-ordred &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> 
<a name="l01055"></a>01055                   &lt;&lt; TVxk[is][ix].B(_pTM-&gt;nord()+1-ordred)
<a name="l01056"></a>01056                   &lt;&lt; std::endl;
<a name="l01057"></a>01057 <span class="preprocessor">#endif</span>
<a name="l01058"></a>01058 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( Op&lt;T&gt;::diam(TVxk[is][ix].B(_pTM-&gt;nord()+1-ordred))
<a name="l01059"></a>01059             &gt; options.REUSE_TMODEL_THRESHOLD ) <span class="keywordflow">break</span>;
<a name="l01060"></a>01060       }
<a name="l01061"></a>01061       <span class="keywordflow">if</span>( ordred &lt; TVxk_ordred ) TVxk_ordred = ordred;
<a name="l01062"></a>01062     }
<a name="l01063"></a>01063 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG_TMNODE</span>
<a name="l01064"></a>01064 <span class="preprocessor"></span>  std::cerr &lt;&lt; <span class="stringliteral">&quot;Taylor model converged from order: &quot;</span> &lt;&lt; _pTM-&gt;nord()+1-TVxk_ordred &lt;&lt; std::endl;
<a name="l01065"></a>01065   <span class="comment">//{ int dum; std::cin &gt;&gt; dum; }</span>
<a name="l01066"></a>01066 <span class="preprocessor">#endif</span>
<a name="l01067"></a>01067 <span class="preprocessor"></span>
<a name="l01068"></a>01068   <span class="comment">// Set current independent variables (_pFPV) and state variables (FPVxk)</span>
<a name="l01069"></a>01069   <span class="comment">// in FPRelax</span>
<a name="l01070"></a>01070   <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS flag = _bound_output( TVp, TVxk );
<a name="l01071"></a>01071   <span class="keywordflow">if</span>( flag == SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED
<a name="l01072"></a>01072    &amp;&amp; options.USE_DOMAIN_REDUCTION ){
<a name="l01073"></a>01073     <span class="comment">// update parameters in FP representation</span>
<a name="l01074"></a>01074     _relaxation_setup( Ip );
<a name="l01075"></a>01075     <span class="comment">// adjust Taylor model order for polyhedral relaxation</span>
<a name="l01076"></a>01076     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TMFPord = ( TVxk_ordred? _pTM-&gt;nord()+1-TVxk_ordred: _pTM-&gt;nord() );
<a name="l01077"></a>01077     <span class="keywordflow">if</span>( _pTMFP-&gt;nord() != TMFPord ){
<a name="l01078"></a>01078       <span class="keyword">delete</span> _pTMFP;                <span class="comment">// this is a bit piggy...</span>
<a name="l01079"></a>01079       _pTMFP = <span class="keyword">new</span> TMFPVT( _IVPdepend.size(), TMFPord ); <span class="comment">// would be better to keep various</span>
<a name="l01080"></a>01080       _pTMFP-&gt;options = _pTM-&gt;options = *_pTMOpt;     <span class="comment">// _pTMFP with different orders</span>
<a name="l01081"></a>01081     }
<a name="l01082"></a>01082     <span class="comment">// Update Taylor model environment mc::TModel&lt; FPVar&lt;T&gt; &gt;</span>
<a name="l01083"></a>01083     _pFPR-&gt;update_TModel( _pTMFP, _pTM, _IVPparam );  
<a name="l01084"></a>01084     std::map&lt;int,bool&gt;&amp; PEdep = _PEstruct[1].dep();
<a name="l01085"></a>01085     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0, ixs=_np; !failed &amp;&amp; is&lt;=_data.ns; is++ )
<a name="l01086"></a>01086       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ix=0; ix&lt;_nx; ix++, ixs++ ){
<a name="l01087"></a>01087         <span class="keywordflow">if</span>( Op&lt;T&gt;::diam(TVxk[is][ix].B()) &gt;= <a class="code" href="classmc_1_1PESTRUCT.html#a7c0940f536bbf16b87af18a41c664e99" title="Infinity.">PESTRUCT::INF</a> ){
<a name="l01088"></a>01088           failed = <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l01089"></a>01089         }
<a name="l01090"></a>01090         std::map&lt;int,bool&gt;::iterator it = PEdep.find(ixs);
<a name="l01091"></a>01091         <span class="keywordflow">if</span>( it!=PEdep.end() )
<a name="l01092"></a>01092           FPVxk[is][ix] = FPVT( _pFPR, TVxk[is][ix], _pTMFP );
<a name="l01093"></a>01093       }
<a name="l01094"></a>01094   }
<a name="l01095"></a>01095   stats.cumul_FPREL += time();
<a name="l01096"></a>01096   
<a name="l01097"></a>01097   <span class="comment">// Clean-up</span>
<a name="l01098"></a>01098   <span class="keywordflow">if</span>( !TVxk_cvg ){
<a name="l01099"></a>01099     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] TVxk[is];
<a name="l01100"></a>01100     <span class="keyword">delete</span>[] TVxk;
<a name="l01101"></a>01101   }
<a name="l01102"></a>01102   <span class="keywordflow">return</span> flag;
<a name="l01103"></a>01103 }
<a name="l01104"></a>01104 
<a name="l01105"></a>01105 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01106"></a>01106 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l01107"></a>01107 ODEGPE&lt;T,PE&gt;::_bound_output
<a name="l01108"></a>01108 ( <span class="keyword">const</span> TVT*TVp, TVT* <span class="keyword">const</span>*TVxk )
<a name="l01109"></a>01109 {
<a name="l01110"></a>01110   <span class="keywordtype">bool</span> inner = <span class="keyword">true</span>;
<a name="l01111"></a>01111   <span class="keyword">typename</span> std::list&lt; Data &gt;::const_iterator cit = _data.Y-&gt;begin();
<a name="l01112"></a>01112   <span class="keywordflow">for</span>( ; cit != _data.Y-&gt;end(); ++cit ){
<a name="l01113"></a>01113     <span class="keywordflow">switch</span>( _bound_output( PE().OUT( (*cit).index, TVp, TVxk[(*cit).stage], (*cit).stage ).B(),
<a name="l01114"></a>01114                            (*cit).lower, (*cit).upper ) ){
<a name="l01115"></a>01115       <span class="keywordflow">case</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER:
<a name="l01116"></a>01116         <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER;
<a name="l01117"></a>01117       <span class="keywordflow">case</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED:
<a name="l01118"></a>01118         inner = <span class="keyword">false</span>; <span class="keywordflow">continue</span>;
<a name="l01119"></a>01119       <span class="keywordflow">case</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INNER:
<a name="l01120"></a>01120         <span class="keywordflow">default</span>: <span class="keywordflow">continue</span>;
<a name="l01121"></a>01121     }
<a name="l01122"></a>01122   }
<a name="l01123"></a>01123   <span class="keywordflow">return</span>( inner? SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INNER
<a name="l01124"></a>01124                : SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED );
<a name="l01125"></a>01125 }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01128"></a>01128 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l01129"></a>01129 ODEGPE&lt;T,PE&gt;::_bound_output
<a name="l01130"></a>01130 ( <span class="keyword">const</span> T&amp;Iyk, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp;lo, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp;up )
<a name="l01131"></a>01131 {
<a name="l01132"></a>01132   <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Iyk) &gt; up || Op&lt;T&gt;::u(Iyk) &lt; lo ){
<a name="l01133"></a>01133     <span class="comment">//std::cout &lt;&lt; Iyk &lt;&lt; &quot;  &lt;-&gt; &quot; &lt;&lt; T(lo,up) &lt;&lt; std::endl;</span>
<a name="l01134"></a>01134     <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER;
<a name="l01135"></a>01135   }
<a name="l01136"></a>01136   <span class="keywordflow">if</span>( Op&lt;T&gt;::l(Iyk) &lt; lo || Op&lt;T&gt;::u(Iyk) &gt; up )
<a name="l01137"></a>01137     <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED;
<a name="l01138"></a>01138   <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INNER;
<a name="l01139"></a>01139 }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01142"></a>01142 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01143"></a>01143 ODEGPE&lt;T,PE&gt;::_relaxation_setup
<a name="l01144"></a>01144 ( <span class="keyword">const</span> T*P )
<a name="l01145"></a>01145 {
<a name="l01146"></a>01146   <span class="comment">// Set current variables in FP representation</span>
<a name="l01147"></a>01147   _pFPR-&gt;reset();
<a name="l01148"></a>01148   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;_np; ip++ )
<a name="l01149"></a>01149     _pFPV[ip] = FPVT( _pFPR, ip, P[ip] );
<a name="l01150"></a>01150 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l01151"></a>01151 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;FPR:\n&quot;</span> &lt;&lt; *_pFPR;
<a name="l01152"></a>01152 <span class="preprocessor">#endif</span>
<a name="l01153"></a>01153 <span class="preprocessor"></span>}
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01156"></a>01156 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l01157"></a>01157 ODEGPE&lt;T,PE&gt;::_relax_outputs_constraints
<a name="l01158"></a>01158 ( FPVT*<span class="keyword">const</span>*FPVxk )
<a name="l01159"></a>01159 {
<a name="l01160"></a>01160   <span class="comment">// User constraints definition</span>
<a name="l01161"></a>01161   stats.cumul_FPREL -= time();
<a name="l01162"></a>01162   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ic=0; ic&lt;_nc; ic++ ){
<a name="l01163"></a>01163     std::pair&lt;FPVT,PESTRUCT::t_CTR&gt; pctr = PE().CTR( ic, _pFPV, FPVxk, _data.ns );
<a name="l01164"></a>01164     <span class="keywordflow">switch</span>( pctr.second ){
<a name="l01165"></a>01165       <span class="keywordflow">case</span> <a class="code" href="classmc_1_1PESTRUCT.html#acd631bea7e7b71521abfc441926c6cf5afde343e7f89919f909c2f04991f41fba" title="Equality constraint.">PESTRUCT::EQ</a>: _pFPR-&gt;add_constraint( pctr.first, FPRT::EQ, 0. ); <span class="keywordflow">break</span>;
<a name="l01166"></a>01166       <span class="keywordflow">case</span> <a class="code" href="classmc_1_1PESTRUCT.html#acd631bea7e7b71521abfc441926c6cf5a7b49391e3a80b2fb3777987eb14f7ec9" title="Inequality constraint.">PESTRUCT::LE</a>: _pFPR-&gt;add_constraint( pctr.first, FPRT::LE, 0. ); <span class="keywordflow">break</span>;
<a name="l01167"></a>01167       <span class="keywordflow">default</span>:           _pFPR-&gt;add_constraint( pctr.first, FPRT::GE, 0. ); <span class="keywordflow">break</span>;
<a name="l01168"></a>01168     }
<a name="l01169"></a>01169   }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171   <span class="comment">// Output constraints definition</span>
<a name="l01172"></a>01172   <span class="keyword">typename</span> std::list&lt; Data &gt;::const_iterator cit = _data.Y-&gt;begin();
<a name="l01173"></a>01173   <span class="keywordflow">for</span>( ; cit != _data.Y-&gt;end(); ++cit ){
<a name="l01174"></a>01174     FPVT pyk = PE().OUT( (*cit).index, _pFPV, FPVxk[(*cit).stage], (*cit).stage );
<a name="l01175"></a>01175     _pFPR-&gt;add_constraint( pyk, FPRT::LE, (*cit).upper );
<a name="l01176"></a>01176     _pFPR-&gt;add_constraint( pyk, FPRT::GE, (*cit).lower );
<a name="l01177"></a>01177   }
<a name="l01178"></a>01178   stats.cumul_FPREL += time();
<a name="l01179"></a>01179 
<a name="l01180"></a>01180   <span class="comment">// Node processing: Constraint propagation</span>
<a name="l01181"></a>01181   stats.cumul_REDUC -= time();
<a name="l01182"></a>01182   <span class="keywordflow">if</span> ( options.USE_CONSTRAINT_PROPAGATION &amp;&amp; !_pFPR-&gt;propagate_constraints() ){
<a name="l01183"></a>01183     stats.cumul_REDUC += time();
<a name="l01184"></a>01184     <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER;
<a name="l01185"></a>01185   }
<a name="l01186"></a>01186   stats.cumul_REDUC += time();
<a name="l01187"></a>01187 
<a name="l01188"></a>01188   <span class="comment">// Polyhedral relaxations</span>
<a name="l01189"></a>01189   stats.cumul_FPREL -= time();
<a name="l01190"></a>01190   _pFPR-&gt;generate_cuts();
<a name="l01191"></a>01191   <span class="keywordflow">if</span>( options.USE_RLT_TMODEL ) _pFPR-&gt;generate_RLT_TModel( _pTMFP );
<a name="l01192"></a>01192   stats.cumul_FPREL += time();
<a name="l01193"></a>01193 
<a name="l01194"></a>01194   <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED;
<a name="l01195"></a>01195 }
<a name="l01196"></a>01196 
<a name="l01197"></a>01197 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01198"></a>01198 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l01199"></a>01199 ODEGPE&lt;T,PE&gt;::_domain_reduction
<a name="l01200"></a>01200 ( FPVT*<span class="keyword">const</span>*FPVxk, T*P, <span class="keywordtype">double</span>&amp;maxred )
<a name="l01201"></a>01201 {
<a name="l01202"></a>01202   maxred = 0.;
<a name="l01203"></a>01203   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ip=0; ip&lt;_np; ip++ ){
<a name="l01204"></a>01204     T P0 = P[ip];
<a name="l01205"></a>01205     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ipb=0; ipb&lt;2; ipb++ ){
<a name="l01206"></a>01206       _pFPR-&gt;set_objective( (ipb? FPRT::MIN: FPRT::MAX), _pFPV[ip] );
<a name="l01207"></a>01207 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l01208"></a>01208 <span class="preprocessor"></span>      _pFPR-&gt;options.SOLVER_DISPLAY = <span class="keyword">true</span>;
<a name="l01209"></a>01209 <span class="preprocessor">#endif</span>
<a name="l01210"></a>01210 <span class="preprocessor"></span>      <span class="keywordflow">switch</span>( _pFPR-&gt;solve() ){
<a name="l01211"></a>01211 <span class="preprocessor">#ifdef USE_CPLEX</span>
<a name="l01212"></a>01212 <span class="preprocessor"></span>      <span class="keywordflow">case</span> IloAlgorithm::Optimal:
<a name="l01213"></a>01213 <span class="preprocessor">#else</span>
<a name="l01214"></a>01214 <span class="preprocessor"></span>      <span class="keywordflow">case</span> GRB_OPTIMAL:
<a name="l01215"></a>01215 <span class="preprocessor">#endif</span>
<a name="l01216"></a>01216 <span class="preprocessor"></span>        <span class="comment">// Update variable bounds</span>
<a name="l01217"></a>01217         <span class="keywordflow">switch</span>( ipb ){
<a name="l01218"></a>01218         <span class="keywordflow">case</span> 0: <span class="comment">// range upper bound</span>
<a name="l01219"></a>01219           <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter(  P[ip], P[ip],
<a name="l01220"></a>01220             T(-<a class="code" href="classmc_1_1PESTRUCT.html#a7c0940f536bbf16b87af18a41c664e99" title="Infinity.">PESTRUCT::INF</a>,_pFPR-&gt;get_objective()) ) ){
<a name="l01221"></a>01221             P[ip] = Op&lt;T&gt;::l( P[ip] );
<a name="l01222"></a>01222             <span class="comment">//for( unsigned int is=0; is&lt;=_data.ns; is++ ) delete[] FPVxk[is];</span>
<a name="l01223"></a>01223             <span class="comment">//throw Exceptions( Exceptions::REDUC );</span>
<a name="l01224"></a>01224             <span class="comment">//return SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INFEASIBLE;</span>
<a name="l01225"></a>01225           }
<a name="l01226"></a>01226           <span class="keywordflow">break</span>;
<a name="l01227"></a>01227         <span class="keywordflow">case</span> 1: <span class="comment">// range lower bound</span>
<a name="l01228"></a>01228           <span class="keywordflow">if</span>( !Op&lt;T&gt;::inter(  P[ip], P[ip],
<a name="l01229"></a>01229               T(_pFPR-&gt;get_objective(),<a class="code" href="classmc_1_1PESTRUCT.html#a7c0940f536bbf16b87af18a41c664e99" title="Infinity.">PESTRUCT::INF</a>) ) ){
<a name="l01230"></a>01230             P[ip] = Op&lt;T&gt;::u( P[ip] );
<a name="l01231"></a>01231             <span class="comment">//for( unsigned int is=0; is&lt;=_data.ns; is++ ) delete[] FPVxk[is];</span>
<a name="l01232"></a>01232             <span class="comment">//throw Exceptions( Exceptions::REDUC );</span>
<a name="l01233"></a>01233             <span class="comment">//return SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::INFEASIBLE;</span>
<a name="l01234"></a>01234           }
<a name="l01235"></a>01235           <span class="keywordflow">break</span>;
<a name="l01236"></a>01236         }
<a name="l01237"></a>01237         _pFPR-&gt;update_bounds( _pFPV[ip], P[ip] );
<a name="l01238"></a>01238 <span class="preprocessor">#ifdef MC__ODEGPE_DEBUG</span>
<a name="l01239"></a>01239 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;  P(&quot;</span> &lt;&lt; ip &lt;&lt; <span class="stringliteral">&quot;) = &quot;</span> &lt;&lt; P[ip] &lt;&lt; std::endl;
<a name="l01240"></a>01240 <span class="preprocessor">#endif</span>
<a name="l01241"></a>01241 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
<a name="l01242"></a>01242 <span class="preprocessor">#ifdef USE_CPLEX</span>
<a name="l01243"></a>01243 <span class="preprocessor"></span>      <span class="keywordflow">case</span> IloAlgorithm::Infeasible:
<a name="l01244"></a>01244       <span class="keywordflow">case</span> IloAlgorithm::InfeasibleOrUnbounded:
<a name="l01245"></a>01245 <span class="preprocessor">#else</span>
<a name="l01246"></a>01246 <span class="preprocessor"></span>      <span class="keywordflow">case</span> GRB_INFEASIBLE:
<a name="l01247"></a>01247       <span class="keywordflow">case</span> GRB_INF_OR_UNBD:
<a name="l01248"></a>01248 <span class="preprocessor">#endif</span>
<a name="l01249"></a>01249 <span class="preprocessor"></span><span class="preprocessor">#ifdef MC__ODEGPE_SHOW_FAILURE</span>
<a name="l01250"></a>01250 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Infeasible LP!\n&quot;</span>;
<a name="l01251"></a>01251 <span class="preprocessor">#endif</span>
<a name="l01252"></a>01252 <span class="preprocessor"></span>        <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::OUTER;
<a name="l01253"></a>01253       <span class="keywordflow">default</span>:
<a name="l01254"></a>01254 <span class="preprocessor">#ifdef MC__ODEGPE_SHOW_FAILURE</span>
<a name="l01255"></a>01255 <span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;FAILURE IN DOMAIN REDUCTION LP\n&quot;</span>; 
<a name="l01256"></a>01256 <span class="preprocessor">#endif</span>
<a name="l01257"></a>01257 <span class="preprocessor"></span>        <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::FAILURE;
<a name="l01258"></a>01258       }
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     maxred = std::max( 1.-Op&lt;T&gt;::diam(P[ip])/Op&lt;T&gt;::diam(P0), maxred );
<a name="l01261"></a>01261   }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263   <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED;
<a name="l01264"></a>01264 }
<a name="l01265"></a>01265 
<a name="l01266"></a>01266 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01267"></a>01267 <span class="keyword">inline</span> <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS
<a name="l01268"></a>01268 ODEGPE&lt;T,PE&gt;::assess
<a name="l01269"></a>01269 ( SetInvNode&lt;T,TMNode&lt;T&gt; &gt;*pNode )
<a name="l01270"></a>01270 {
<a name="l01271"></a>01271   <span class="comment">// Allocate variables for states in polyhedral relaxation</span>
<a name="l01272"></a>01272   stats.cumul_FPREL -= time();
<a name="l01273"></a>01273   FPVT* FPVxk[_data.ns];
<a name="l01274"></a>01274   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ )
<a name="l01275"></a>01275     FPVxk[is] = <span class="keyword">new</span> FPVT[_nx];
<a name="l01276"></a>01276   stats.cumul_FPREL += time();
<a name="l01277"></a>01277 
<a name="l01278"></a>01278   <span class="comment">// Main loop for relaxation and domain reduction</span>
<a name="l01279"></a>01279   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ired=0; !ired || ired &lt; options.DOMAIN_REDUCTION_MAXLOOPS; ired++ ){
<a name="l01280"></a>01280 
<a name="l01281"></a>01281     <span class="comment">// State relaxation, inclusion test, and polyhedral relaxation</span>
<a name="l01282"></a>01282     <span class="keyword">typename</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::STATUS status;
<a name="l01283"></a>01283     <span class="keywordflow">try</span>{
<a name="l01284"></a>01284       <span class="keywordflow">switch</span>( options.IVP_BOUNDING_TYPE ){
<a name="l01285"></a>01285       <span class="comment">// State polyhedral relaxations via Intervals</span>
<a name="l01286"></a>01286       <span class="keywordflow">case</span> Options::IA:
<a name="l01287"></a>01287         status = _bound_IVP_IA( pNode, FPVxk, options.IVP_BOUNDING_PROPAGATION ); <span class="keywordflow">break</span>;
<a name="l01288"></a>01288       <span class="comment">// State polyhedral relaxations via Taylor models</span>
<a name="l01289"></a>01289       <span class="keywordflow">case</span> Options::TM:
<a name="l01290"></a>01290         status = _bound_IVP_TM( pNode, FPVxk, options.IVP_BOUNDING_PROPAGATION ); <span class="keywordflow">break</span>;
<a name="l01291"></a>01291       <span class="keywordflow">default</span>:
<a name="l01292"></a>01292         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] FPVxk[is];
<a name="l01293"></a>01293         <span class="keywordflow">throw</span> Exceptions( Exceptions::UNDEF );
<a name="l01294"></a>01294       }
<a name="l01295"></a>01295 
<a name="l01296"></a>01296      <span class="comment">// Return (i) on failure; (ii) if status is established;</span>
<a name="l01297"></a>01297      <span class="comment">// or (iii) if domain reduction is not selected</span>
<a name="l01298"></a>01298      <span class="keywordflow">if</span>( status != SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED
<a name="l01299"></a>01299       || !options.USE_DOMAIN_REDUCTION ){
<a name="l01300"></a>01300         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] FPVxk[is];
<a name="l01301"></a>01301         <span class="keywordflow">return</span> status;
<a name="l01302"></a>01302       }
<a name="l01303"></a>01303     }
<a name="l01304"></a>01304     <span class="keywordflow">catch</span>(...){
<a name="l01305"></a>01305       <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::FAILURE;
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     <span class="comment">// Add user and output constraints to polyhedral relaxation</span>
<a name="l01309"></a>01309     status = _relax_outputs_constraints( FPVxk );
<a name="l01310"></a>01310     <span class="keywordflow">if</span>( status != SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED ){
<a name="l01311"></a>01311       <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] FPVxk[is];
<a name="l01312"></a>01312       <span class="keywordflow">return</span> status;
<a name="l01313"></a>01313     }
<a name="l01314"></a>01314 
<a name="l01315"></a>01315     <span class="comment">// Node processing: Domain reduction</span>
<a name="l01316"></a>01316     <span class="keywordflow">if</span>( options.USE_DOMAIN_REDUCTION &amp;&amp; ired &lt; options.DOMAIN_REDUCTION_MAXLOOPS ){
<a name="l01317"></a>01317       <span class="keywordtype">double</span> maxred;
<a name="l01318"></a>01318       stats.cumul_REDUC -= time();
<a name="l01319"></a>01319       status = _domain_reduction( FPVxk, pNode-&gt;P(), maxred );
<a name="l01320"></a>01320       stats.cumul_REDUC += time();
<a name="l01321"></a>01321       <span class="keywordflow">if</span>( status != SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::UNDETERMINED ){
<a name="l01322"></a>01322         <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] FPVxk[is];
<a name="l01323"></a>01323         <span class="keywordflow">return</span> status;
<a name="l01324"></a>01324       }
<a name="l01325"></a>01325 
<a name="l01326"></a>01326       <span class="comment">// Reconstruct lower bounding problem when sufficient tightening was achieved</span>
<a name="l01327"></a>01327 <span class="preprocessor">#ifdef MC__ODEGPE_SHOW_REDUCTION</span>
<a name="l01328"></a>01328 <span class="preprocessor"></span>      std::cerr &lt;&lt; <span class="stringliteral">&quot;max. domain reduction: &quot;</span> &lt;&lt; maxred &lt;&lt; std::endl;
<a name="l01329"></a>01329 <span class="preprocessor">#endif</span>
<a name="l01330"></a>01330 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( maxred &gt; options.DOMAIN_REDUCTION_THRESHOLD
<a name="l01331"></a>01331        &amp;&amp; ired+1 &lt; options.DOMAIN_REDUCTION_MAXLOOPS ) <span class="keywordflow">continue</span>;
<a name="l01332"></a>01332     }
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     <span class="comment">// Clean-up</span>
<a name="l01335"></a>01335     <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> is=0; is&lt;=_data.ns; is++ ) <span class="keyword">delete</span>[] FPVxk[is];
<a name="l01336"></a>01336     <span class="keywordflow">return</span> status;
<a name="l01337"></a>01337   }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 <span class="preprocessor">#ifdef MC__ODEGPE_SHOW_FAILURE</span>
<a name="l01340"></a>01340 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">&quot;FAILURE AT EXIT\n&quot;</span>; 
<a name="l01341"></a>01341 <span class="preprocessor">#endif</span>
<a name="l01342"></a>01342 <span class="preprocessor"></span>  <span class="keywordflow">return</span> SetInv&lt; T, SetInvNode&lt;T,TMNode&lt;T&gt; &gt;, lt_SetInvNode&lt;T,TMNode&lt;T&gt; &gt; &gt;::FAILURE;
<a name="l01343"></a>01343 }
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01346"></a>01346 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l01347"></a>01347 <a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ac8236cb27236222c2f0bb9eef8286853" title="Display.">ODEGPE&lt;T,PE&gt;::Options::display</a>
<a name="l01348"></a><a class="code" href="structmc_1_1ODEGPE_1_1Options.html#ac8236cb27236222c2f0bb9eef8286853">01348</a> ( std::ostream&amp;out ) <span class="keyword">const</span>
<a name="l01349"></a>01349 {
<a name="l01350"></a>01350   <span class="comment">// Display ODEGPE Options</span>
<a name="l01351"></a>01351   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  BOUNDER TYPE FOR PARAMETRIC IVP&quot;</span>;
<a name="l01352"></a>01352   <span class="keywordflow">switch</span>( IVP_BOUNDING_TYPE ){
<a name="l01353"></a>01353   <span class="keywordflow">case</span> IA:   out &lt;&lt; <span class="stringliteral">&quot;IA\n&quot;</span>;   <span class="keywordflow">break</span>;
<a name="l01354"></a>01354   <span class="keywordflow">case</span> TM:   out &lt;&lt; <span class="stringliteral">&quot;TM\n&quot;</span>;   <span class="keywordflow">break</span>;
<a name="l01355"></a>01355   }
<a name="l01356"></a>01356   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  BOUNDING STRATEGY FOR PARAMETRIC IVP&quot;</span>;
<a name="l01357"></a>01357   <span class="keywordflow">switch</span>( IVP_BOUNDING_PROPAGATION ){
<a name="l01358"></a>01358   <span class="keywordflow">case</span> DINEQ:   out &lt;&lt; <span class="stringliteral">&quot;DINEQ\n&quot;</span>;   <span class="keywordflow">break</span>;
<a name="l01359"></a>01359   <span class="keywordflow">case</span> VERIF:   out &lt;&lt; <span class="stringliteral">&quot;VERIF\n&quot;</span>;   <span class="keywordflow">break</span>;
<a name="l01360"></a>01360   }
<a name="l01361"></a>01361   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  ORDER OF TAYLOR MODEL&quot;</span>
<a name="l01362"></a>01362       &lt;&lt; TAYLOR_MODEL_ORDER &lt;&lt; std::endl;
<a name="l01363"></a>01363   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  THRESHOLD FOR REUSING A TAYLOR MODEL IN CHILDREN NODES&quot;</span>
<a name="l01364"></a>01364       &lt;&lt; std::scientific &lt;&lt; std::setprecision(1)
<a name="l01365"></a>01365       &lt;&lt; REUSE_TMODEL_THRESHOLD &lt;&lt; std::endl;
<a name="l01366"></a>01366   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  USE CONSTRAINT PROPAGATION?&quot;</span>
<a name="l01367"></a>01367       &lt;&lt; (USE_CONSTRAINT_PROPAGATION?<span class="stringliteral">&quot;Y\n&quot;</span>:<span class="stringliteral">&quot;N\n&quot;</span>);
<a name="l01368"></a>01368   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  USE OPTIMIZATION-BASED DOMAIN REDUCTION?&quot;</span>
<a name="l01369"></a>01369       &lt;&lt; (USE_DOMAIN_REDUCTION?<span class="stringliteral">&quot;Y\n&quot;</span>:<span class="stringliteral">&quot;N\n&quot;</span>);
<a name="l01370"></a>01370   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  OPTIMIZATION-BASED REDUCTION MAX LOOPS&quot;</span>
<a name="l01371"></a>01371       &lt;&lt; DOMAIN_REDUCTION_MAXLOOPS &lt;&lt; std::endl;
<a name="l01372"></a>01372   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  THRESHOLD FOR OPTIMIZATION-BASED REDUCTION LOOP&quot;</span>
<a name="l01373"></a>01373       &lt;&lt; std::fixed &lt;&lt; std::setprecision(0)
<a name="l01374"></a>01374       &lt;&lt; DOMAIN_REDUCTION_THRESHOLD*1e2 &lt;&lt; <span class="stringliteral">&quot;%\n&quot;</span>;
<a name="l01375"></a>01375   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  USE RLT TO TIGHTEN TAYLOR MODEL RELAXATIONS?&quot;</span>
<a name="l01376"></a>01376       &lt;&lt; (USE_RLT_TMODEL?<span class="stringliteral">&quot;Y\n&quot;</span>:<span class="stringliteral">&quot;N\n&quot;</span>);
<a name="l01377"></a>01377   out &lt;&lt; std::setw(60) &lt;&lt; <span class="stringliteral">&quot;  LP SOLVER FOR POLYHEDRAL RELAXATION&quot;</span>
<a name="l01378"></a>01378 <span class="preprocessor">#ifdef USE_CPLEX</span>
<a name="l01379"></a>01379 <span class="preprocessor"></span>      &lt;&lt; <span class="stringliteral">&quot;CPLEX\n&quot;</span>;
<a name="l01380"></a>01380 <span class="preprocessor">#else</span>
<a name="l01381"></a>01381 <span class="preprocessor"></span>      &lt;&lt; <span class="stringliteral">&quot;GUROBI\n&quot;</span>;
<a name="l01382"></a>01382 <span class="preprocessor">#endif</span>
<a name="l01383"></a>01383 <span class="preprocessor"></span>}
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> PE&gt;
<a name="l01386"></a>01386 <span class="keyword">inline</span> std::ostream&amp;
<a name="l01387"></a>01387 <span class="keyword">operator</span> &lt;&lt;
<a name="l01388"></a>01388 ( std::ostream&amp;out, <span class="keyword">const</span> <a class="code" href="classmc_1_1ODEGPE.html" title="C++ class for guaranteed parameter estimation in dynamic systems using set inversion techniques...">ODEGPE&lt;T,PE&gt;</a>&amp;pPE )
<a name="l01389"></a>01389 {
<a name="l01390"></a>01390   out &lt;&lt; std::endl
<a name="l01391"></a>01391       &lt;&lt; std::setfill(<span class="charliteral">&#39;_&#39;</span>) &lt;&lt; std::setw(72) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; std::setfill(<span class="charliteral">&#39; &#39;</span>)
<a name="l01392"></a>01392       &lt;&lt; std::setw(52) &lt;&lt; <span class="stringliteral">&quot;GUARANTEED PARAMETER ESTIMATION IN MC++\n&quot;</span>
<a name="l01393"></a>01393       &lt;&lt; std::setfill(<span class="charliteral">&#39;_&#39;</span>) &lt;&lt; std::setw(72) &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span> &lt;&lt; std::setfill(<span class="charliteral">&#39; &#39;</span>);
<a name="l01394"></a>01394 
<a name="l01395"></a>01395   <span class="comment">// Display ODEGPE Options</span>
<a name="l01396"></a>01396   out &lt;&lt; std::left &lt;&lt; <span class="stringliteral">&quot;SET INVERSION ALGORITHM OPTIONS:\n\n&quot;</span>;
<a name="l01397"></a>01397   pPE.SetInv&lt; T, <a class="code" href="classmc_1_1SetInvNode.html" title="C++ base class for set-inversion nodes.">SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt;, <a class="code" href="structmc_1_1lt__SetInvNode.html" title="C++ structure for comparing SetInv Nodes.">lt_SetInvNode&lt;T,TMNode&lt;T&gt;</a> &gt; &gt;::options.display( out );
<a name="l01398"></a>01398   pPE.ODEGPE&lt;T,PE&gt;::options.display( out );
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   out &lt;&lt; std::setfill(<span class="charliteral">&#39;_&#39;</span>) &lt;&lt; std::setw(72) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::setfill(<span class="charliteral">&#39; &#39;</span>)
<a name="l01401"></a>01401       &lt;&lt; std::endl &lt;&lt; std::endl;
<a name="l01402"></a>01402   <span class="keywordflow">return</span> out;
<a name="l01403"></a>01403 }
<a name="l01404"></a>01404 
<a name="l01405"></a>01405 } <span class="comment">// end namescape mc</span>
<a name="l01406"></a>01406 
<a name="l01407"></a>01407 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>odegpe.hpp</b>      </li>

    <li class="footer">Generated on Thu Feb 13 2014 20:08:11 for GOLIB by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
